{"version":3,"sources":["../../src/lang/GemlUtils.js"],"sourcesContent":["\"use strict\";\n\nconst { _ } = require('@genx/july');\nconst pluralize = require('pluralize');\n\nclass Clonable {\n    linked = false;\n\n    clone() {      \n        assert: this.linked, 'An element becomes clonable only after being linked.';\n    }\n}\n\nconst deepClone = (value) => _.cloneDeepWith(value, el => (el instanceof Clonable) ? el.clone() : undefined);\n\nconst deepCloneField = (src, dest, field) => {\n    if (field in src) dest[field] = deepClone(src[field]);\n};\n\nconst isDotSeparateName = (name) => (name.indexOf('.') > 0);\n\nconst extractDotSeparateName = (name) => name.split('.');\n\nconst extractReferenceBaseName = (name) => extractDotSeparateName(name).pop();\n\nconst prefixNaming = (prefix, name) => {\n    let leftParts = _.kebabCase(prefix).split('-');\n    let rightParts = _.kebabCase(extractReferenceBaseName(name)).split('-');\n    \n    let reservedLeft, reservedRight;\n\n    if (leftParts.length > rightParts.length) {\n        reservedLeft = leftParts.splice(0, leftParts.length - rightParts.length);\n        reservedRight = [];\n    } else {\n        reservedLeft = [];\n        reservedRight = rightParts.splice(leftParts.length, rightParts.length - leftParts.length);\n    }\n\n    const combine = () => _.camelCase(reservedLeft.concat(leftParts).concat(reservedRight).join('-'));\n\n    if (_.isEqual(leftParts, rightParts)) {\n        return combine();\n    }\n    \n    while (leftParts.length > 0) {\n        reservedLeft.push(leftParts.shift());\n        reservedRight.unshift(rightParts.pop());\n        if (_.isEqual(leftParts, rightParts)) {\n            break;\n        }\n    } \n\n    return combine();\n};\n\nconst getReferenceNameIfItIs = (obj) => {\n    if (_.isPlainObject(obj) && obj.oolType === 'ObjectReference') {\n        return extractDotSeparateName(obj.name)[0];\n    }\n\n    return undefined;\n};\n\nexports.parseReferenceInDocument = (schema, doc, ref) => {    \n    let parts = ref.split('.');\n    let parent;\n    let l = parts.length;\n    let entityNode, entity, field;\n    \n    for (let i = 0; i < l; i++) {\n        let p = parts[i];\n        \n        if (!entityNode) {\n            if (doc.entity === p) {\n                entityNode = doc;\n                continue;\n            }\n\n            throw new Error(`Reference by path \"${ref}\" not found in given document.`);\n        }\n\n        if (entityNode && p[0] === '$') {\n            entity = schema.entities[entityNode.entity];\n            let attr = entity.getEntityAttribute(p);\n\n            if (attr instanceof Field) {\n                field = attr;\n                if (i !== l-1) {\n                    throw new Error(`Reference by path \"${ref}\" not found in given document.`);\n                }\n\n                return {\n                    entityNode,\n                    entity,\n                    field\n                };\n            } else {\n                parent = attr;\n            }\n\n            continue;\n        }\n        \n        if (parent) {\n            parent = parent[p];\n        } else {\n            if (i === l-1) {\n                //last part\n                entity = schema.entities[entityNode.entity];\n                field = entity.getEntityAttribute(p);\n\n                return {\n                    entityNode,\n                    entity,\n                    field\n                };\n            }\n\n            entityNode = entityNode.subDocuments && entityNode.subDocuments[p];\n            if (!entityNode) {\n                throw new Error(`Reference by path \"${ref}\" not found in given document.`);\n            }\n        }\n    }\n\n    if (!field) {\n        if (typeof parent !== 'string') {\n            throw new Error(`Reference by path \"${ref}\" not found in given document.`);\n        }\n\n        if (!entity) {\n            throw new Error(`Reference by path \"${ref}\" not found in given document.`);\n        }\n\n        field = entity.getEntityAttribute(parent);\n        if (!(field instanceof Field)) {\n            throw new Error(`Reference by path \"${ref}\" not found in given document.`);\n        }\n    }\n    \n    return {\n        entityNode,\n        entity,\n        field\n    };\n};\n\nexports.pluralize = (name) => {\n    let parts = _.kebabCase(name).split('-');\n    let last = pluralize(parts.pop().toLowerCase());\n    parts.push(last);\n    return _.camelCase(parts.join('-'));\n};\n\nexports.deepClone = deepClone;\nexports.deepCloneField = deepCloneField;\nexports.isDotSeparateName = isDotSeparateName;\nexports.extractDotSeparateName = extractDotSeparateName;\nexports.extractReferenceBaseName = extractReferenceBaseName;\nexports.getReferenceNameIfItIs = getReferenceNameIfItIs;\nexports.schemaNaming = name => _.camelCase(name);\nexports.entityNaming = name => _.camelCase(name);\nexports.fieldNaming = name => _.camelCase(name);\nexports.prefixNaming = prefixNaming;\nexports.generateDisplayName = name => _.startCase(name);\nexports.formatFields = field => Array.isArray(field) ? field.join(', ') : field;\nexports.Clonable = Clonable;"],"names":["_","require","pluralize","Clonable","clone","assert","linked","deepClone","value","cloneDeepWith","el","undefined","deepCloneField","src","dest","field","isDotSeparateName","name","indexOf","extractDotSeparateName","split","extractReferenceBaseName","pop","prefixNaming","prefix","leftParts","kebabCase","rightParts","reservedLeft","reservedRight","length","splice","combine","camelCase","concat","join","isEqual","push","shift","unshift","getReferenceNameIfItIs","obj","isPlainObject","oolType","exports","parseReferenceInDocument","schema","doc","ref","parts","parent","l","entityNode","entity","i","p","Error","entities","attr","getEntityAttribute","Field","subDocuments","last","toLowerCase","schemaNaming","entityNaming","fieldNaming","generateDisplayName","startCase","formatFields","Array","isArray"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"AAAA;;;;;;;;;;;;;;AAEA,MAAM,EAAEA,CAAC,EAAE,GAAGC,QAAQ;AACtB,MAAMC,YAAYD,QAAQ;AAE1B,MAAME;IAGFC,QAAQ;QACJC,QAAQ,IAAI,CAACC,MAAM,EAAE;IACzB;;QAJAA,uBAAAA,UAAS;;AAKb;AAEA,MAAMC,YAAY,CAACC,QAAUR,EAAES,aAAa,CAACD,OAAOE,CAAAA,KAAM,AAACA,cAAcP,WAAYO,GAAGN,KAAK,KAAKO;AAElG,MAAMC,iBAAiB,CAACC,KAAKC,MAAMC;IAC/B,IAAIA,SAASF,KAAKC,IAAI,CAACC,MAAM,GAAGR,UAAUM,GAAG,CAACE,MAAM;AACxD;AAEA,MAAMC,oBAAoB,CAACC,OAAUA,KAAKC,OAAO,CAAC,OAAO;AAEzD,MAAMC,yBAAyB,CAACF,OAASA,KAAKG,KAAK,CAAC;AAEpD,MAAMC,2BAA2B,CAACJ,OAASE,uBAAuBF,MAAMK,GAAG;AAE3E,MAAMC,eAAe,CAACC,QAAQP;IAC1B,IAAIQ,YAAYzB,EAAE0B,SAAS,CAACF,QAAQJ,KAAK,CAAC;IAC1C,IAAIO,aAAa3B,EAAE0B,SAAS,CAACL,yBAAyBJ,OAAOG,KAAK,CAAC;IAEnE,IAAIQ,cAAcC;IAElB,IAAIJ,UAAUK,MAAM,GAAGH,WAAWG,MAAM,EAAE;QACtCF,eAAeH,UAAUM,MAAM,CAAC,GAAGN,UAAUK,MAAM,GAAGH,WAAWG,MAAM;QACvED,gBAAgB,EAAE;IACtB,OAAO;QACHD,eAAe,EAAE;QACjBC,gBAAgBF,WAAWI,MAAM,CAACN,UAAUK,MAAM,EAAEH,WAAWG,MAAM,GAAGL,UAAUK,MAAM;IAC5F;IAEA,MAAME,UAAU,IAAMhC,EAAEiC,SAAS,CAACL,aAAaM,MAAM,CAACT,WAAWS,MAAM,CAACL,eAAeM,IAAI,CAAC;IAE5F,IAAInC,EAAEoC,OAAO,CAACX,WAAWE,aAAa;QAClC,OAAOK;IACX;IAEA,MAAOP,UAAUK,MAAM,GAAG,EAAG;QACzBF,aAAaS,IAAI,CAACZ,UAAUa,KAAK;QACjCT,cAAcU,OAAO,CAACZ,WAAWL,GAAG;QACpC,IAAItB,EAAEoC,OAAO,CAACX,WAAWE,aAAa;YAClC;QACJ;IACJ;IAEA,OAAOK;AACX;AAEA,MAAMQ,yBAAyB,CAACC;IAC5B,IAAIzC,EAAE0C,aAAa,CAACD,QAAQA,IAAIE,OAAO,KAAK,mBAAmB;QAC3D,OAAOxB,uBAAuBsB,IAAIxB,IAAI,CAAC,CAAC,EAAE;IAC9C;IAEA,OAAON;AACX;AAEAiC,QAAQC,wBAAwB,GAAG,CAACC,QAAQC,KAAKC;IAC7C,IAAIC,QAAQD,IAAI5B,KAAK,CAAC;IACtB,IAAI8B;IACJ,IAAIC,IAAIF,MAAMnB,MAAM;IACpB,IAAIsB,YAAYC,QAAQtC;IAExB,IAAK,IAAIuC,IAAI,GAAGA,IAAIH,GAAGG,IAAK;QACxB,IAAIC,IAAIN,KAAK,CAACK,EAAE;QAEhB,IAAI,CAACF,YAAY;YACb,IAAIL,IAAIM,MAAM,KAAKE,GAAG;gBAClBH,aAAaL;gBACb;YACJ;YAEA,MAAM,IAAIS,MAAM,CAAC,mBAAmB,EAAER,IAAI,8BAA8B,CAAC;QAC7E;QAEA,IAAII,cAAcG,CAAC,CAAC,EAAE,KAAK,KAAK;YAC5BF,SAASP,OAAOW,QAAQ,CAACL,WAAWC,MAAM,CAAC;YAC3C,IAAIK,OAAOL,OAAOM,kBAAkB,CAACJ;YAErC,IAAIG,gBAAgBE,OAAO;gBACvB7C,QAAQ2C;gBACR,IAAIJ,MAAMH,IAAE,GAAG;oBACX,MAAM,IAAIK,MAAM,CAAC,mBAAmB,EAAER,IAAI,8BAA8B,CAAC;gBAC7E;gBAEA,OAAO;oBACHI;oBACAC;oBACAtC;gBACJ;YACJ,OAAO;gBACHmC,SAASQ;YACb;YAEA;QACJ;QAEA,IAAIR,QAAQ;YACRA,SAASA,MAAM,CAACK,EAAE;QACtB,OAAO;YACH,IAAID,MAAMH,IAAE,GAAG;gBACX,WAAW;gBACXE,SAASP,OAAOW,QAAQ,CAACL,WAAWC,MAAM,CAAC;gBAC3CtC,QAAQsC,OAAOM,kBAAkB,CAACJ;gBAElC,OAAO;oBACHH;oBACAC;oBACAtC;gBACJ;YACJ;YAEAqC,aAAaA,WAAWS,YAAY,IAAIT,WAAWS,YAAY,CAACN,EAAE;YAClE,IAAI,CAACH,YAAY;gBACb,MAAM,IAAII,MAAM,CAAC,mBAAmB,EAAER,IAAI,8BAA8B,CAAC;YAC7E;QACJ;IACJ;IAEA,IAAI,CAACjC,OAAO;QACR,IAAI,OAAOmC,WAAW,UAAU;YAC5B,MAAM,IAAIM,MAAM,CAAC,mBAAmB,EAAER,IAAI,8BAA8B,CAAC;QAC7E;QAEA,IAAI,CAACK,QAAQ;YACT,MAAM,IAAIG,MAAM,CAAC,mBAAmB,EAAER,IAAI,8BAA8B,CAAC;QAC7E;QAEAjC,QAAQsC,OAAOM,kBAAkB,CAACT;QAClC,IAAI,CAAEnC,CAAAA,iBAAiB6C,KAAI,GAAI;YAC3B,MAAM,IAAIJ,MAAM,CAAC,mBAAmB,EAAER,IAAI,8BAA8B,CAAC;QAC7E;IACJ;IAEA,OAAO;QACHI;QACAC;QACAtC;IACJ;AACJ;AAEA6B,QAAQ1C,SAAS,GAAG,CAACe;IACjB,IAAIgC,QAAQjD,EAAE0B,SAAS,CAACT,MAAMG,KAAK,CAAC;IACpC,IAAI0C,OAAO5D,UAAU+C,MAAM3B,GAAG,GAAGyC,WAAW;IAC5Cd,MAAMZ,IAAI,CAACyB;IACX,OAAO9D,EAAEiC,SAAS,CAACgB,MAAMd,IAAI,CAAC;AAClC;AAEAS,QAAQrC,SAAS,GAAGA;AACpBqC,QAAQhC,cAAc,GAAGA;AACzBgC,QAAQ5B,iBAAiB,GAAGA;AAC5B4B,QAAQzB,sBAAsB,GAAGA;AACjCyB,QAAQvB,wBAAwB,GAAGA;AACnCuB,QAAQJ,sBAAsB,GAAGA;AACjCI,QAAQoB,YAAY,GAAG/C,CAAAA,OAAQjB,EAAEiC,SAAS,CAAChB;AAC3C2B,QAAQqB,YAAY,GAAGhD,CAAAA,OAAQjB,EAAEiC,SAAS,CAAChB;AAC3C2B,QAAQsB,WAAW,GAAGjD,CAAAA,OAAQjB,EAAEiC,SAAS,CAAChB;AAC1C2B,QAAQrB,YAAY,GAAGA;AACvBqB,QAAQuB,mBAAmB,GAAGlD,CAAAA,OAAQjB,EAAEoE,SAAS,CAACnD;AAClD2B,QAAQyB,YAAY,GAAGtD,CAAAA,QAASuD,MAAMC,OAAO,CAACxD,SAASA,MAAMoB,IAAI,CAAC,QAAQpB;AAC1E6B,QAAQzC,QAAQ,GAAGA"}