{"version":3,"sources":["../../src/lang/Linker.js"],"sourcesContent":["\"use strict\";\n\nconst path = require(\"path\");\nconst { _ } = require(\"@genx/july\");\nconst { fs, glob } = require(\"@genx/sys\");\nconst { Types } = require(\"@genx/data\");\n\nconst Geml = require(\"./grammar/geml\");\nconst GemlParser = Geml.parser;\nconst GemlTypes = require(\"./GemlTypes\");\nconst Entity = require(\"./Entity\");\nconst Schema = require(\"./Schema\");\nconst View = require(\"./View\");\nconst Dataset = require(\"./Dataset\");\n\nconst ELEMENT_CLASS_MAP = {\n    [GemlTypes.Element.ENTITY]: Entity,\n    [GemlTypes.Element.VIEW]: View,\n    [GemlTypes.Element.DATASET]: Dataset,\n};\n\nconst GEML_SOURCE_EXT = \".geml\";\nconst BUILTINS_PATH = path.resolve(__dirname, \"builtins\");\n\n/**\n * Linker of geml\n * @class GemlLinker\n */\nclass Linker {\n    /**\n     * Get geml files\n     * @param {string} sourceDir\n     * @param {boolean} [useJsonSource]\n     * @param {boolean} [recursive]\n     * @returns {array} geml files\n     */\n    static getGemlFiles(sourceDir, useJsonSource, recursive) {\n        let pattern = \"*\" + GEML_SOURCE_EXT;\n\n        if (useJsonSource) {\n            pattern += \".json\";\n        }\n\n        if (recursive) {\n            pattern = \"**/\" + pattern;\n        }\n\n        return glob.sync(path.join(sourceDir, pattern), { nodir: true });\n    }\n\n    /**\n     * Compile and link geml files into schema objects\n     * @param {App} app\n     * @param {object} context\n     * @returns {object} map of schema name to object\n     */\n    static buildSchemaObjects(app, context) {\n        const schemaObjects = {};\n        const schemaFiles = Linker.getGemlFiles(context.gemlPath, context.useJsonSource);\n        schemaFiles.forEach((schemaFile) => {\n            const linker = new Linker(app, context);\n            linker.link(schemaFile);\n\n            _.forEach(linker.schemas, async (schemaObject, schemaName) => {\n                if (schemaObjects[schemaName]) {\n                    throw new Error(`Duplicate schema found: \"${schemaName}\".`);\n                }\n\n                schemaObjects[schemaName] = schemaObject;\n            });\n        });\n\n        return schemaObjects;\n    }\n\n    /**\n     * @param {ServiceContainer} app\n     * @param {object} context\n     * @property {string} context.gemlPath - Geml source files path\n     * @property {bool} [context.useJsonSource=false] - Use .json intermediate source file instead of .ool\n     * @property {bool} [context.saveIntermediate=false] - Save intermediate source file while linking\n     */\n    constructor(app, context) {\n        /**\n         * App\n         * @member {ServiceContainer}\n         */\n        this.app = app;\n\n        /**\n         * Geml source files path\n         * @member {string}\n         */\n        this.sourcePath = context.gemlPath;\n\n        /**\n         * Use json or ols\n         * @member {bool}\n         */\n        this.useJsonSource = context.useJsonSource;\n\n        /**\n         * Save intermediate files\n         * @member {bool}\n         */\n        this.saveIntermediate = context.saveIntermediate;\n\n        /**\n         * Linked schemas\n         * @member {object.<string, Schema>}\n         */\n        this.schemas = {};\n\n        /**\n         * Dependent packages\n         * @member {object.<string, string>}\n         */\n        this.dependencies = context.dependencies ?? {};\n\n        /**\n         * Parsed oolong files, path => module\n         * @member {object}\n         * @private\n         */\n        this._gemlModules = {};\n\n        /**\n         * Element cache, map of <referenceId, element> and <selfId, element>\n         * @member {object}\n         * @private\n         */\n        this._elementsCache = {};\n\n        /**\n         * Map of <referenceId, moduleId>\n         * @member {object}\n         * @private\n         */\n        this._mapOfReferenceToModuleId = {};\n\n        //this.entryModule\n        //this.customizeEntities\n    }\n\n    /**\n     * Write log\n     * @param {string} level\n     * @param {string} message\n     * @param {object} [data]\n     */\n    log(...args) {\n        this.app.log(...args);\n    }\n\n    /**\n     * Check whether a module is loaded\n     * @param {string} moduleId\n     * @returns {boolean}\n     */\n    isModuleLoaded(moduleId) {\n        return moduleId in this._gemlModules;\n    }\n\n    /**\n     * Get a loaded oolone module\n     * @param {string} moduleId\n     * @returns {object}\n     */\n    getModuleById(moduleId) {\n        return this._gemlModules[moduleId];\n    }\n\n    /**\n     * Start linking oolong files\n     * @param {string} entryFileName\n     */\n    link(entryFileName) {\n        // compile entry file\n        this.entryModule = this.loadModule(entryFileName);\n\n        if (!this.entryModule) {\n            throw new Error(`Cannot resolve file \"${entryFileName}\".`);\n        }\n\n        if (_.isEmpty(this.entryModule.schema)) {\n            throw new Error(\"No schema defined in entry file.\");\n        }\n\n        if (this.entryModule.overrides) {\n            if (this.entryModule.overrides.entities) {\n                this.customizeEntities = new Set(\n                    this.entryModule.overrides.entities.map((entityItem) => entityItem.entity)\n                );\n            }\n        }\n\n        // compile schemas\n        _.forOwn(this.entryModule.schema, (schemaInfo, schemaName) => {\n            let schema = new Schema(this, schemaName, schemaInfo);\n            schema.link();\n\n            this.schemas[schemaName] = schema;\n\n            if (this.saveIntermediate) {\n                let jsFile = path.resolve(this.sourcePath, entryFileName + \"-linked.json\");\n                fs.writeFileSync(jsFile, JSON.stringify(schema.toJSON(), null, 4));\n            }\n        });\n    }\n\n    /**\n     * Load a oolong module, return undefined if not exist\n     * @param {string} modulePath\n     * @returns {*}\n     */\n    loadModule(modulePath, packageName) {\n        modulePath = path.resolve(this.sourcePath, modulePath);\n\n        let id = this.getModuleIdByPath(modulePath);\n\n        if (this.isModuleLoaded(id)) {\n            return this.getModuleById(id);\n        }\n\n        if (!fs.existsSync(modulePath)) {\n            return undefined;\n        }\n\n        let gemlModule = this._compile(modulePath, packageName);\n\n        return (this._gemlModules[id] = gemlModule);\n    }\n\n    getTypeInfo(name, location) {\n        const gemlModule = this.getModuleById(location);\n        return gemlModule.type[name];\n    }\n\n    /**\n     * Track back the type derived chain.\n     * @param {object} gemlModule\n     * @param {object} info\n     * @returns {Array} [ derivedInfo, baseInfo ]\n     */\n    trackBackType(gemlModule, info) {\n        if (Types.Builtin.has(info.type)) {\n            return [info];\n        }\n\n        let baseInfo = this.loadElement(gemlModule, GemlTypes.Element.TYPE, info.type, true);\n        let backupBaseInfo = baseInfo.type !== info.type ? baseInfo : null;\n\n        if (!Types.Builtin.has(baseInfo.type)) {\n            //the base type is not a builtin type\n            let ownerModule = baseInfo.gemlModule;\n\n            let [rootTypeInfo] = this.trackBackType(ownerModule, baseInfo);\n\n            ownerModule.type[baseInfo.type] = rootTypeInfo;\n            baseInfo = rootTypeInfo;\n        } else {\n            backupBaseInfo = null;\n        }\n\n        let derivedInfo = {\n            ..._.cloneDeep(_.omit(baseInfo, [\"gemlModule\", \"modifiers\"])),\n            ..._.omit(info, [\"gemlModule\", \"type\", \"modifiers\"]),\n        };\n        if (baseInfo.modifiers || info.modifiers) {\n            derivedInfo.modifiers = [...(baseInfo.modifiers || []), ...(info.modifiers || [])];\n        }\n\n        if (!derivedInfo.subClass) {\n            derivedInfo.subClass = [];\n        }\n        derivedInfo.subClass.push(info.type);\n        return [derivedInfo, backupBaseInfo];\n    }\n\n    /**\n     * Translate an value by inferring all the references.\n     * @param {object} gemlModule\n     * @param {*} value\n     * @returns {*} - Translated value.\n     */\n    translateOolValue(gemlModule, value) {\n        if (_.isPlainObject(value)) {\n            if (value.oolType === GemlTypes.Lang.CONST_REF) {\n                let refedValue = this.loadElement(gemlModule, GemlTypes.Element.CONST, value.name, true);\n                let uniqueId = this.getElementUniqueId(gemlModule, GemlTypes.Element.CONST, value.name);\n                let ownerModule = this.getModuleById(this._mapOfReferenceToModuleId[uniqueId]);\n                return this.translateOolValue(ownerModule, refedValue);\n            } else if (value.oolType) {\n                throw new Error(`todo: translateOolValue with type: ${value.oolType}`);\n            }\n\n            return _.mapValues(value, (v) => this.translateOolValue(gemlModule, v));\n        }\n\n        if (Array.isArray(value)) {\n            return value.map((v) => this.translateOolValue(gemlModule, v));\n        }\n\n        return value;\n    }\n\n    /**\n     * Get the unique module id by source file path.\n     * @param {string} modulePath - The path of an oolong source file.\n     * @returns {string} - The module id.\n     */\n    getModuleIdByPath(modulePath) {\n        let isBuiltinEntity = _.startsWith(modulePath, BUILTINS_PATH);\n        return isBuiltinEntity\n            ? path.relative(BUILTINS_PATH, modulePath)\n            : \"./\" + path.relative(this.sourcePath, modulePath);\n    }\n\n    /**\n     * Get the unique name of an element.\n     * @param {object} refererModule\n     * @param {string} elementType\n     * @param {string} elementName\n     * @returns {string} - The unique name of an element.\n     */\n    getElementUniqueId(refererModule, elementType, elementName) {\n        return elementType + \":\" + elementName + \"<-\" + refererModule.id;\n    }\n\n    loadEntity(refererModule, elementName, throwOnMissing = true) {\n        return this.loadElement(refererModule, GemlTypes.Element.ENTITY, elementName, throwOnMissing);\n    }\n\n    loadType(refererModule, elementName, throwOnMissing = true) {\n        return this.loadElement(refererModule, GemlTypes.Element.TYPE, elementName, throwOnMissing);\n    }\n\n    loadDataset(refererModule, elementName, throwOnMissing = true) {\n        return this.loadElement(refererModule, GemlTypes.Element.DATASET, elementName, throwOnMissing);\n    }\n\n    loadView(refererModule, elementName, throwOnMissing = true) {\n        return this.loadElement(refererModule, GemlTypes.Element.VIEW, elementName, throwOnMissing);\n    }\n\n    /**\n     * Load an element based on the namespace chain.\n     * @param {object} refererModule\n     * @param {string} elementType\n     * @param {string} elementName\n     */\n    loadElement(refererModule, elementType, elementName, throwOnMissing) {\n        // the element id with type, should be unique among the whole schema\n        let uniqueId = this.getElementUniqueId(refererModule, elementType, elementName);\n\n        // the element id + referer\n        if (uniqueId in this._elementsCache) {\n            return this._elementsCache[uniqueId];\n        }\n\n        let targetModule;\n\n        if (elementType in refererModule && elementName in refererModule[elementType]) {\n            // see if it exists in the same module\n            targetModule = refererModule;\n        } else {\n            // search reversely by the namespaces\n            //this.log('verbose', `Searching ${elementType} \"${elementName}\" from \"${refererModule.id}\" ...`);\n\n            let index = _.findLastIndex(refererModule.namespace, (modulePath) => {\n                //this.log('debug', `Looking for ${elementType} \"${elementName}\" in \"${modulePath}\" ...`);\n                let packageName;\n\n                if (Array.isArray(modulePath)) {\n                    packageName = modulePath[1];\n                    modulePath = modulePath[0];\n                }\n\n                targetModule = this.loadModule(modulePath, packageName);\n                if (!targetModule) {\n                    return undefined;\n                }\n\n                return targetModule[elementType] && elementName in targetModule[elementType];\n            });\n\n            if (index === -1) {\n                if (throwOnMissing) {\n                    throw new Error(\n                        `${elementType} \"${elementName}\" not found in imported namespaces. Referer: ${refererModule.id}`\n                    );\n                }\n\n                return undefined;\n            }\n        }\n\n        let elementSelfId = elementType + \":\" + elementName + \"@\" + targetModule.id;\n        if (elementSelfId in this._elementsCache) {\n            // already initialized\n            return (this._elementsCache[uniqueId] = this._elementsCache[elementSelfId]);\n        }\n\n        this._mapOfReferenceToModuleId[uniqueId] = targetModule.id;\n\n        // retrieve the compiled info\n        let elementInfo = targetModule[elementType][elementName];\n        let element;\n\n        if (elementType === GemlTypes.Element.ENTITY && this.customizeEntities?.has(elementName)) {            \n            const overrideElement = this.loadElement(this.entryModule, GemlTypes.Element.ENTITY_OVERRIDE, elementName, true);\n\n            Entity.overrideEntityMeta(elementInfo, overrideElement);\n\n            //console.dir(elementInfo, { depth: 10 });\n        }\n\n        if (elementType in ELEMENT_CLASS_MAP) {\n            // element need linking\n            let ElementClass = ELEMENT_CLASS_MAP[elementType];\n\n            element = new ElementClass(this, elementName, targetModule, elementInfo);\n            element.link();\n        } else {\n            if (elementType === GemlTypes.Element.TYPE) {\n                element = {\n                    ...elementInfo,\n                    gemlModule: targetModule,\n                };\n            } else {\n                element = elementInfo;\n            }\n        }\n\n        this._elementsCache[elementSelfId] = element;\n        this._elementsCache[uniqueId] = element;\n\n        return element;\n    }\n\n    _compile(oolFile, packageName) {\n        let jsFile;\n\n        if (oolFile.endsWith(\".json\")) {\n            jsFile = oolFile;\n            oolFile = oolFile.substr(0, oolFile.length - 5);\n        } else {\n            jsFile = oolFile + \".json\";\n        }\n\n        let ool, searchExt;\n\n        if (this.useJsonSource) {\n            if (!fs.existsSync(jsFile)) {\n                throw new Error(`\"useJsonSource\" enabeld but json file \"${jsFile}\" not found.`);\n            }\n\n            ool = fs.readJsonSync(jsFile);\n            searchExt = GEML_SOURCE_EXT + \".json\";\n        } else {\n            try {\n                ool = GemlParser.parse(fs.readFileSync(oolFile, \"utf8\"));\n            } catch (error) {\n                throw new Error(`Failed to compile \"${oolFile}\".\\n${error.message || error}`);\n            }\n\n            if (!ool) {\n                throw new Error(\"Unknown error occurred while compiling: \" + oolFile);\n            }\n\n            searchExt = GEML_SOURCE_EXT;\n        }\n\n        let baseName = path.basename(oolFile, GEML_SOURCE_EXT);\n\n        let namespace = [];\n\n        let currentPath = path.dirname(oolFile);\n\n        /**\n         *\n         * @param {*} namespaces - Searching path\n         * @param {string} ns - Import line\n         * @param {*} recursive\n         */\n        function expandNs(namespaces, ns, recursive, packageName) {\n            let stats = fs.statSync(ns);\n\n            //import '/path/user.ool'\n            if (stats.isFile() && ns.endsWith(searchExt)) {\n                if (packageName) {\n                    namespaces.push([ns, packageName]);\n                } else {\n                    namespaces.push(ns);\n                }\n\n                return;\n            }\n\n            if (stats.isDirectory() && recursive) {\n                //resursive expand sub-directory\n                let files = fs.readdirSync(ns);\n                files.forEach((f) => expandNs(namespaces, path.join(ns, f), true, packageName));\n            }\n        }\n\n        if (ool.namespace) {\n            ool.namespace.forEach((ns) => {\n                let p;\n                let packageName;\n\n                const packageSep = ns.indexOf(\":\");\n                if (packageSep > 0) {\n                    //reference to a package\n                    packageName = ns.substring(0, packageSep);\n                    const pkgPath = this.dependencies[packageName];\n\n                    if (pkgPath == null) {\n                        throw new Error(\n                            `Package \"${packageName}\" not found in geml dependencies settings. Failed to compile ${oolFile}`\n                        );\n                    }\n\n                    ns = path.join(pkgPath, ns.substring(packageSep + 1));\n                }\n\n                if (ns.endsWith(\"/*\")) {\n                    p = path.resolve(currentPath, ns.substr(0, ns.length - 2));\n                    let files = fs.readdirSync(p);\n                    files.forEach((f) => expandNs(namespace, path.join(p, f), false, packageName));\n                } else if (ns.endsWith(\"/**\")) {\n                    p = path.resolve(currentPath, ns.substr(0, ns.length - 3));\n                    let files = fs.readdirSync(p);\n                    files.forEach((f) => expandNs(namespace, path.join(p, f), true, packageName));\n                } else {\n                    ns = path.resolve(currentPath, _.endsWith(ns, GEML_SOURCE_EXT) ? ns : ns + GEML_SOURCE_EXT);\n                    if (packageName) {\n                        namespace.push([ns, packageName]);\n                    } else {\n                        namespace.push(ns);\n                    }\n                }\n            });\n        }\n\n        ool.namespace = namespace;\n\n        ool.id = this.getModuleIdByPath(oolFile);\n        if (packageName) {\n            ool.packageName = packageName;\n        }\n        ool.name = baseName;\n\n        if (!this.useJsonSource && this.saveIntermediate) {\n            fs.writeFileSync(jsFile, JSON.stringify(ool, null, 4));\n        }\n\n        return ool;\n    }\n}\n\nmodule.exports = Linker;\n"],"names":["path","require","_","fs","glob","Types","Geml","GemlParser","parser","GemlTypes","Entity","Schema","View","Dataset","ELEMENT_CLASS_MAP","Element","ENTITY","VIEW","DATASET","GEML_SOURCE_EXT","BUILTINS_PATH","resolve","__dirname","Linker","getGemlFiles","sourceDir","useJsonSource","recursive","pattern","sync","join","nodir","buildSchemaObjects","app","context","schemaObjects","schemaFiles","gemlPath","forEach","schemaFile","linker","link","schemas","schemaObject","schemaName","Error","log","args","isModuleLoaded","moduleId","_gemlModules","getModuleById","entryFileName","entryModule","loadModule","isEmpty","schema","overrides","entities","customizeEntities","Set","map","entityItem","entity","forOwn","schemaInfo","saveIntermediate","jsFile","sourcePath","writeFileSync","JSON","stringify","toJSON","modulePath","packageName","id","getModuleIdByPath","existsSync","undefined","gemlModule","_compile","getTypeInfo","name","location","type","trackBackType","info","Builtin","has","baseInfo","loadElement","TYPE","backupBaseInfo","ownerModule","rootTypeInfo","derivedInfo","cloneDeep","omit","modifiers","subClass","push","translateOolValue","value","isPlainObject","oolType","Lang","CONST_REF","refedValue","CONST","uniqueId","getElementUniqueId","_mapOfReferenceToModuleId","mapValues","v","Array","isArray","isBuiltinEntity","startsWith","relative","refererModule","elementType","elementName","loadEntity","throwOnMissing","loadType","loadDataset","loadView","_elementsCache","targetModule","index","findLastIndex","namespace","elementSelfId","elementInfo","element","overrideElement","ENTITY_OVERRIDE","overrideEntityMeta","ElementClass","oolFile","endsWith","substr","length","ool","searchExt","readJsonSync","parse","readFileSync","error","message","baseName","basename","currentPath","dirname","expandNs","namespaces","ns","stats","statSync","isFile","isDirectory","files","readdirSync","f","p","packageSep","indexOf","substring","pkgPath","dependencies","constructor","module","exports"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}