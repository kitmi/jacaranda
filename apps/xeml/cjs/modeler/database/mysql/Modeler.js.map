{"version":3,"sources":["../../../../src/modeler/database/mysql/Modeler.js"],"sourcesContent":["\"use strict\";\n\nconst EventEmitter = require(\"events\");\nconst path = require(\"path\");\n\nconst { _, quote, pushIntoBucket, get, naming, bin2Hex } = require('@genx/july');\nconst { fs } = require('@genx/sys');\n\nconst GemlUtils = require(\"../../../lang/GemlUtils\");\nconst { pluralize, isDotSeparateName, extractDotSeparateName } = GemlUtils;\nconst Entity = require(\"../../../lang/Entity\");\nconst { Types } = require(\"@genx/data\");\n\nconst UNSUPPORTED_DEFAULT_VALUE = new Set([\"BLOB\", \"TEXT\", \"JSON\", \"GEOMETRY\"]);\n\n/**\n * Ooolong database modeler for mysql db.\n * @class\n */\nclass MySQLModeler {\n    /**\n     * @param {object} context\n     * @property {Linker} context.linker - Geml DSL linker\n     * @property {string} context.scriptPath - Generated script path\n     * @param {object} dbOptions\n     * @property {object} dbOptions.db\n     * @property {object} dbOptions.table\n     */\n    constructor(context, linker, connector, dbOptions) {\n        this.linker = linker;\n        this.outputPath = context.scriptPath;\n        this.connector = connector;\n\n        this._events = new EventEmitter();\n\n        this._dbOptions = dbOptions\n            ? {\n                  db: _.mapKeys(dbOptions.db, (value, key) => _.upperCase(key)),\n                  table: _.mapKeys(dbOptions.table, (value, key) => _.upperCase(key)),\n              }\n            : {};\n\n        this._references = {};\n        this._relationEntities = {};\n        this._processedRef = new Set();\n    }\n\n    modeling(schema, schemaToConnector, skipGeneration) {\n        if (!skipGeneration) {\n            this.linker.log(\"info\", 'Generating mysql scripts for schema \"' + schema.name + '\"...');\n        }\n\n        let modelingSchema = schema.clone();\n\n        this.linker.log(\"debug\", \"Building relations...\");\n\n        let pendingEntities = Object.keys(modelingSchema.entities);\n\n        while (pendingEntities.length > 0) {\n            let entityName = pendingEntities.shift();\n            let entity = modelingSchema.entities[entityName];\n\n            if (!_.isEmpty(entity.info.associations)) {\n                this.linker.log(\"debug\", `Processing associations of entity \"${entityName}\"...`);\n\n                let assocs = this._preProcessAssociations(entity);\n\n                let assocNames = assocs.reduce((result, v) => {\n                    result[v] = v;\n                    return result;\n                }, {});\n\n                entity.info.associations.forEach((assoc) =>\n                    this._processAssociation(modelingSchema, entity, assoc, assocNames, pendingEntities)\n                );\n            }\n        }\n\n        this._events.emit(\"afterRelationshipBuilding\");\n\n        // build SQL scripts\n        // change from database name to schema name\n        // let sqlFilesDir = path.join(\"mysql\", this.connector.database);   \n        let sqlFilesDir = path.join(\"mysql\", schema.name);        \n        let dbFilePath = path.join(sqlFilesDir, \"entities.sql\");\n        let fkFilePath = path.join(sqlFilesDir, \"relations.sql\");\n\n        let tableSQL = \"\",\n            relationSQL = \"\",\n            data = {};\n\n        //let mapOfEntityNameToCodeName = {};\n\n        _.each(modelingSchema.entities, (entity, entityName) => {\n            assert: entityName === entity.name;\n            //mapOfEntityNameToCodeName[entityName] = entity.code;\n\n            entity.addIndexes();\n\n            let result = MySQLModeler.complianceCheck(entity);\n            if (result.errors.length) {\n                let message = \"\";\n                if (result.warnings.length > 0) {\n                    message += \"Warnings: \\n\" + result.warnings.join(\"\\n\") + \"\\n\";\n                }\n                message += result.errors.join(\"\\n\");\n\n                throw new Error(message);\n            }\n\n            if (entity.features) {\n                _.forOwn(entity.features, (f, featureName) => {\n                    if (Array.isArray(f)) {\n                        f.forEach((ff) => this._featureReducer(modelingSchema, entity, featureName, ff));\n                    } else {\n                        this._featureReducer(modelingSchema, entity, featureName, f);\n                    }\n                });\n            }\n\n            if (!skipGeneration) {\n                tableSQL += this._createTableStatement(entityName, entity /*, mapOfEntityNameToCodeName*/) + \"\\n\";\n\n                if (entity.info.data) {\n                    entity.info.data.forEach(({ dataSet, runtimeEnv, records }) => {\n                        //intiSQL += `-- Initial data for entity: ${entityName}\\n`;\n\n                        let entityData = [];\n\n                        if (Array.isArray(records)) {\n                            records.forEach((record) => {\n                                if (!_.isPlainObject(record)) {\n                                    let fields = Object.keys(entity.fields);\n                                    if (fields.length !== 2) {\n                                        throw new Error(\n                                            `Invalid data syntax: entity \"${entity.name}\" has more than 2 fields.`\n                                        );\n                                    }\n\n                                    let keyField = entity.fields[fields[0]];\n\n                                    if (!keyField.auto && !keyField.defaultByDb) {\n                                        throw new Error(\n                                            `The key field \"${entity.name}\" has no default value or auto-generated value.`\n                                        );\n                                    }\n\n                                    record = { [fields[1]]: this.linker.translateOolValue(entity.gemlModule, record) };\n                                } else {\n                                    record = this.linker.translateOolValue(entity.gemlModule, record);\n                                }\n\n                                entityData.push(record);\n                            });\n                        } else {\n                            _.forOwn(records, (record, key) => {\n                                if (!_.isPlainObject(record)) {\n                                    let fields = Object.keys(entity.fields);\n                                    if (fields.length !== 2) {\n                                        throw new Error(\n                                            `Invalid data syntax: entity \"${entity.name}\" has more than 2 fields.`\n                                        );\n                                    }\n\n                                    record = {\n                                        [entity.key]: key,\n                                        [fields[1]]: this.linker.translateOolValue(entity.gemlModule, record),\n                                    };\n                                } else {\n                                    record = Object.assign(\n                                        { [entity.key]: key },\n                                        this.linker.translateOolValue(entity.gemlModule, record)\n                                    );\n                                }\n\n                                entityData.push(record);\n                                //intiSQL += 'INSERT INTO `' + entityName + '` SET ' + _.map(record, (v,k) => '`' + k + '` = ' + JSON.stringify(v)).join(', ') + ';\\n';\n                            });\n                        }\n\n                        if (!_.isEmpty(entityData)) {\n                            dataSet || (dataSet = \"_init\");\n                            runtimeEnv || (runtimeEnv = \"default\");\n\n                            let nodes = [dataSet, runtimeEnv];\n\n                            nodes.push(entityName);\n\n                            let key = nodes.join(\".\");\n\n                            pushIntoBucket(data, key, entityData, true);\n                        }\n                    });\n\n                    //intiSQL += '\\n';\n                }\n            }\n        });\n\n        if (!skipGeneration) {\n            _.forOwn(this._references, (refs, srcEntityName) => {\n                _.each(refs, (ref) => {\n                    relationSQL +=\n                        this._addForeignKeyStatement(\n                            srcEntityName,\n                            ref,\n                            schemaToConnector /*, mapOfEntityNameToCodeName*/\n                        ) + \"\\n\";\n                });\n            });\n\n            this._writeFile(path.join(this.outputPath, dbFilePath), tableSQL);\n            this._writeFile(path.join(this.outputPath, fkFilePath), relationSQL);\n\n            let initIdxFiles = {};\n\n            if (!_.isEmpty(data)) {\n                _.forOwn(data, (envData, dataSet) => {\n                    _.forOwn(envData, (entitiesData, runtimeEnv) => {\n                        _.forOwn(entitiesData, (records, entityName) => {\n                            let initFileName = `0-${entityName}.json`;\n\n                            let pathNodes = [sqlFilesDir, \"data\", dataSet || \"_init\"];\n\n                            if (runtimeEnv !== \"default\") {\n                                pathNodes.push(runtimeEnv);\n                            }\n\n                            let initFilePath = path.join(...pathNodes, initFileName);\n                            let idxFilePath = path.join(...pathNodes, \"index.list\");\n\n                            pushIntoBucket(initIdxFiles, [idxFilePath], initFileName);\n\n                            this._writeFile(\n                                path.join(this.outputPath, initFilePath),\n                                JSON.stringify({ [entityName]: records }, null, 4)\n                            );\n                        });\n                    });\n                });\n            }\n\n            //console.dir(initIdxFiles, {depth: 10});\n\n            _.forOwn(initIdxFiles, (list, filePath) => {\n                let idxFilePath = path.join(this.outputPath, filePath);\n\n                let manual = [];\n\n                if (fs.existsSync(idxFilePath)) {\n                    let lines = fs.readFileSync(idxFilePath, \"utf8\").split(\"\\n\");\n                    lines.forEach((line) => {\n                        if (!line.startsWith(\"0-\")) {\n                            manual.push(line);\n                        }\n                    });\n                }\n\n                this._writeFile(idxFilePath, list.concat(manual).join(\"\\n\"));\n            });\n\n            let funcSQL = \"\";\n\n            //process view\n            /*\n            _.each(modelingSchema.views, (view, viewName) => {\n                view.inferTypeInfo(modelingSchema);\n\n                funcSQL += `CREATE PROCEDURE ${dbService.getViewSPName(viewName)}(`;\n                \n                if (!_.isEmpty(view.params)) {\n                    let paramSQLs = [];\n                    view.params.forEach(param => {\n                        paramSQLs.push(`p${_.upperFirst(param.name)} ${MySQLModeler.columnDefinition(param, true)}`);\n                    });\n\n                    funcSQL += paramSQLs.join(', ');\n                }\n\n                funcSQL += `)\\nCOMMENT 'SP for view ${viewName}'\\nREADS SQL DATA\\nBEGIN\\n`;\n\n                funcSQL += this._viewDocumentToSQL(modelingSchema, view) + ';';\n\n                funcSQL += '\\nEND;\\n\\n';\n            });\n            */\n\n            let spFilePath = path.join(sqlFilesDir, \"procedures.sql\");\n            this._writeFile(path.join(this.outputPath, spFilePath), funcSQL);\n        }\n\n        return modelingSchema;\n    }\n\n    _toColumnReference(name) {\n        return { oorType: \"ColumnReference\", name };\n    }\n\n    _translateJoinCondition(context, localField, anchor, remoteField) {\n        if (Array.isArray(remoteField)) {\n            return remoteField.map((rf) => this._translateJoinCondition(context, localField, anchor, rf));\n        }\n\n        if (_.isPlainObject(remoteField)) {\n            let ret = { [localField]: this._toColumnReference(anchor + \".\" + remoteField.by) };\n            let withExtra = this._oolConditionToQueryCondition(context, remoteField.with);\n\n            if (localField in withExtra) {\n                return { $and: [ret, withExtra] };\n            }\n\n            return { ...ret, ...withExtra };\n        }\n\n        return { [localField]: this._toColumnReference(anchor + \".\" + remoteField) };\n    }\n\n    _getAllRelatedFields(remoteField) {\n        if (!remoteField) return undefined;\n\n        if (Array.isArray(remoteField)) {\n            return remoteField.map((rf) => this._getAllRelatedFields(rf));\n        }\n\n        if (_.isPlainObject(remoteField)) {\n            return remoteField.by;\n        }\n\n        return remoteField;\n    }\n\n    _preProcessAssociations(entity) {\n        return entity.info.associations.map((assoc) => {\n            if (assoc.srcField) return assoc.srcField;\n\n            if (assoc.type === \"hasMany\") {\n                return pluralize(assoc.destEntity);\n            }\n\n            return assoc.destEntity;\n        });\n    }\n\n    /**\n     * hasMany/hasOne - belongsTo\n     * hasMany/hasOne - hasMany/hasOne [by] [with]\n     * hasMany - semi connection\n     * refersTo - semi connection\n     *\n     * remoteField:\n     *   1. fieldName\n     *   2. array of fieldName\n     *   3. { by , with }\n     *   4. array of fieldName and { by , with } mixed\n     *\n     * @param {*} schema\n     * @param {*} entity\n     * @param {*} assoc\n     */\n    _processAssociation(schema, entity, assoc, assocNames, pendingEntities) {\n        let entityKeyField = entity.getKeyField();\n        assert: !Array.isArray(entityKeyField);\n\n        this.linker.log(\"debug\", `Processing \"${entity.name}\" ${JSON.stringify(assoc)}`);\n\n        let destEntityName = assoc.destEntity,\n            destEntity,\n            destEntityNameAsFieldName;\n\n        if (isDotSeparateName(destEntityName)) {\n            //cross db reference\n            let [destSchemaName, actualDestEntityName] = extractDotSeparateName(destEntityName);\n\n            let destSchema = schema.linker.schemas[destSchemaName];\n            if (!destSchema.linked) {\n                throw new Error(\n                    `The destination schema ${destSchemaName} has not been linked yet. Currently only support one-way reference for cross db relation.`\n                );\n            }\n\n            destEntity = destSchema.entities[actualDestEntityName];\n            destEntityNameAsFieldName = actualDestEntityName;\n        } else {\n            destEntity = schema.ensureGetEntity(entity.gemlModule, destEntityName, pendingEntities);\n            if (!destEntity) {\n                throw new Error(`Entity \"${entity.name}\" references to an unexisting entity \"${destEntityName}\".`);\n            }\n\n            destEntityNameAsFieldName = destEntityName;\n        }\n\n        if (!destEntity) {\n            throw new Error(`Entity \"${entity.name}\" references to an unexisting entity \"${destEntityName}\".`);\n        }\n\n        let destKeyField = destEntity.getKeyField();\n        assert: destKeyField,\n            `Empty key field \"${destEntity.keyField}\". Dest entity: ${destEntityName}, current entity: ${entity.name}`;\n\n        if (Array.isArray(destKeyField)) {\n            throw new Error(`Destination entity \"${destEntityName}\" with combination primary key is not supported.`);\n        }\n\n        switch (assoc.type) {\n            case \"hasOne\":\n            case \"hasMany\":\n                let includes;\n                let excludes = {\n                    types: [\"refersTo\"],\n                    association: assoc,\n                };\n\n                if (assoc.by) {\n                    excludes.types.push(\"belongsTo\");\n                    includes = {\n                        by: (cb) => cb && cb.split(\".\")[0] === assoc.by.split(\".\")[0],\n                    };\n\n                    if (assoc.with) {\n                        includes.with = assoc.with;\n                    }\n                } else {\n                    let remoteFields = this._getAllRelatedFields(assoc.remoteField);\n\n                    includes = {\n                        srcField: (remoteField) => {\n                            remoteField || (remoteField = entity.name);\n\n                            return (\n                                _.isNil(remoteFields) ||\n                                (Array.isArray(remoteFields)\n                                    ? remoteFields.indexOf(remoteField) > -1\n                                    : remoteFields === remoteField)\n                            );\n                        },\n                    };\n                }\n\n                let backRef = destEntity.getReferenceTo(entity.name, includes, excludes);\n                if (backRef) {\n                    if (backRef.type === \"hasMany\" || backRef.type === \"hasOne\") {\n                        if (!assoc.by) {\n                            throw new Error(\n                                '\"m2n\" association requires \"by\" property. Entity: ' +\n                                    entity.name +\n                                    \" destination: \" +\n                                    destEntityName\n                            );\n                        }\n\n                        // one/many to one/many relation\n\n                        let connectedByParts = assoc.by.split(\".\");\n                        assert: connectedByParts.length <= 2;\n\n                        // connected by field is usually a refersTo assoc\n                        let connectedByField = (connectedByParts.length > 1 && connectedByParts[1]) || entity.name;\n                        let connEntityName = GemlUtils.entityNaming(connectedByParts[0]);\n\n                        assert: connEntityName;\n\n                        let tag1 = `${entity.name}:${assoc.type === \"hasMany\" ? \"m\" : \"1\"}-${destEntityName}:${\n                            backRef.type === \"hasMany\" ? \"n\" : \"1\"\n                        } by ${connEntityName}`;\n                        let tag2 = `${destEntityName}:${backRef.type === \"hasMany\" ? \"m\" : \"1\"}-${entity.name}:${\n                            assoc.type === \"hasMany\" ? \"n\" : \"1\"\n                        } by ${connEntityName}`;\n\n                        if (assoc.srcField) {\n                            tag1 += \" \" + assoc.srcField;\n                        }\n\n                        if (backRef.srcField) {\n                            tag2 += \" \" + backRef.srcField;\n                        }\n\n                        if (this._processedRef.has(tag1) || this._processedRef.has(tag2)) {\n                            //already processed, skip\n                            return;\n                        }\n\n                        let connectedByParts2 = backRef.by.split(\".\");\n                        let connectedByField2 =\n                            (connectedByParts2.length > 1 && connectedByParts2[1]) || destEntityNameAsFieldName;\n\n                        if (connectedByField === connectedByField2) {\n                            throw new Error('Cannot use the same \"by\" field in a relation entity.');\n                        }\n\n                        let connEntity = schema.ensureGetEntity(entity.gemlModule, connEntityName, pendingEntities);\n                        if (!connEntity) {\n                            //create a\n                            connEntity = this._addRelationEntity(\n                                schema,\n                                connEntityName,\n                                entity.name,\n                                destEntityName,\n                                connectedByField,\n                                connectedByField2\n                            );\n                            pendingEntities.push(connEntity.name);\n                            this.linker.log(\"debug\", `New entity \"${connEntity.name}\" added by association.`);\n                        }\n\n                        this._updateRelationEntity(\n                            connEntity,\n                            entity,\n                            destEntity,\n                            entity.name,\n                            destEntityName,\n                            connectedByField,\n                            connectedByField2\n                        );\n\n                        let localFieldName = assoc.srcField || pluralize(destEntityNameAsFieldName);\n\n                        entity.addAssociation(localFieldName, {\n                            entity: connEntityName,\n                            key: connEntity.key,\n                            on: this._translateJoinCondition(\n                                { ...assocNames, [connEntityName]: localFieldName },\n                                entity.key,\n                                localFieldName,\n                                assoc.with\n                                    ? {\n                                          by: connectedByField,\n                                          with: assoc.with,\n                                      }\n                                    : connectedByField\n                            ),\n                            field: connectedByField,\n                            ...(assoc.type === \"hasMany\" ? { list: true } : {}),\n                            assoc: connectedByField2,\n                        });\n\n                        let remoteFieldName = backRef.srcField || pluralize(entity.name);\n\n                        destEntity.addAssociation(remoteFieldName, {\n                            entity: connEntityName,\n                            key: connEntity.key,\n                            on: this._translateJoinCondition(\n                                { ...assocNames, [connEntityName]: remoteFieldName },\n                                destEntity.key,\n                                remoteFieldName,\n                                backRef.with\n                                    ? {\n                                          by: connectedByField2,\n                                          with: backRef.with,\n                                      }\n                                    : connectedByField2\n                            ),\n                            field: connectedByField2,\n                            ...(backRef.type === \"hasMany\" ? { list: true } : {}),\n                            assoc: connectedByField,\n                        });\n\n                        this._processedRef.add(tag1);\n                        this.linker.log(\"verbose\", `Processed 2-way reference: ${tag1}`);\n\n                        this._processedRef.add(tag2);\n                        this.linker.log(\"verbose\", `Processed 2-way reference: ${tag2}`);\n                    } else if (backRef.type === \"belongsTo\") {\n                        if (assoc.by) {\n                            throw new Error(\"todo: belongsTo by. entity: \" + entity.name);\n                        } else {\n                            //leave it to the referenced entity\n                            let anchor =\n                                assoc.srcField ||\n                                (assoc.type === \"hasMany\"\n                                    ? pluralize(destEntityNameAsFieldName)\n                                    : destEntityNameAsFieldName);\n                            let remoteField = assoc.remoteField || backRef.srcField || entity.name;\n\n                            //check if the target entity has logical deletion feature\n                            if (destEntity.hasFeature(\"logicalDeletion\")) {\n                                let deletionCheck = {\n                                    oolType: \"BinaryExpression\",\n                                    operator: \"!=\",\n                                    left: {\n                                        oolType: \"ObjectReference\",\n                                        name: `${destEntityName}.${destEntity.features[\"logicalDeletion\"].field}`,\n                                    },\n                                    right: true,\n                                };\n\n                                if (_.isPlainObject(remoteField)) {\n                                    remoteField.with = {\n                                        oolType: \"LogicalExpression\",\n                                        operator: \"and\",\n                                        left: remoteField.with,\n                                        right: deletionCheck,\n                                    };\n                                } else if (assoc.with) {\n                                    assoc.with = {\n                                        oolType: \"LogicalExpression\",\n                                        operator: \"and\",\n                                        left: assoc.with,\n                                        right: deletionCheck,\n                                    };\n                                } else {\n                                    assoc.with = deletionCheck;\n                                }\n                            }\n\n                            entity.addAssociation(anchor, {\n                                entity: destEntityName,\n                                key: destEntity.key,\n                                on: this._translateJoinCondition(\n                                    { ...assocNames, [destEntityName]: anchor },\n                                    entity.key,\n                                    anchor,\n                                    assoc.with\n                                        ? {\n                                              by: remoteField,\n                                              with: assoc.with,\n                                          }\n                                        : remoteField\n                                ),\n                                ...(typeof remoteField === \"string\" ? { field: remoteField } : {}),\n                                ...(assoc.type === \"hasMany\" ? { list: true } : {}),\n                            });\n                        }\n                    } else {\n                        throw new Error(\n                            \"Unexpected path. Entity: \" +\n                                entity.name +\n                                \", association: \" +\n                                JSON.stringify(assoc, null, 2)\n                        );\n                    }\n                } else {\n                    // semi association\n\n                    let connectedByParts = assoc.by\n                        ? assoc.by.split(\".\")\n                        : [GemlUtils.prefixNaming(entity.name, destEntityName)];\n                    assert: connectedByParts.length <= 2;\n\n                    let connectedByField = (connectedByParts.length > 1 && connectedByParts[1]) || entity.name;\n                    let connEntityName = GemlUtils.entityNaming(connectedByParts[0]);\n\n                    assert: connEntityName;\n\n                    let tag1 = `${entity.name}:${\n                        assoc.type === \"hasMany\" ? \"m\" : \"1\"\n                    }-${destEntityName}:* by ${connEntityName}`;\n\n                    if (assoc.srcField) {\n                        tag1 += \" \" + assoc.srcField;\n                    }\n\n                    assert: !this._processedRef.has(tag1);\n\n                    let connEntity = schema.ensureGetEntity(entity.gemlModule, connEntityName, pendingEntities);\n                    if (!connEntity) {\n                        //create a\n                        connEntity = this._addRelationEntity(\n                            schema,\n                            connEntityName,\n                            entity.name,\n                            destEntityName,\n                            connectedByField,\n                            destEntityNameAsFieldName\n                        );\n                        pendingEntities.push(connEntity.name);\n                        this.linker.log(\"debug\", `New entity \"${connEntity.name}\" added by association.`);\n                    }\n\n                    //todo: get back ref from connection entity\n                    let connBackRef1 = connEntity.getReferenceTo(entity.name, {\n                        type: \"refersTo\",\n                        srcField: (f) => _.isNil(f) || f == connectedByField,\n                    });\n\n                    if (!connBackRef1) {\n                        throw new Error(\n                            `Cannot find back reference to \"${entity.name}\" from relation entity \"${connEntityName}\".`\n                        );\n                    }\n\n                    let connBackRef2 = connEntity.getReferenceTo(\n                        destEntityName,\n                        { type: \"refersTo\" },\n                        { association: connBackRef1 }\n                    );\n\n                    if (!connBackRef2) {\n                        throw new Error(\n                            `Cannot find back reference to \"${destEntityName}\" from relation entity \"${connEntityName}\".`\n                        );\n                    }\n\n                    let connectedByField2 = connBackRef2.srcField || destEntityNameAsFieldName;\n\n                    if (connectedByField === connectedByField2) {\n                        throw new Error(\n                            'Cannot use the same \"by\" field in a relation entity. Detail: ' +\n                                JSON.stringify({\n                                    src: entity.name,\n                                    dest: destEntityName,\n                                    srcField: assoc.srcField,\n                                    by: connectedByField,\n                                })\n                        );\n                    }\n\n                    this._updateRelationEntity(\n                        connEntity,\n                        entity,\n                        destEntity,\n                        entity.name,\n                        destEntityName,\n                        connectedByField,\n                        connectedByField2\n                    );\n\n                    let localFieldName = assoc.srcField || pluralize(destEntityNameAsFieldName);\n\n                    entity.addAssociation(localFieldName, {\n                        entity: connEntityName,\n                        key: connEntity.key,\n                        on: this._translateJoinCondition(\n                            {\n                                ...assocNames,\n                                [destEntityName]: localFieldName + \".\" + connectedByField2,\n                                [connEntityName]: localFieldName,\n                            },\n                            entity.key,\n                            localFieldName,\n                            assoc.with\n                                ? {\n                                      by: connectedByField,\n                                      with: assoc.with,\n                                  }\n                                : connectedByField\n                        ),\n                        field: connectedByField,\n                        ...(assoc.type === \"hasMany\" ? { list: true } : {}),\n                        assoc: connectedByField2,\n                    });\n\n                    this._processedRef.add(tag1);\n                    this.linker.log(\"verbose\", `Processed 1-way reference: ${tag1}`);\n                }\n\n                break;\n\n            case \"refersTo\":\n            case \"belongsTo\":\n                let localField = assoc.srcField || destEntityNameAsFieldName;\n                let destFieldName = destKeyField.name;\n                let referencedField = destKeyField;\n\n                if (assoc.type === \"refersTo\") {\n                    let tag = `${entity.name}:1-${destEntityName}:* ${localField}`;\n\n                    if (assoc.destField) {\n                        if (!destEntity.hasField(assoc.destField)) {\n                            throw new Error(\n                                `The field \"${assoc.destField}\" being referenced is not a field of entity \"${destEntityName}\".`\n                            );\n                        }\n\n                        destFieldName = assoc.destField;\n                        referencedField = destEntity.fields[destFieldName];\n                    }\n\n                    tag += \"->\" + assoc.destField;\n\n                    if (this._processedRef.has(tag)) {\n                        //already processed by connection, skip\n                        return;\n                    }\n\n                    this._processedRef.add(tag);\n                    this.linker.log(\"verbose\", `Processed week reference: ${tag}`);\n                }\n\n                let joinOn = { [localField]: this._toColumnReference(localField + \".\" + destFieldName) };\n\n                if (assoc.with) {\n                    Object.assign(\n                        joinOn,\n                        this._oolConditionToQueryCondition({ ...assocNames, [destEntityName]: localField }, assoc.with)\n                    );\n                }\n\n                entity.addAssocField(localField, destEntity, referencedField, assoc.fieldProps);\n                entity.addAssociation(localField, {\n                    type: assoc.type,\n                    entity: destEntityName,\n                    key: destEntity.key,\n                    field: destFieldName,\n                    on: joinOn,\n                });\n\n                //foreign key constraits\n                let localFieldObj = entity.fields[localField];\n\n                let constraints = {};\n\n                if (localFieldObj.constraintOnUpdate) {\n                    constraints.onUpdate = localFieldObj.constraintOnUpdate;\n                }\n\n                if (localFieldObj.constraintOnDelete) {\n                    constraints.onDelete = localFieldObj.constraintOnDelete;\n                }\n\n                if (assoc.type === \"belongsTo\") {\n                    constraints.onUpdate || (constraints.onUpdate = \"CASCADE\");\n                    constraints.onDelete || (constraints.onDelete = \"CASCADE\");\n                } else if (localFieldObj.optional) {\n                    constraints.onUpdate || (constraints.onUpdate = \"SET NULL\");\n                    constraints.onDelete || (constraints.onDelete = \"SET NULL\");\n                }\n\n                constraints.onUpdate || (constraints.onUpdate = \"NO ACTION\");\n                constraints.onDelete || (constraints.onDelete = \"NO ACTION\");\n\n                this._addReference(entity.name, localField, destEntityName, destFieldName, constraints);\n                break;\n        }\n    }\n\n    _oolConditionToQueryCondition(context, oolCon) {\n        assert: oolCon.oolType;\n\n        if (oolCon.oolType === \"BinaryExpression\") {\n            if (oolCon.operator === \"==\") {\n                let left = oolCon.left;\n                if (left.oolType && left.oolType === \"ObjectReference\") {\n                    left = this._translateReference(context, left.name, true);\n                }\n\n                let right = oolCon.right;\n                if (right.oolType && right.oolType === \"ObjectReference\") {\n                    right = this._translateReference(context, right.name);\n                }\n\n                return {\n                    [left]: { $eq: right },\n                };\n            } else if (oolCon.operator === \"!=\") {\n                let left = oolCon.left;\n                if (left.oolType && left.oolType === \"ObjectReference\") {\n                    left = this._translateReference(context, left.name, true);\n                }\n\n                let right = oolCon.right;\n                if (right.oolType && right.oolType === \"ObjectReference\") {\n                    right = this._translateReference(context, right.name);\n                }\n\n                return {\n                    [left]: { $ne: right },\n                };\n            }\n        } else if (oolCon.oolType === \"UnaryExpression\") {\n            let arg;\n\n            switch (oolCon.operator) {\n                case \"is-null\":\n                    arg = oolCon.argument;\n                    if (arg.oolType && arg.oolType === \"ObjectReference\") {\n                        arg = this._translateReference(context, arg.name, true);\n                    }\n\n                    return {\n                        [arg]: { $eq: null },\n                    };\n\n                case \"is-not-null\":\n                    arg = oolCon.argument;\n                    if (arg.oolType && arg.oolType === \"ObjectReference\") {\n                        arg = this._translateReference(context, arg.name, true);\n                    }\n\n                    return {\n                        [arg]: { $ne: null },\n                    };\n\n                default:\n                    throw new Error(\"Unknown UnaryExpression operator: \" + oolCon.operator);\n            }\n        } else if (oolCon.oolType === \"LogicalExpression\") {\n            switch (oolCon.operator) {\n                case \"and\":\n                    return {\n                        $and: [\n                            this._oolConditionToQueryCondition(context, oolCon.left),\n                            this._oolConditionToQueryCondition(context, oolCon.right),\n                        ],\n                    };\n\n                case \"or\":\n                    return {\n                        $or: [\n                            this._oolConditionToQueryCondition(context, oolCon.left),\n                            this._oolConditionToQueryCondition(context, oolCon.right),\n                        ],\n                    };\n            }\n        }\n\n        throw new Error(\"Unknown syntax: \" + JSON.stringify(oolCon));\n    }\n\n    _translateReference(context, ref, asKey) {\n        let [base, ...other] = ref.split(\".\");\n\n        let translated = context[base];\n        if (!translated) {\n            console.log(context);\n            throw new Error(`Referenced object \"${ref}\" not found in context.`);\n        }\n\n        let refName = [translated, ...other].join(\".\");\n\n        if (asKey) {\n            return refName;\n        }\n\n        return this._toColumnReference(refName);\n    }\n\n    _addReference(left, leftField, right, rightField, constraints) {\n        if (Array.isArray(leftField)) {\n            leftField.forEach((lf) => this._addReference(left, lf, right, rightField, constraints));\n            return;\n        }\n\n        if (_.isPlainObject(leftField)) {\n            this._addReference(left, leftField.by, right.rightField, constraints);\n            return;\n        }\n\n        assert: typeof leftField === \"string\";\n\n        let refs4LeftEntity = this._references[left];\n        if (!refs4LeftEntity) {\n            refs4LeftEntity = [];\n            this._references[left] = refs4LeftEntity;\n        } else {\n            let found = _.find(\n                refs4LeftEntity,\n                (item) => item.leftField === leftField && item.right === right && item.rightField === rightField\n            );\n\n            if (found) return;\n        }\n\n        refs4LeftEntity.push({ leftField, right, rightField, constraints });\n    }\n\n    _getReferenceOfField(left, leftField) {\n        let refs4LeftEntity = this._references[left];\n        if (!refs4LeftEntity) {\n            return undefined;\n        }\n\n        let reference = _.find(refs4LeftEntity, (item) => item.leftField === leftField);\n\n        if (!reference) {\n            return undefined;\n        }\n\n        return reference;\n    }\n\n    _hasReferenceOfField(left, leftField) {\n        let refs4LeftEntity = this._references[left];\n        if (!refs4LeftEntity) return false;\n\n        return undefined !== _.find(refs4LeftEntity, (item) => item.leftField === leftField);\n    }\n\n    _getReferenceBetween(left, right) {\n        let refs4LeftEntity = this._references[left];\n        if (!refs4LeftEntity) {\n            return undefined;\n        }\n\n        let reference = _.find(refs4LeftEntity, (item) => item.right === right);\n\n        if (!reference) {\n            return undefined;\n        }\n\n        return reference;\n    }\n\n    _hasReferenceBetween(left, right) {\n        let refs4LeftEntity = this._references[left];\n        if (!refs4LeftEntity) return false;\n\n        return undefined !== _.find(refs4LeftEntity, (item) => item.right === right);\n    }\n\n    _featureReducer(schema, entity, featureName, feature) {\n        let field;\n\n        switch (featureName) {\n            case \"autoId\":\n                field = entity.fields[feature.field];\n\n                if (field.type === \"integer\" && !field.generator) {\n                    field.autoIncrementId = true;\n                    if (\"startFrom\" in feature) {\n                        this._events.once(\"setTableOptions:\" + entity.name, (extraOpts) => {\n                            extraOpts[\"AUTO_INCREMENT\"] = feature.startFrom;\n                        });\n                    }\n                }\n                break;\n\n            case \"createTimestamp\":\n                field = entity.fields[feature.field];\n                field.isCreateTimestamp = true;\n                break;\n\n            case \"updateTimestamp\":\n                field = entity.fields[feature.field];\n                field.isUpdateTimestamp = true;\n                break;\n\n            case \"userEditTracking\":\n                break;\n\n            case \"logicalDeletion\":\n                break;\n\n            case \"atLeastOneNotNull\":\n                break;\n\n            case \"validateAllFieldsOnCreation\":\n                break;\n\n            case \"stateTracking\":\n                break;\n\n            case \"i18n\":\n                break;\n\n            case \"changeLog\":\n                let changeLogSettings = get(schema.deploymentSettings, \"features.changeLog\");\n\n                if (!changeLogSettings) {\n                    throw new Error(\n                        `Missing \"changeLog\" feature settings in deployment config for schema [${schema.name}].`\n                    );\n                }\n\n                if (!changeLogSettings.dataSource) {\n                    throw new Error(`\"changeLog.dataSource\" is required. Schema: ${schema.name}`);\n                }\n\n                Object.assign(feature, changeLogSettings);\n                break;\n\n            default:\n                throw new Error('Unsupported feature \"' + featureName + '\".');\n        }\n    }\n\n    _writeFile(filePath, content) {\n        fs.ensureFileSync(filePath);\n        fs.writeFileSync(filePath, content);\n\n        this.linker.log(\"info\", \"Generated db script: \" + filePath);\n    }\n\n    _addRelationEntity(\n        schema,\n        relationEntityName,\n        entity1Name /* for cross db */,\n        entity2Name /* for cross db */,\n        entity1RefField,\n        entity2RefField\n    ) {\n        let entityInfo = {\n            features: [\"autoId\", \"createTimestamp\"],\n            indexes: [\n                {\n                    fields: [entity1RefField, entity2RefField],\n                    unique: true,\n                },\n            ],\n            associations: [\n                {\n                    type: \"refersTo\",\n                    destEntity: entity1Name,\n                    srcField: entity1RefField,\n                },\n                {\n                    type: \"refersTo\",\n                    destEntity: entity2Name,\n                    srcField: entity2RefField,\n                },\n            ],\n        };\n\n        let entity = new Entity(this.linker, relationEntityName, schema.gemlModule, entityInfo);\n        entity.link();\n\n        schema.addEntity(entity);\n\n        return entity;\n    }\n\n    /**\n     *\n     * @param {*} relationEntity\n     * @param {*} entity1\n     * @param {*} entity2\n     * @param {*} entity1Name\n     * @param {*} entity2Name\n     * @param {*} connectedByField\n     * @param {*} connectedByField2\n     */\n    _updateRelationEntity(\n        relationEntity,\n        entity1,\n        entity2,\n        entity1Name /* for cross db */,\n        entity2Name /* for cross db */,\n        connectedByField,\n        connectedByField2\n    ) {\n        let relationEntityName = relationEntity.name;\n\n        this._relationEntities[relationEntityName] = true;\n\n        if (relationEntity.info.associations) {\n            // check if the relation entity has the refersTo both side of associations\n            let hasRefToEntity1 = false,\n                hasRefToEntity2 = false;\n\n            _.each(relationEntity.info.associations, (assoc) => {\n                if (\n                    assoc.type === \"refersTo\" &&\n                    assoc.destEntity === entity1Name &&\n                    (assoc.srcField || entity1Name) === connectedByField\n                ) {\n                    hasRefToEntity1 = true;\n                }\n\n                if (\n                    assoc.type === \"refersTo\" &&\n                    assoc.destEntity === entity2Name &&\n                    (assoc.srcField || entity2Name) === connectedByField2\n                ) {\n                    hasRefToEntity2 = true;\n                }\n            });\n\n            if (hasRefToEntity1 && hasRefToEntity2) {\n                //yes, don't need to add refersTo to the relation entity\n                return;\n            }\n        }\n\n        let tag1 = `${relationEntityName}:1-${entity1Name}:* ${connectedByField}`;\n        let tag2 = `${relationEntityName}:1-${entity2Name}:* ${connectedByField2}`;\n\n        if (this._processedRef.has(tag1)) {\n            assert: this._processedRef.has(tag2);\n\n            //already processed, skip\n            return;\n        }\n\n        this._processedRef.add(tag1);\n        this.linker.log(\"verbose\", `Processed bridging reference: ${tag1}`);\n\n        this._processedRef.add(tag2);\n        this.linker.log(\"verbose\", `Processed bridging reference: ${tag2}`);\n\n        let keyEntity1 = entity1.getKeyField();\n        if (Array.isArray(keyEntity1)) {\n            throw new Error(`Combination primary key is not supported. Entity: ${entity1Name}`);\n        }\n\n        let keyEntity2 = entity2.getKeyField();\n        if (Array.isArray(keyEntity2)) {\n            throw new Error(`Combination primary key is not supported. Entity: ${entity2Name}`);\n        }\n\n        relationEntity.addAssocField(connectedByField, entity1, keyEntity1);\n        relationEntity.addAssocField(connectedByField2, entity2, keyEntity2);\n\n        relationEntity.addAssociation(connectedByField, { entity: entity1Name });\n        relationEntity.addAssociation(connectedByField2, { entity: entity2Name });\n\n        let allCascade = { onUpdate: \"RESTRICT\", onDelete: \"RESTRICT\" };\n\n        this._addReference(relationEntityName, connectedByField, entity1Name, keyEntity1.name, allCascade);\n        this._addReference(relationEntityName, connectedByField2, entity2Name, keyEntity2.name, allCascade);\n    }\n\n    static oolOpToSql(op) {\n        switch (op) {\n            case \"=\":\n                return \"=\";\n\n            default:\n                throw new Error(\"oolOpToSql to be implemented.\");\n        }\n    }\n\n    static oolToSql(schema, doc, ool, params) {\n        if (!ool.oolType) {\n            return ool;\n        }\n\n        switch (ool.oolType) {\n            case \"BinaryExpression\":\n                let left, right;\n\n                if (ool.left.oolType) {\n                    left = MySQLModeler.oolToSql(schema, doc, ool.left, params);\n                } else {\n                    left = ool.left;\n                }\n\n                if (ool.right.oolType) {\n                    right = MySQLModeler.oolToSql(schema, doc, ool.right, params);\n                } else {\n                    right = ool.right;\n                }\n\n                return left + \" \" + MySQLModeler.oolOpToSql(ool.operator) + \" \" + right;\n\n            case \"ObjectReference\":\n                if (!GemlUtils.isMemberAccess(ool.name)) {\n                    if (params && _.find(params, (p) => p.name === ool.name) !== -1) {\n                        return \"p\" + _.upperFirst(ool.name);\n                    }\n\n                    throw new Error(`Referencing to a non-existing param \"${ool.name}\".`);\n                }\n\n                let { entityNode, entity, field } = GemlUtils.parseReferenceInDocument(schema, doc, ool.name);\n\n                return entityNode.alias + \".\" + MySQLModeler.quoteIdentifier(field.name);\n\n            default:\n                throw new Error(\"oolToSql to be implemented.\");\n        }\n    }\n\n    static _orderByToSql(schema, doc, ool) {\n        return (\n            MySQLModeler.oolToSql(schema, doc, { oolType: \"ObjectReference\", name: ool.field }) +\n            (ool.ascend ? \"\" : \" DESC\")\n        );\n    }\n\n    _viewDocumentToSQL(modelingSchema, view) {\n        let sql = \"  \";\n        //console.log('view: ' + view.name);\n        let doc = _.cloneDeep(view.getDocumentHierarchy(modelingSchema));\n        //console.dir(doc, {depth: 8, colors: true});\n\n        //let aliasMapping = {};\n        let [colList, alias, joins] = this._buildViewSelect(modelingSchema, doc, 0);\n\n        sql += \"SELECT \" + colList.join(\", \") + \" FROM \" + MySQLModeler.quoteIdentifier(doc.entity) + \" AS \" + alias;\n\n        if (!_.isEmpty(joins)) {\n            sql += \" \" + joins.join(\" \");\n        }\n\n        if (!_.isEmpty(view.selectBy)) {\n            sql +=\n                \" WHERE \" +\n                view.selectBy\n                    .map((select) => MySQLModeler.oolToSql(modelingSchema, doc, select, view.params))\n                    .join(\" AND \");\n        }\n\n        if (!_.isEmpty(view.groupBy)) {\n            sql +=\n                \" GROUP BY \" +\n                view.groupBy.map((col) => MySQLModeler._orderByToSql(modelingSchema, doc, col)).join(\", \");\n        }\n\n        if (!_.isEmpty(view.orderBy)) {\n            sql +=\n                \" ORDER BY \" +\n                view.orderBy.map((col) => MySQLModeler._orderByToSql(modelingSchema, doc, col)).join(\", \");\n        }\n\n        let skip = view.skip || 0;\n        if (view.limit) {\n            sql +=\n                \" LIMIT \" +\n                MySQLModeler.oolToSql(modelingSchema, doc, skip, view.params) +\n                \", \" +\n                MySQLModeler.oolToSql(modelingSchema, doc, view.limit, view.params);\n        } else if (view.skip) {\n            sql += \" OFFSET \" + MySQLModeler.oolToSql(modelingSchema, doc, view.skip, view.params);\n        }\n\n        return sql;\n    }\n\n    /*\n    _buildViewSelect(schema, doc, startIndex) {\n        let entity = schema.entities[doc.entity];\n        let alias = ntol(startIndex++);\n        doc.alias = alias;\n\n        let colList = Object.keys(entity.fields).map(k => alias + '.' + MySQLModeler.quoteIdentifier(k));\n        let joins = [];\n\n        if (!_.isEmpty(doc.subDocuments)) {\n            _.forOwn(doc.subDocuments, (doc, fieldName) => {\n                let [ subColList, subAlias, subJoins, startIndex2 ] = this._buildViewSelect(schema, doc, startIndex);\n                startIndex = startIndex2;\n                colList = colList.concat(subColList);\n                \n                joins.push('LEFT JOIN ' + MySQLModeler.quoteIdentifier(doc.entity) + ' AS ' + subAlias\n                    + ' ON ' + alias + '.' + MySQLModeler.quoteIdentifier(fieldName) + ' = ' +\n                    subAlias + '.' + MySQLModeler.quoteIdentifier(doc.linkWithField));\n\n                if (!_.isEmpty(subJoins)) {\n                    joins = joins.concat(subJoins);\n                }\n            });\n        }\n\n        return [ colList, alias, joins, startIndex ];\n    }*/\n\n    _createTableStatement(entityName, entity /*, mapOfEntityNameToCodeName*/) {\n        let sql = \"CREATE TABLE IF NOT EXISTS `\" + entityName + \"` (\\n\";\n\n        //column definitions\n        _.each(entity.fields, (field, name) => {\n            sql += \"  \" + MySQLModeler.quoteIdentifier(name) + \" \" + MySQLModeler.columnDefinition(field) + \",\\n\";\n        });\n\n        //primary key\n        sql += \"  PRIMARY KEY (\" + MySQLModeler.quoteListOrValue(entity.key) + \"),\\n\";\n\n        //other keys\n        if (entity.indexes && entity.indexes.length > 0) {\n            entity.indexes.forEach((index) => {\n                sql += \"  \";\n                if (index.unique) {\n                    sql += \"UNIQUE \";\n                }\n                sql += \"KEY (\" + MySQLModeler.quoteListOrValue(index.fields) + \"),\\n\";\n            });\n        }\n\n        let lines = [];\n        this._events.emit(\"beforeEndColumnDefinition:\" + entityName, lines);\n        if (lines.length > 0) {\n            sql += \"  \" + lines.join(\",\\n  \");\n        } else {\n            sql = sql.substr(0, sql.length - 2);\n        }\n\n        sql += \"\\n)\";\n\n        //table options\n        let extraProps = {};\n        this._events.emit(\"setTableOptions:\" + entityName, extraProps);\n        let props = Object.assign({}, this._dbOptions.table, extraProps);\n\n        sql = _.reduce(\n            props,\n            function (result, value, key) {\n                return result + \" \" + key + \"=\" + value;\n            },\n            sql\n        );\n\n        sql += \";\\n\";\n\n        return sql;\n    }\n\n    _addForeignKeyStatement(entityName, relation, schemaToConnector /*, mapOfEntityNameToCodeName*/) {\n        let refTable = relation.right;\n\n        if (refTable.indexOf(\".\") > 0) {\n            let [schemaName, refEntityName] = refTable.split(\".\");\n\n            let targetConnector = schemaToConnector[schemaName];\n            assert: targetConnector;\n\n            refTable = targetConnector.database + \"`.`\" + refEntityName;\n        }\n\n        let sql =\n            \"ALTER TABLE `\" +\n            entityName +\n            \"` ADD FOREIGN KEY (`\" +\n            relation.leftField +\n            \"`) \" +\n            \"REFERENCES `\" +\n            refTable +\n            \"` (`\" +\n            relation.rightField +\n            \"`) \";\n\n        sql += `ON UPDATE ${relation.constraints.onUpdate} ON DELETE ${relation.constraints.onDelete};\\n`;\n\n        return sql;\n    }\n\n    static foreignKeyFieldNaming(entityName, entity) {\n        let leftPart = naming.camelCase(entityName);\n        let rightPart = naming.pascalCase(entity.key);\n\n        if (_.endsWith(leftPart, rightPart)) {\n            return leftPart;\n        }\n\n        return leftPart + rightPart;\n    }\n\n    static quoteString(str) {\n        return \"'\" + str.replace(/'/g, \"\\\\'\") + \"'\";\n    }\n\n    static quoteIdentifier(str) {\n        return \"`\" + str + \"`\";\n    }\n\n    static quoteListOrValue(obj) {\n        return _.isArray(obj)\n            ? obj.map((v) => MySQLModeler.quoteIdentifier(v)).join(\", \")\n            : MySQLModeler.quoteIdentifier(obj);\n    }\n\n    static complianceCheck(entity) {\n        let result = { errors: [], warnings: [] };\n\n        if (!entity.key) {\n            result.errors.push(\"Primary key is not specified.\");\n        }\n\n        return result;\n    }\n\n    static columnDefinition(field, isProc) {\n        let col;\n\n        switch (field.type) {\n            case \"integer\":\n                col = MySQLModeler.intColumnDefinition(field);\n                break;\n\n            case \"number\":\n                col = MySQLModeler.floatColumnDefinition(field);\n                break;\n\n            case \"text\":\n                col = MySQLModeler.textColumnDefinition(field);\n                break;\n\n            case \"boolean\":\n                col = MySQLModeler.boolColumnDefinition(field);\n                break;\n\n            case \"binary\":\n                col = MySQLModeler.binaryColumnDefinition(field);\n                break;\n\n            case \"datetime\":\n                col = MySQLModeler.datetimeColumnDefinition(field);\n                break;\n\n            case \"object\":\n                col = MySQLModeler.textColumnDefinition(field);\n                break;\n\n            case \"enum\":\n                col = MySQLModeler.enumColumnDefinition(field);\n                break;\n\n            case \"array\":\n                col = MySQLModeler.textColumnDefinition(field);\n                break;\n\n            default:\n                throw new Error('Unsupported type \"' + field.type + '\".');\n        }\n\n        let { sql, type } = col;\n\n        if (!isProc) {\n            sql += this.columnNullable(field);\n            sql += this.defaultValue(field, type);\n        }\n\n        return sql;\n    }\n\n    static intColumnDefinition(info) {\n        let sql, type;\n\n        if (info.digits) {\n            if (info.digits > 10) {\n                type = sql = \"BIGINT\";\n            } else if (info.digits > 7) {\n                type = sql = \"INT\";\n            } else if (info.digits > 4) {\n                type = sql = \"MEDIUMINT\";\n            } else if (info.digits > 2) {\n                type = sql = \"SMALLINT\";\n            } else {\n                type = sql = \"TINYINT\";\n            }\n\n            sql += `(${info.digits})`;\n        } else {\n            type = sql = \"INT\";\n        }\n\n        if (info.unsigned) {\n            sql += \" UNSIGNED\";\n        }\n\n        return { sql, type };\n    }\n\n    static floatColumnDefinition(info) {\n        let sql = \"\",\n            type;\n\n        if (info.type == \"number\" && info.exact) {\n            type = sql = \"DECIMAL\";\n\n            if (info.totalDigits > 65) {\n                throw new Error(\"Total digits exceed maximum limit.\");\n            }\n        } else {\n            if (info.bytes === 8 || info.double || info.totalDigits > 23) {\n                type = sql = \"DOUBLE\";\n\n                if (info.totalDigits > 53) {\n                    throw new Error(\"Total digits exceed maximum limit.\");\n                }\n            } else {\n                type = sql = \"FLOAT\";\n            }\n        }\n\n        if (\"totalDigits\" in info) {\n            sql += \"(\" + info.totalDigits;\n            if (\"decimalDigits\" in info) {\n                sql += \", \" + info.decimalDigits;\n            }\n            sql += \")\";\n        } else {\n            if (\"decimalDigits\" in info) {\n                if (info.decimalDigits > 23) {\n                    sql += \"(53, \" + info.decimalDigits + \")\";\n                } else {\n                    sql += \"(23, \" + info.decimalDigits + \")\";\n                }\n            }\n        }\n\n        return { sql, type };\n    }\n\n    static textColumnDefinition(info) {\n        let sql = \"\",\n            type;\n\n        if (info.fixedLength && info.fixedLength <= 255) {\n            sql = \"CHAR(\" + info.fixedLength + \")\";\n            type = \"CHAR\";\n        } else if (info.maxLength) {\n            if (info.maxLength > 16777215) {\n                type = sql = \"LONGTEXT\";\n            } else if (info.maxLength > 65535) {\n                type = sql = \"MEDIUMTEXT\";\n            } else if (info.maxLength > 2000) {\n                type = sql = \"TEXT\";\n            } else {\n                type = sql = \"VARCHAR\";\n                if (info.fixedLength) {\n                    sql += \"(\" + info.fixedLength + \")\";\n                } else {\n                    sql += \"(\" + info.maxLength + \")\";\n                }\n            }\n        } else {\n            type = sql = \"TEXT\";\n        }\n\n        return { sql, type };\n    }\n\n    static binaryColumnDefinition(info) {\n        let sql = \"\",\n            type;\n\n        if (info.fixedLength <= 255) {\n            sql = \"BINARY(\" + info.fixedLength + \")\";\n            type = \"BINARY\";\n        } else if (info.maxLength) {\n            if (info.maxLength > 16777215) {\n                type = sql = \"LONGBLOB\";\n            } else if (info.maxLength > 65535) {\n                type = sql = \"MEDIUMBLOB\";\n            } else {\n                type = sql = \"VARBINARY\";\n                if (info.fixedLength) {\n                    sql += \"(\" + info.fixedLength + \")\";\n                } else {\n                    sql += \"(\" + info.maxLength + \")\";\n                }\n            }\n        } else {\n            type = sql = \"BLOB\";\n        }\n\n        return { sql, type };\n    }\n\n    static boolColumnDefinition() {\n        return { sql: \"TINYINT(1)\", type: \"TINYINT\" };\n    }\n\n    static datetimeColumnDefinition(info) {\n        let sql;\n\n        if (!info.range || info.range === \"datetime\") {\n            sql = \"DATETIME\";\n        } else if (info.range === \"date\") {\n            sql = \"DATE\";\n        } else if (info.range === \"time\") {\n            sql = \"TIME\";\n        } else if (info.range === \"year\") {\n            sql = \"YEAR\";\n        } else if (info.range === \"timestamp\") {\n            sql = \"TIMESTAMP\";\n        }\n\n        return { sql, type: sql };\n    }\n\n    static enumColumnDefinition(info) {\n        return { sql: \"ENUM(\" + _.map(info.values, (v) => MySQLModeler.quoteString(v)).join(\", \") + \")\", type: \"ENUM\" };\n    }\n\n    static columnNullable(info) {\n        if (info.hasOwnProperty(\"optional\") && info.optional) {\n            return \" NULL\";\n        }\n\n        return \" NOT NULL\";\n    }\n\n    static defaultValue(info, type) {\n        if (info.isCreateTimestamp) {\n            info.createByDb = true;\n            return \" DEFAULT CURRENT_TIMESTAMP\";\n        }\n\n        if (info.autoIncrementId) {\n            info.createByDb = true;\n            return \" AUTO_INCREMENT\";\n        }\n\n        if (info.isUpdateTimestamp) {\n            info.updateByDb = true;\n            return \" ON UPDATE CURRENT_TIMESTAMP\";\n        }\n\n        let sql = \"\";\n\n        if (!info.optional) {\n            if (info.hasOwnProperty(\"default\")) {\n                let defaultValue = info[\"default\"];\n\n                if (typeof defaultValue === \"object\" && defaultValue.oorType === \"SymbolToken\") {\n                    const tokenName = defaultValue.name.toUpperCase();\n\n                    switch (tokenName) {\n                        case \"NOW\":\n                            sql += \" DEFAULT NOW()\";\n                            info.createByDb = true;\n                            break;\n\n                        default:\n                            throw new Error(`Unsupported symbol token \"${tokenName}\".`);\n                    }\n                } else {\n                    switch (info.type) {\n                        case \"boolean\":\n                            sql += \" DEFAULT \" + (Types.BOOLEAN.sanitize(defaultValue) ? \"1\" : \"0\");\n                            break;\n\n                        case \"integer\":\n                            if (_.isInteger(defaultValue)) {\n                                sql += \" DEFAULT \" + defaultValue.toString();\n                            } else {\n                                sql += \" DEFAULT \" + parseInt(defaultValue).toString();\n                            }\n                            break;\n\n                        case \"text\":\n                        case \"enum\":\n                            sql += \" DEFAULT \" + quote(defaultValue);\n                            break;\n\n                        case \"number\":\n                            if (_.isNumber(defaultValue)) {\n                                sql += \" DEFAULT \" + defaultValue.toString();\n                            } else {\n                                sql += \" DEFAULT \" + parseFloat(defaultValue).toString();\n                            }\n                            break;\n\n                        case \"binary\":\n                            sql += \" DEFAULT \" + bin2Hex(defaultValue);\n                            break;\n\n                        case \"datetime\":\n                            sql +=\n                                \" DEFAULT \" +\n                                quote(Types.DATETIME.sanitize(defaultValue).toSQL({ includeOffset: false }));\n                            break;\n\n                        case \"object\":\n                        case \"array\":\n                            sql += \" DEFAULT \" + quote(JSON.stringify(defaultValue));\n                            break;\n\n                        default:\n                            throw new Error(`Invalid type \"${info.type}\"`);\n                    }\n                }\n            } else if (!info.hasOwnProperty(\"auto\")) {\n                if (UNSUPPORTED_DEFAULT_VALUE.has(type)) {\n                    return \"\";\n                }\n\n                if (info.type === \"boolean\" || info.type === \"integer\" || info.type === \"number\") {\n                    sql += \" DEFAULT 0\";\n                } else if (info.type === \"datetime\") {\n                    sql += \" DEFAULT CURRENT_TIMESTAMP\";\n                } else if (info.type === \"enum\") {\n                    sql += \" DEFAULT \" + quote(info.values[0]);\n                    info.createByDb = true;\n                } else {\n                    sql += ' DEFAULT \"\"';\n                }\n\n                //not explicit specified, will not treated as createByDb\n                //info.createByDb = true;\n            }\n        }     \n\n        return sql;\n    }\n\n    static removeTableNamePrefix(entityName, removeTablePrefix) {\n        if (removeTablePrefix) {\n            entityName = _.trim(_.snakeCase(entityName));\n\n            removeTablePrefix = _.trimEnd(_.snakeCase(removeTablePrefix), \"_\") + \"_\";\n\n            if (_.startsWith(entityName, removeTablePrefix)) {\n                entityName = entityName.substr(removeTablePrefix.length);\n            }\n        }\n\n        return GemlUtils.entityNaming(entityName);\n    }\n}\n\nmodule.exports = MySQLModeler;\n"],"names":["EventEmitter","require","path","_","quote","pushIntoBucket","get","naming","bin2Hex","fs","GemlUtils","pluralize","isDotSeparateName","extractDotSeparateName","Entity","Types","UNSUPPORTED_DEFAULT_VALUE","Set","MySQLModeler","modeling","schema","schemaToConnector","skipGeneration","linker","log","name","modelingSchema","clone","pendingEntities","Object","keys","entities","length","entityName","shift","entity","isEmpty","info","associations","assocs","_preProcessAssociations","assocNames","reduce","result","v","forEach","assoc","_processAssociation","_events","emit","sqlFilesDir","join","dbFilePath","fkFilePath","tableSQL","relationSQL","data","each","assert","addIndexes","complianceCheck","errors","message","warnings","Error","features","forOwn","f","featureName","Array","isArray","ff","_featureReducer","_createTableStatement","dataSet","runtimeEnv","records","entityData","record","isPlainObject","fields","keyField","auto","defaultByDb","translateOolValue","gemlModule","push","key","assign","nodes","_references","refs","srcEntityName","ref","_addForeignKeyStatement","_writeFile","outputPath","initIdxFiles","envData","entitiesData","initFileName","pathNodes","initFilePath","idxFilePath","JSON","stringify","list","filePath","manual","existsSync","lines","readFileSync","split","line","startsWith","concat","funcSQL","spFilePath","_toColumnReference","oorType","_translateJoinCondition","context","localField","anchor","remoteField","map","rf","ret","by","withExtra","_oolConditionToQueryCondition","with","$and","_getAllRelatedFields","undefined","srcField","type","destEntity","entityKeyField","getKeyField","destEntityName","destEntityNameAsFieldName","destSchemaName","actualDestEntityName","destSchema","schemas","linked","ensureGetEntity","destKeyField","includes","excludes","types","association","cb","remoteFields","isNil","indexOf","backRef","getReferenceTo","connectedByParts","connectedByField","connEntityName","entityNaming","tag1","tag2","_processedRef","has","connectedByParts2","connectedByField2","connEntity","_addRelationEntity","_updateRelationEntity","localFieldName","addAssociation","on","field","remoteFieldName","add","hasFeature","deletionCheck","oolType","operator","left","right","prefixNaming","connBackRef1","connBackRef2","src","dest","destFieldName","referencedField","tag","destField","hasField","joinOn","addAssocField","fieldProps","localFieldObj","constraints","constraintOnUpdate","onUpdate","constraintOnDelete","onDelete","optional","_addReference","oolCon","_translateReference","$eq","$ne","arg","argument","$or","asKey","base","other","translated","console","refName","leftField","rightField","lf","refs4LeftEntity","found","find","item","_getReferenceOfField","reference","_hasReferenceOfField","_getReferenceBetween","_hasReferenceBetween","feature","generator","autoIncrementId","once","extraOpts","startFrom","isCreateTimestamp","isUpdateTimestamp","changeLogSettings","deploymentSettings","dataSource","content","ensureFileSync","writeFileSync","relationEntityName","entity1Name","entity2Name","entity1RefField","entity2RefField","entityInfo","indexes","unique","link","addEntity","relationEntity","entity1","entity2","_relationEntities","hasRefToEntity1","hasRefToEntity2","keyEntity1","keyEntity2","allCascade","oolOpToSql","op","oolToSql","doc","ool","params","isMemberAccess","p","upperFirst","entityNode","parseReferenceInDocument","alias","quoteIdentifier","_orderByToSql","ascend","_viewDocumentToSQL","view","sql","cloneDeep","getDocumentHierarchy","colList","joins","_buildViewSelect","selectBy","select","groupBy","col","orderBy","skip","limit","columnDefinition","quoteListOrValue","index","substr","extraProps","props","_dbOptions","table","value","relation","refTable","schemaName","refEntityName","targetConnector","database","foreignKeyFieldNaming","leftPart","camelCase","rightPart","pascalCase","endsWith","quoteString","str","replace","obj","isProc","intColumnDefinition","floatColumnDefinition","textColumnDefinition","boolColumnDefinition","binaryColumnDefinition","datetimeColumnDefinition","enumColumnDefinition","columnNullable","defaultValue","digits","unsigned","exact","totalDigits","bytes","double","decimalDigits","fixedLength","maxLength","range","values","hasOwnProperty","createByDb","updateByDb","tokenName","toUpperCase","BOOLEAN","sanitize","isInteger","toString","parseInt","isNumber","parseFloat","DATETIME","toSQL","includeOffset","removeTableNamePrefix","removeTablePrefix","trim","snakeCase","trimEnd","constructor","connector","dbOptions","scriptPath","db","mapKeys","upperCase","module","exports"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"AAAA;AAEA,MAAMA,eAAeC,QAAQ;AAC7B,MAAMC,OAAOD,QAAQ;AAErB,MAAM,EAAEE,CAAC,EAAEC,KAAK,EAAEC,cAAc,EAAEC,GAAG,EAAEC,MAAM,EAAEC,OAAO,EAAE,GAAGP,QAAQ;AACnE,MAAM,EAAEQ,EAAE,EAAE,GAAGR,QAAQ;AAEvB,MAAMS,YAAYT,QAAQ;AAC1B,MAAM,EAAEU,SAAS,EAAEC,iBAAiB,EAAEC,sBAAsB,EAAE,GAAGH;AACjE,MAAMI,SAASb,QAAQ;AACvB,MAAM,EAAEc,KAAK,EAAE,GAAGd,QAAQ;AAE1B,MAAMe,4BAA4B,IAAIC,IAAI;IAAC;IAAQ;IAAQ;IAAQ;CAAW;AAE9E;;;CAGC,GACD,MAAMC;IA4BFC,SAASC,MAAM,EAAEC,iBAAiB,EAAEC,cAAc,EAAE;QAChD,IAAI,CAACA,gBAAgB;YACjB,IAAI,CAACC,MAAM,CAACC,GAAG,CAAC,QAAQ,0CAA0CJ,OAAOK,IAAI,GAAG;QACpF;QAEA,IAAIC,iBAAiBN,OAAOO,KAAK;QAEjC,IAAI,CAACJ,MAAM,CAACC,GAAG,CAAC,SAAS;QAEzB,IAAII,kBAAkBC,OAAOC,IAAI,CAACJ,eAAeK,QAAQ;QAEzD,MAAOH,gBAAgBI,MAAM,GAAG,EAAG;YAC/B,IAAIC,aAAaL,gBAAgBM,KAAK;YACtC,IAAIC,SAAST,eAAeK,QAAQ,CAACE,WAAW;YAEhD,IAAI,CAAC9B,EAAEiC,OAAO,CAACD,OAAOE,IAAI,CAACC,YAAY,GAAG;gBACtC,IAAI,CAACf,MAAM,CAACC,GAAG,CAAC,SAAS,CAAC,mCAAmC,EAAES,WAAW,IAAI,CAAC;gBAE/E,IAAIM,SAAS,IAAI,CAACC,uBAAuB,CAACL;gBAE1C,IAAIM,aAAaF,OAAOG,MAAM,CAAC,CAACC,QAAQC;oBACpCD,MAAM,CAACC,EAAE,GAAGA;oBACZ,OAAOD;gBACX,GAAG,CAAC;gBAEJR,OAAOE,IAAI,CAACC,YAAY,CAACO,OAAO,CAAC,CAACC,QAC9B,IAAI,CAACC,mBAAmB,CAACrB,gBAAgBS,QAAQW,OAAOL,YAAYb;YAE5E;QACJ;QAEA,IAAI,CAACoB,OAAO,CAACC,IAAI,CAAC;QAElB,oBAAoB;QACpB,2CAA2C;QAC3C,oEAAoE;QACpE,IAAIC,cAAchD,KAAKiD,IAAI,CAAC,SAAS/B,OAAOK,IAAI;QAChD,IAAI2B,aAAalD,KAAKiD,IAAI,CAACD,aAAa;QACxC,IAAIG,aAAanD,KAAKiD,IAAI,CAACD,aAAa;QAExC,IAAII,WAAW,IACXC,cAAc,IACdC,OAAO,CAAC;QAEZ,qCAAqC;QAErCrD,EAAEsD,IAAI,CAAC/B,eAAeK,QAAQ,EAAE,CAACI,QAAQF;YACrCyB,QAAQzB,eAAeE,OAAOV,IAAI;YAClC,sDAAsD;YAEtDU,OAAOwB,UAAU;YAEjB,IAAIhB,SAASzB,aAAa0C,eAAe,CAACzB;YAC1C,IAAIQ,OAAOkB,MAAM,CAAC7B,MAAM,EAAE;gBACtB,IAAI8B,UAAU;gBACd,IAAInB,OAAOoB,QAAQ,CAAC/B,MAAM,GAAG,GAAG;oBAC5B8B,WAAW,iBAAiBnB,OAAOoB,QAAQ,CAACZ,IAAI,CAAC,QAAQ;gBAC7D;gBACAW,WAAWnB,OAAOkB,MAAM,CAACV,IAAI,CAAC;gBAE9B,MAAM,IAAIa,MAAMF;YACpB;YAEA,IAAI3B,OAAO8B,QAAQ,EAAE;gBACjB9D,EAAE+D,MAAM,CAAC/B,OAAO8B,QAAQ,EAAE,CAACE,GAAGC;oBAC1B,IAAIC,MAAMC,OAAO,CAACH,IAAI;wBAClBA,EAAEtB,OAAO,CAAC,CAAC0B,KAAO,IAAI,CAACC,eAAe,CAAC9C,gBAAgBS,QAAQiC,aAAaG;oBAChF,OAAO;wBACH,IAAI,CAACC,eAAe,CAAC9C,gBAAgBS,QAAQiC,aAAaD;oBAC9D;gBACJ;YACJ;YAEA,IAAI,CAAC7C,gBAAgB;gBACjBgC,YAAY,IAAI,CAACmB,qBAAqB,CAACxC,YAAYE,OAAO,6BAA6B,OAAM;gBAE7F,IAAIA,OAAOE,IAAI,CAACmB,IAAI,EAAE;oBAClBrB,OAAOE,IAAI,CAACmB,IAAI,CAACX,OAAO,CAAC,CAAC,EAAE6B,OAAO,EAAEC,UAAU,EAAEC,OAAO,EAAE;wBACtD,2DAA2D;wBAE3D,IAAIC,aAAa,EAAE;wBAEnB,IAAIR,MAAMC,OAAO,CAACM,UAAU;4BACxBA,QAAQ/B,OAAO,CAAC,CAACiC;gCACb,IAAI,CAAC3E,EAAE4E,aAAa,CAACD,SAAS;oCAC1B,IAAIE,SAASnD,OAAOC,IAAI,CAACK,OAAO6C,MAAM;oCACtC,IAAIA,OAAOhD,MAAM,KAAK,GAAG;wCACrB,MAAM,IAAIgC,MACN,CAAC,6BAA6B,EAAE7B,OAAOV,IAAI,CAAC,yBAAyB,CAAC;oCAE9E;oCAEA,IAAIwD,WAAW9C,OAAO6C,MAAM,CAACA,MAAM,CAAC,EAAE,CAAC;oCAEvC,IAAI,CAACC,SAASC,IAAI,IAAI,CAACD,SAASE,WAAW,EAAE;wCACzC,MAAM,IAAInB,MACN,CAAC,eAAe,EAAE7B,OAAOV,IAAI,CAAC,+CAA+C,CAAC;oCAEtF;oCAEAqD,SAAS;wCAAE,CAACE,MAAM,CAAC,EAAE,CAAC,EAAE,IAAI,CAACzD,MAAM,CAAC6D,iBAAiB,CAACjD,OAAOkD,UAAU,EAAEP;oCAAQ;gCACrF,OAAO;oCACHA,SAAS,IAAI,CAACvD,MAAM,CAAC6D,iBAAiB,CAACjD,OAAOkD,UAAU,EAAEP;gCAC9D;gCAEAD,WAAWS,IAAI,CAACR;4BACpB;wBACJ,OAAO;4BACH3E,EAAE+D,MAAM,CAACU,SAAS,CAACE,QAAQS;gCACvB,IAAI,CAACpF,EAAE4E,aAAa,CAACD,SAAS;oCAC1B,IAAIE,SAASnD,OAAOC,IAAI,CAACK,OAAO6C,MAAM;oCACtC,IAAIA,OAAOhD,MAAM,KAAK,GAAG;wCACrB,MAAM,IAAIgC,MACN,CAAC,6BAA6B,EAAE7B,OAAOV,IAAI,CAAC,yBAAyB,CAAC;oCAE9E;oCAEAqD,SAAS;wCACL,CAAC3C,OAAOoD,GAAG,CAAC,EAAEA;wCACd,CAACP,MAAM,CAAC,EAAE,CAAC,EAAE,IAAI,CAACzD,MAAM,CAAC6D,iBAAiB,CAACjD,OAAOkD,UAAU,EAAEP;oCAClE;gCACJ,OAAO;oCACHA,SAASjD,OAAO2D,MAAM,CAClB;wCAAE,CAACrD,OAAOoD,GAAG,CAAC,EAAEA;oCAAI,GACpB,IAAI,CAAChE,MAAM,CAAC6D,iBAAiB,CAACjD,OAAOkD,UAAU,EAAEP;gCAEzD;gCAEAD,WAAWS,IAAI,CAACR;4BAChB,uIAAuI;4BAC3I;wBACJ;wBAEA,IAAI,CAAC3E,EAAEiC,OAAO,CAACyC,aAAa;4BACxBH,WAAYA,CAAAA,UAAU,OAAM;4BAC5BC,cAAeA,CAAAA,aAAa,SAAQ;4BAEpC,IAAIc,QAAQ;gCAACf;gCAASC;6BAAW;4BAEjCc,MAAMH,IAAI,CAACrD;4BAEX,IAAIsD,MAAME,MAAMtC,IAAI,CAAC;4BAErB9C,eAAemD,MAAM+B,KAAKV,YAAY;wBAC1C;oBACJ;gBAEA,kBAAkB;gBACtB;YACJ;QACJ;QAEA,IAAI,CAACvD,gBAAgB;YACjBnB,EAAE+D,MAAM,CAAC,IAAI,CAACwB,WAAW,EAAE,CAACC,MAAMC;gBAC9BzF,EAAEsD,IAAI,CAACkC,MAAM,CAACE;oBACVtC,eACI,IAAI,CAACuC,uBAAuB,CACxBF,eACAC,KACAxE,kBAAkB,6BAA6B,OAC/C;gBACZ;YACJ;YAEA,IAAI,CAAC0E,UAAU,CAAC7F,KAAKiD,IAAI,CAAC,IAAI,CAAC6C,UAAU,EAAE5C,aAAaE;YACxD,IAAI,CAACyC,UAAU,CAAC7F,KAAKiD,IAAI,CAAC,IAAI,CAAC6C,UAAU,EAAE3C,aAAaE;YAExD,IAAI0C,eAAe,CAAC;YAEpB,IAAI,CAAC9F,EAAEiC,OAAO,CAACoB,OAAO;gBAClBrD,EAAE+D,MAAM,CAACV,MAAM,CAAC0C,SAASxB;oBACrBvE,EAAE+D,MAAM,CAACgC,SAAS,CAACC,cAAcxB;wBAC7BxE,EAAE+D,MAAM,CAACiC,cAAc,CAACvB,SAAS3C;4BAC7B,IAAImE,eAAe,CAAC,EAAE,EAAEnE,WAAW,KAAK,CAAC;4BAEzC,IAAIoE,YAAY;gCAACnD;gCAAa;gCAAQwB,WAAW;6BAAQ;4BAEzD,IAAIC,eAAe,WAAW;gCAC1B0B,UAAUf,IAAI,CAACX;4BACnB;4BAEA,IAAI2B,eAAepG,KAAKiD,IAAI,IAAIkD,WAAWD;4BAC3C,IAAIG,cAAcrG,KAAKiD,IAAI,IAAIkD,WAAW;4BAE1ChG,eAAe4F,cAAc;gCAACM;6BAAY,EAAEH;4BAE5C,IAAI,CAACL,UAAU,CACX7F,KAAKiD,IAAI,CAAC,IAAI,CAAC6C,UAAU,EAAEM,eAC3BE,KAAKC,SAAS,CAAC;gCAAE,CAACxE,WAAW,EAAE2C;4BAAQ,GAAG,MAAM;wBAExD;oBACJ;gBACJ;YACJ;YAEA,yCAAyC;YAEzCzE,EAAE+D,MAAM,CAAC+B,cAAc,CAACS,MAAMC;gBAC1B,IAAIJ,cAAcrG,KAAKiD,IAAI,CAAC,IAAI,CAAC6C,UAAU,EAAEW;gBAE7C,IAAIC,SAAS,EAAE;gBAEf,IAAInG,GAAGoG,UAAU,CAACN,cAAc;oBAC5B,IAAIO,QAAQrG,GAAGsG,YAAY,CAACR,aAAa,QAAQS,KAAK,CAAC;oBACvDF,MAAMjE,OAAO,CAAC,CAACoE;wBACX,IAAI,CAACA,KAAKC,UAAU,CAAC,OAAO;4BACxBN,OAAOtB,IAAI,CAAC2B;wBAChB;oBACJ;gBACJ;gBAEA,IAAI,CAAClB,UAAU,CAACQ,aAAaG,KAAKS,MAAM,CAACP,QAAQzD,IAAI,CAAC;YAC1D;YAEA,IAAIiE,UAAU;YAEd,cAAc;YACd;;;;;;;;;;;;;;;;;;;;;YAqBA,GAEA,IAAIC,aAAanH,KAAKiD,IAAI,CAACD,aAAa;YACxC,IAAI,CAAC6C,UAAU,CAAC7F,KAAKiD,IAAI,CAAC,IAAI,CAAC6C,UAAU,EAAEqB,aAAaD;QAC5D;QAEA,OAAO1F;IACX;IAEA4F,mBAAmB7F,IAAI,EAAE;QACrB,OAAO;YAAE8F,SAAS;YAAmB9F;QAAK;IAC9C;IAEA+F,wBAAwBC,OAAO,EAAEC,UAAU,EAAEC,MAAM,EAAEC,WAAW,EAAE;QAC9D,IAAIvD,MAAMC,OAAO,CAACsD,cAAc;YAC5B,OAAOA,YAAYC,GAAG,CAAC,CAACC,KAAO,IAAI,CAACN,uBAAuB,CAACC,SAASC,YAAYC,QAAQG;QAC7F;QAEA,IAAI3H,EAAE4E,aAAa,CAAC6C,cAAc;YAC9B,IAAIG,MAAM;gBAAE,CAACL,WAAW,EAAE,IAAI,CAACJ,kBAAkB,CAACK,SAAS,MAAMC,YAAYI,EAAE;YAAE;YACjF,IAAIC,YAAY,IAAI,CAACC,6BAA6B,CAACT,SAASG,YAAYO,IAAI;YAE5E,IAAIT,cAAcO,WAAW;gBACzB,OAAO;oBAAEG,MAAM;wBAACL;wBAAKE;qBAAU;gBAAC;YACpC;YAEA,OAAO;gBAAE,GAAGF,GAAG;gBAAE,GAAGE,SAAS;YAAC;QAClC;QAEA,OAAO;YAAE,CAACP,WAAW,EAAE,IAAI,CAACJ,kBAAkB,CAACK,SAAS,MAAMC;QAAa;IAC/E;IAEAS,qBAAqBT,WAAW,EAAE;QAC9B,IAAI,CAACA,aAAa,OAAOU;QAEzB,IAAIjE,MAAMC,OAAO,CAACsD,cAAc;YAC5B,OAAOA,YAAYC,GAAG,CAAC,CAACC,KAAO,IAAI,CAACO,oBAAoB,CAACP;QAC7D;QAEA,IAAI3H,EAAE4E,aAAa,CAAC6C,cAAc;YAC9B,OAAOA,YAAYI,EAAE;QACzB;QAEA,OAAOJ;IACX;IAEApF,wBAAwBL,MAAM,EAAE;QAC5B,OAAOA,OAAOE,IAAI,CAACC,YAAY,CAACuF,GAAG,CAAC,CAAC/E;YACjC,IAAIA,MAAMyF,QAAQ,EAAE,OAAOzF,MAAMyF,QAAQ;YAEzC,IAAIzF,MAAM0F,IAAI,KAAK,WAAW;gBAC1B,OAAO7H,UAAUmC,MAAM2F,UAAU;YACrC;YAEA,OAAO3F,MAAM2F,UAAU;QAC3B;IACJ;IAEA;;;;;;;;;;;;;;;KAeC,GACD1F,oBAAoB3B,MAAM,EAAEe,MAAM,EAAEW,KAAK,EAAEL,UAAU,EAAEb,eAAe,EAAE;QACpE,IAAI8G,iBAAiBvG,OAAOwG,WAAW;QACvCjF,QAAQ,CAACW,MAAMC,OAAO,CAACoE;QAEvB,IAAI,CAACnH,MAAM,CAACC,GAAG,CAAC,SAAS,CAAC,YAAY,EAAEW,OAAOV,IAAI,CAAC,EAAE,EAAE+E,KAAKC,SAAS,CAAC3D,OAAO,CAAC;QAE/E,IAAI8F,iBAAiB9F,MAAM2F,UAAU,EACjCA,YACAI;QAEJ,IAAIjI,kBAAkBgI,iBAAiB;YACnC,oBAAoB;YACpB,IAAI,CAACE,gBAAgBC,qBAAqB,GAAGlI,uBAAuB+H;YAEpE,IAAII,aAAa5H,OAAOG,MAAM,CAAC0H,OAAO,CAACH,eAAe;YACtD,IAAI,CAACE,WAAWE,MAAM,EAAE;gBACpB,MAAM,IAAIlF,MACN,CAAC,uBAAuB,EAAE8E,eAAe,yFAAyF,CAAC;YAE3I;YAEAL,aAAaO,WAAWjH,QAAQ,CAACgH,qBAAqB;YACtDF,4BAA4BE;QAChC,OAAO;YACHN,aAAarH,OAAO+H,eAAe,CAAChH,OAAOkD,UAAU,EAAEuD,gBAAgBhH;YACvE,IAAI,CAAC6G,YAAY;gBACb,MAAM,IAAIzE,MAAM,CAAC,QAAQ,EAAE7B,OAAOV,IAAI,CAAC,sCAAsC,EAAEmH,eAAe,EAAE,CAAC;YACrG;YAEAC,4BAA4BD;QAChC;QAEA,IAAI,CAACH,YAAY;YACb,MAAM,IAAIzE,MAAM,CAAC,QAAQ,EAAE7B,OAAOV,IAAI,CAAC,sCAAsC,EAAEmH,eAAe,EAAE,CAAC;QACrG;QAEA,IAAIQ,eAAeX,WAAWE,WAAW;QACzCjF,QAAQ0F,cACJ,CAAC,iBAAiB,EAAEX,WAAWxD,QAAQ,CAAC,gBAAgB,EAAE2D,eAAe,kBAAkB,EAAEzG,OAAOV,IAAI,CAAC,CAAC;QAE9G,IAAI4C,MAAMC,OAAO,CAAC8E,eAAe;YAC7B,MAAM,IAAIpF,MAAM,CAAC,oBAAoB,EAAE4E,eAAe,gDAAgD,CAAC;QAC3G;QAEA,OAAQ9F,MAAM0F,IAAI;YACd,KAAK;YACL,KAAK;gBACD,IAAIa;gBACJ,IAAIC,WAAW;oBACXC,OAAO;wBAAC;qBAAW;oBACnBC,aAAa1G;gBACjB;gBAEA,IAAIA,MAAMkF,EAAE,EAAE;oBACVsB,SAASC,KAAK,CAACjE,IAAI,CAAC;oBACpB+D,WAAW;wBACPrB,IAAI,CAACyB,KAAOA,MAAMA,GAAGzC,KAAK,CAAC,IAAI,CAAC,EAAE,KAAKlE,MAAMkF,EAAE,CAAChB,KAAK,CAAC,IAAI,CAAC,EAAE;oBACjE;oBAEA,IAAIlE,MAAMqF,IAAI,EAAE;wBACZkB,SAASlB,IAAI,GAAGrF,MAAMqF,IAAI;oBAC9B;gBACJ,OAAO;oBACH,IAAIuB,eAAe,IAAI,CAACrB,oBAAoB,CAACvF,MAAM8E,WAAW;oBAE9DyB,WAAW;wBACPd,UAAU,CAACX;4BACPA,eAAgBA,CAAAA,cAAczF,OAAOV,IAAI,AAAD;4BAExC,OACItB,EAAEwJ,KAAK,CAACD,iBACPrF,CAAAA,MAAMC,OAAO,CAACoF,gBACTA,aAAaE,OAAO,CAAChC,eAAe,CAAC,IACrC8B,iBAAiB9B,WAAU;wBAEzC;oBACJ;gBACJ;gBAEA,IAAIiC,UAAUpB,WAAWqB,cAAc,CAAC3H,OAAOV,IAAI,EAAE4H,UAAUC;gBAC/D,IAAIO,SAAS;oBACT,IAAIA,QAAQrB,IAAI,KAAK,aAAaqB,QAAQrB,IAAI,KAAK,UAAU;wBACzD,IAAI,CAAC1F,MAAMkF,EAAE,EAAE;4BACX,MAAM,IAAIhE,MACN,uDACI7B,OAAOV,IAAI,GACX,mBACAmH;wBAEZ;wBAEA,gCAAgC;wBAEhC,IAAImB,mBAAmBjH,MAAMkF,EAAE,CAAChB,KAAK,CAAC;wBACtCtD,QAAQqG,iBAAiB/H,MAAM,IAAI;wBAEnC,iDAAiD;wBACjD,IAAIgI,mBAAmB,AAACD,iBAAiB/H,MAAM,GAAG,KAAK+H,gBAAgB,CAAC,EAAE,IAAK5H,OAAOV,IAAI;wBAC1F,IAAIwI,iBAAiBvJ,UAAUwJ,YAAY,CAACH,gBAAgB,CAAC,EAAE;wBAE/DrG,QAAQuG;wBAER,IAAIE,OAAO,CAAC,EAAEhI,OAAOV,IAAI,CAAC,CAAC,EAAEqB,MAAM0F,IAAI,KAAK,YAAY,MAAM,IAAI,CAAC,EAAEI,eAAe,CAAC,EACjFiB,QAAQrB,IAAI,KAAK,YAAY,MAAM,IACtC,IAAI,EAAEyB,eAAe,CAAC;wBACvB,IAAIG,OAAO,CAAC,EAAExB,eAAe,CAAC,EAAEiB,QAAQrB,IAAI,KAAK,YAAY,MAAM,IAAI,CAAC,EAAErG,OAAOV,IAAI,CAAC,CAAC,EACnFqB,MAAM0F,IAAI,KAAK,YAAY,MAAM,IACpC,IAAI,EAAEyB,eAAe,CAAC;wBAEvB,IAAInH,MAAMyF,QAAQ,EAAE;4BAChB4B,QAAQ,MAAMrH,MAAMyF,QAAQ;wBAChC;wBAEA,IAAIsB,QAAQtB,QAAQ,EAAE;4BAClB6B,QAAQ,MAAMP,QAAQtB,QAAQ;wBAClC;wBAEA,IAAI,IAAI,CAAC8B,aAAa,CAACC,GAAG,CAACH,SAAS,IAAI,CAACE,aAAa,CAACC,GAAG,CAACF,OAAO;4BAC9D,yBAAyB;4BACzB;wBACJ;wBAEA,IAAIG,oBAAoBV,QAAQ7B,EAAE,CAAChB,KAAK,CAAC;wBACzC,IAAIwD,oBACA,AAACD,kBAAkBvI,MAAM,GAAG,KAAKuI,iBAAiB,CAAC,EAAE,IAAK1B;wBAE9D,IAAImB,qBAAqBQ,mBAAmB;4BACxC,MAAM,IAAIxG,MAAM;wBACpB;wBAEA,IAAIyG,aAAarJ,OAAO+H,eAAe,CAAChH,OAAOkD,UAAU,EAAE4E,gBAAgBrI;wBAC3E,IAAI,CAAC6I,YAAY;4BACb,UAAU;4BACVA,aAAa,IAAI,CAACC,kBAAkB,CAChCtJ,QACA6I,gBACA9H,OAAOV,IAAI,EACXmH,gBACAoB,kBACAQ;4BAEJ5I,gBAAgB0D,IAAI,CAACmF,WAAWhJ,IAAI;4BACpC,IAAI,CAACF,MAAM,CAACC,GAAG,CAAC,SAAS,CAAC,YAAY,EAAEiJ,WAAWhJ,IAAI,CAAC,uBAAuB,CAAC;wBACpF;wBAEA,IAAI,CAACkJ,qBAAqB,CACtBF,YACAtI,QACAsG,YACAtG,OAAOV,IAAI,EACXmH,gBACAoB,kBACAQ;wBAGJ,IAAII,iBAAiB9H,MAAMyF,QAAQ,IAAI5H,UAAUkI;wBAEjD1G,OAAO0I,cAAc,CAACD,gBAAgB;4BAClCzI,QAAQ8H;4BACR1E,KAAKkF,WAAWlF,GAAG;4BACnBuF,IAAI,IAAI,CAACtD,uBAAuB,CAC5B;gCAAE,GAAG/E,UAAU;gCAAE,CAACwH,eAAe,EAAEW;4BAAe,GAClDzI,OAAOoD,GAAG,EACVqF,gBACA9H,MAAMqF,IAAI,GACJ;gCACIH,IAAIgC;gCACJ7B,MAAMrF,MAAMqF,IAAI;4BACpB,IACA6B;4BAEVe,OAAOf;4BACP,GAAIlH,MAAM0F,IAAI,KAAK,YAAY;gCAAE9B,MAAM;4BAAK,IAAI,CAAC,CAAC;4BAClD5D,OAAO0H;wBACX;wBAEA,IAAIQ,kBAAkBnB,QAAQtB,QAAQ,IAAI5H,UAAUwB,OAAOV,IAAI;wBAE/DgH,WAAWoC,cAAc,CAACG,iBAAiB;4BACvC7I,QAAQ8H;4BACR1E,KAAKkF,WAAWlF,GAAG;4BACnBuF,IAAI,IAAI,CAACtD,uBAAuB,CAC5B;gCAAE,GAAG/E,UAAU;gCAAE,CAACwH,eAAe,EAAEe;4BAAgB,GACnDvC,WAAWlD,GAAG,EACdyF,iBACAnB,QAAQ1B,IAAI,GACN;gCACIH,IAAIwC;gCACJrC,MAAM0B,QAAQ1B,IAAI;4BACtB,IACAqC;4BAEVO,OAAOP;4BACP,GAAIX,QAAQrB,IAAI,KAAK,YAAY;gCAAE9B,MAAM;4BAAK,IAAI,CAAC,CAAC;4BACpD5D,OAAOkH;wBACX;wBAEA,IAAI,CAACK,aAAa,CAACY,GAAG,CAACd;wBACvB,IAAI,CAAC5I,MAAM,CAACC,GAAG,CAAC,WAAW,CAAC,2BAA2B,EAAE2I,KAAK,CAAC;wBAE/D,IAAI,CAACE,aAAa,CAACY,GAAG,CAACb;wBACvB,IAAI,CAAC7I,MAAM,CAACC,GAAG,CAAC,WAAW,CAAC,2BAA2B,EAAE4I,KAAK,CAAC;oBACnE,OAAO,IAAIP,QAAQrB,IAAI,KAAK,aAAa;wBACrC,IAAI1F,MAAMkF,EAAE,EAAE;4BACV,MAAM,IAAIhE,MAAM,iCAAiC7B,OAAOV,IAAI;wBAChE,OAAO;4BACH,mCAAmC;4BACnC,IAAIkG,SACA7E,MAAMyF,QAAQ,IACbzF,CAAAA,MAAM0F,IAAI,KAAK,YACV7H,UAAUkI,6BACVA,yBAAwB;4BAClC,IAAIjB,cAAc9E,MAAM8E,WAAW,IAAIiC,QAAQtB,QAAQ,IAAIpG,OAAOV,IAAI;4BAEtE,yDAAyD;4BACzD,IAAIgH,WAAWyC,UAAU,CAAC,oBAAoB;gCAC1C,IAAIC,gBAAgB;oCAChBC,SAAS;oCACTC,UAAU;oCACVC,MAAM;wCACFF,SAAS;wCACT3J,MAAM,CAAC,EAAEmH,eAAe,CAAC,EAAEH,WAAWxE,QAAQ,CAAC,kBAAkB,CAAC8G,KAAK,CAAC,CAAC;oCAC7E;oCACAQ,OAAO;gCACX;gCAEA,IAAIpL,EAAE4E,aAAa,CAAC6C,cAAc;oCAC9BA,YAAYO,IAAI,GAAG;wCACfiD,SAAS;wCACTC,UAAU;wCACVC,MAAM1D,YAAYO,IAAI;wCACtBoD,OAAOJ;oCACX;gCACJ,OAAO,IAAIrI,MAAMqF,IAAI,EAAE;oCACnBrF,MAAMqF,IAAI,GAAG;wCACTiD,SAAS;wCACTC,UAAU;wCACVC,MAAMxI,MAAMqF,IAAI;wCAChBoD,OAAOJ;oCACX;gCACJ,OAAO;oCACHrI,MAAMqF,IAAI,GAAGgD;gCACjB;4BACJ;4BAEAhJ,OAAO0I,cAAc,CAAClD,QAAQ;gCAC1BxF,QAAQyG;gCACRrD,KAAKkD,WAAWlD,GAAG;gCACnBuF,IAAI,IAAI,CAACtD,uBAAuB,CAC5B;oCAAE,GAAG/E,UAAU;oCAAE,CAACmG,eAAe,EAAEjB;gCAAO,GAC1CxF,OAAOoD,GAAG,EACVoC,QACA7E,MAAMqF,IAAI,GACJ;oCACIH,IAAIJ;oCACJO,MAAMrF,MAAMqF,IAAI;gCACpB,IACAP;gCAEV,GAAI,OAAOA,gBAAgB,WAAW;oCAAEmD,OAAOnD;gCAAY,IAAI,CAAC,CAAC;gCACjE,GAAI9E,MAAM0F,IAAI,KAAK,YAAY;oCAAE9B,MAAM;gCAAK,IAAI,CAAC,CAAC;4BACtD;wBACJ;oBACJ,OAAO;wBACH,MAAM,IAAI1C,MACN,8BACI7B,OAAOV,IAAI,GACX,oBACA+E,KAAKC,SAAS,CAAC3D,OAAO,MAAM;oBAExC;gBACJ,OAAO;oBACH,mBAAmB;oBAEnB,IAAIiH,mBAAmBjH,MAAMkF,EAAE,GACzBlF,MAAMkF,EAAE,CAAChB,KAAK,CAAC,OACf;wBAACtG,UAAU8K,YAAY,CAACrJ,OAAOV,IAAI,EAAEmH;qBAAgB;oBAC3DlF,QAAQqG,iBAAiB/H,MAAM,IAAI;oBAEnC,IAAIgI,mBAAmB,AAACD,iBAAiB/H,MAAM,GAAG,KAAK+H,gBAAgB,CAAC,EAAE,IAAK5H,OAAOV,IAAI;oBAC1F,IAAIwI,iBAAiBvJ,UAAUwJ,YAAY,CAACH,gBAAgB,CAAC,EAAE;oBAE/DrG,QAAQuG;oBAER,IAAIE,OAAO,CAAC,EAAEhI,OAAOV,IAAI,CAAC,CAAC,EACvBqB,MAAM0F,IAAI,KAAK,YAAY,MAAM,IACpC,CAAC,EAAEI,eAAe,MAAM,EAAEqB,eAAe,CAAC;oBAE3C,IAAInH,MAAMyF,QAAQ,EAAE;wBAChB4B,QAAQ,MAAMrH,MAAMyF,QAAQ;oBAChC;oBAEA7E,QAAQ,CAAC,IAAI,CAAC2G,aAAa,CAACC,GAAG,CAACH;oBAEhC,IAAIM,aAAarJ,OAAO+H,eAAe,CAAChH,OAAOkD,UAAU,EAAE4E,gBAAgBrI;oBAC3E,IAAI,CAAC6I,YAAY;wBACb,UAAU;wBACVA,aAAa,IAAI,CAACC,kBAAkB,CAChCtJ,QACA6I,gBACA9H,OAAOV,IAAI,EACXmH,gBACAoB,kBACAnB;wBAEJjH,gBAAgB0D,IAAI,CAACmF,WAAWhJ,IAAI;wBACpC,IAAI,CAACF,MAAM,CAACC,GAAG,CAAC,SAAS,CAAC,YAAY,EAAEiJ,WAAWhJ,IAAI,CAAC,uBAAuB,CAAC;oBACpF;oBAEA,2CAA2C;oBAC3C,IAAIgK,eAAehB,WAAWX,cAAc,CAAC3H,OAAOV,IAAI,EAAE;wBACtD+G,MAAM;wBACND,UAAU,CAACpE,IAAMhE,EAAEwJ,KAAK,CAACxF,MAAMA,KAAK6F;oBACxC;oBAEA,IAAI,CAACyB,cAAc;wBACf,MAAM,IAAIzH,MACN,CAAC,+BAA+B,EAAE7B,OAAOV,IAAI,CAAC,wBAAwB,EAAEwI,eAAe,EAAE,CAAC;oBAElG;oBAEA,IAAIyB,eAAejB,WAAWX,cAAc,CACxClB,gBACA;wBAAEJ,MAAM;oBAAW,GACnB;wBAAEgB,aAAaiC;oBAAa;oBAGhC,IAAI,CAACC,cAAc;wBACf,MAAM,IAAI1H,MACN,CAAC,+BAA+B,EAAE4E,eAAe,wBAAwB,EAAEqB,eAAe,EAAE,CAAC;oBAErG;oBAEA,IAAIO,oBAAoBkB,aAAanD,QAAQ,IAAIM;oBAEjD,IAAImB,qBAAqBQ,mBAAmB;wBACxC,MAAM,IAAIxG,MACN,kEACIwC,KAAKC,SAAS,CAAC;4BACXkF,KAAKxJ,OAAOV,IAAI;4BAChBmK,MAAMhD;4BACNL,UAAUzF,MAAMyF,QAAQ;4BACxBP,IAAIgC;wBACR;oBAEZ;oBAEA,IAAI,CAACW,qBAAqB,CACtBF,YACAtI,QACAsG,YACAtG,OAAOV,IAAI,EACXmH,gBACAoB,kBACAQ;oBAGJ,IAAII,iBAAiB9H,MAAMyF,QAAQ,IAAI5H,UAAUkI;oBAEjD1G,OAAO0I,cAAc,CAACD,gBAAgB;wBAClCzI,QAAQ8H;wBACR1E,KAAKkF,WAAWlF,GAAG;wBACnBuF,IAAI,IAAI,CAACtD,uBAAuB,CAC5B;4BACI,GAAG/E,UAAU;4BACb,CAACmG,eAAe,EAAEgC,iBAAiB,MAAMJ;4BACzC,CAACP,eAAe,EAAEW;wBACtB,GACAzI,OAAOoD,GAAG,EACVqF,gBACA9H,MAAMqF,IAAI,GACJ;4BACIH,IAAIgC;4BACJ7B,MAAMrF,MAAMqF,IAAI;wBACpB,IACA6B;wBAEVe,OAAOf;wBACP,GAAIlH,MAAM0F,IAAI,KAAK,YAAY;4BAAE9B,MAAM;wBAAK,IAAI,CAAC,CAAC;wBAClD5D,OAAO0H;oBACX;oBAEA,IAAI,CAACH,aAAa,CAACY,GAAG,CAACd;oBACvB,IAAI,CAAC5I,MAAM,CAACC,GAAG,CAAC,WAAW,CAAC,2BAA2B,EAAE2I,KAAK,CAAC;gBACnE;gBAEA;YAEJ,KAAK;YACL,KAAK;gBACD,IAAIzC,aAAa5E,MAAMyF,QAAQ,IAAIM;gBACnC,IAAIgD,gBAAgBzC,aAAa3H,IAAI;gBACrC,IAAIqK,kBAAkB1C;gBAEtB,IAAItG,MAAM0F,IAAI,KAAK,YAAY;oBAC3B,IAAIuD,MAAM,CAAC,EAAE5J,OAAOV,IAAI,CAAC,GAAG,EAAEmH,eAAe,GAAG,EAAElB,WAAW,CAAC;oBAE9D,IAAI5E,MAAMkJ,SAAS,EAAE;wBACjB,IAAI,CAACvD,WAAWwD,QAAQ,CAACnJ,MAAMkJ,SAAS,GAAG;4BACvC,MAAM,IAAIhI,MACN,CAAC,WAAW,EAAElB,MAAMkJ,SAAS,CAAC,6CAA6C,EAAEpD,eAAe,EAAE,CAAC;wBAEvG;wBAEAiD,gBAAgB/I,MAAMkJ,SAAS;wBAC/BF,kBAAkBrD,WAAWzD,MAAM,CAAC6G,cAAc;oBACtD;oBAEAE,OAAO,OAAOjJ,MAAMkJ,SAAS;oBAE7B,IAAI,IAAI,CAAC3B,aAAa,CAACC,GAAG,CAACyB,MAAM;wBAC7B,uCAAuC;wBACvC;oBACJ;oBAEA,IAAI,CAAC1B,aAAa,CAACY,GAAG,CAACc;oBACvB,IAAI,CAACxK,MAAM,CAACC,GAAG,CAAC,WAAW,CAAC,0BAA0B,EAAEuK,IAAI,CAAC;gBACjE;gBAEA,IAAIG,SAAS;oBAAE,CAACxE,WAAW,EAAE,IAAI,CAACJ,kBAAkB,CAACI,aAAa,MAAMmE;gBAAe;gBAEvF,IAAI/I,MAAMqF,IAAI,EAAE;oBACZtG,OAAO2D,MAAM,CACT0G,QACA,IAAI,CAAChE,6BAA6B,CAAC;wBAAE,GAAGzF,UAAU;wBAAE,CAACmG,eAAe,EAAElB;oBAAW,GAAG5E,MAAMqF,IAAI;gBAEtG;gBAEAhG,OAAOgK,aAAa,CAACzE,YAAYe,YAAYqD,iBAAiBhJ,MAAMsJ,UAAU;gBAC9EjK,OAAO0I,cAAc,CAACnD,YAAY;oBAC9Bc,MAAM1F,MAAM0F,IAAI;oBAChBrG,QAAQyG;oBACRrD,KAAKkD,WAAWlD,GAAG;oBACnBwF,OAAOc;oBACPf,IAAIoB;gBACR;gBAEA,wBAAwB;gBACxB,IAAIG,gBAAgBlK,OAAO6C,MAAM,CAAC0C,WAAW;gBAE7C,IAAI4E,cAAc,CAAC;gBAEnB,IAAID,cAAcE,kBAAkB,EAAE;oBAClCD,YAAYE,QAAQ,GAAGH,cAAcE,kBAAkB;gBAC3D;gBAEA,IAAIF,cAAcI,kBAAkB,EAAE;oBAClCH,YAAYI,QAAQ,GAAGL,cAAcI,kBAAkB;gBAC3D;gBAEA,IAAI3J,MAAM0F,IAAI,KAAK,aAAa;oBAC5B8D,YAAYE,QAAQ,IAAKF,CAAAA,YAAYE,QAAQ,GAAG,SAAQ;oBACxDF,YAAYI,QAAQ,IAAKJ,CAAAA,YAAYI,QAAQ,GAAG,SAAQ;gBAC5D,OAAO,IAAIL,cAAcM,QAAQ,EAAE;oBAC/BL,YAAYE,QAAQ,IAAKF,CAAAA,YAAYE,QAAQ,GAAG,UAAS;oBACzDF,YAAYI,QAAQ,IAAKJ,CAAAA,YAAYI,QAAQ,GAAG,UAAS;gBAC7D;gBAEAJ,YAAYE,QAAQ,IAAKF,CAAAA,YAAYE,QAAQ,GAAG,WAAU;gBAC1DF,YAAYI,QAAQ,IAAKJ,CAAAA,YAAYI,QAAQ,GAAG,WAAU;gBAE1D,IAAI,CAACE,aAAa,CAACzK,OAAOV,IAAI,EAAEiG,YAAYkB,gBAAgBiD,eAAeS;gBAC3E;QACR;IACJ;IAEApE,8BAA8BT,OAAO,EAAEoF,MAAM,EAAE;QAC3CnJ,QAAQmJ,OAAOzB,OAAO;QAEtB,IAAIyB,OAAOzB,OAAO,KAAK,oBAAoB;YACvC,IAAIyB,OAAOxB,QAAQ,KAAK,MAAM;gBAC1B,IAAIC,OAAOuB,OAAOvB,IAAI;gBACtB,IAAIA,KAAKF,OAAO,IAAIE,KAAKF,OAAO,KAAK,mBAAmB;oBACpDE,OAAO,IAAI,CAACwB,mBAAmB,CAACrF,SAAS6D,KAAK7J,IAAI,EAAE;gBACxD;gBAEA,IAAI8J,QAAQsB,OAAOtB,KAAK;gBACxB,IAAIA,MAAMH,OAAO,IAAIG,MAAMH,OAAO,KAAK,mBAAmB;oBACtDG,QAAQ,IAAI,CAACuB,mBAAmB,CAACrF,SAAS8D,MAAM9J,IAAI;gBACxD;gBAEA,OAAO;oBACH,CAAC6J,KAAK,EAAE;wBAAEyB,KAAKxB;oBAAM;gBACzB;YACJ,OAAO,IAAIsB,OAAOxB,QAAQ,KAAK,MAAM;gBACjC,IAAIC,OAAOuB,OAAOvB,IAAI;gBACtB,IAAIA,KAAKF,OAAO,IAAIE,KAAKF,OAAO,KAAK,mBAAmB;oBACpDE,OAAO,IAAI,CAACwB,mBAAmB,CAACrF,SAAS6D,KAAK7J,IAAI,EAAE;gBACxD;gBAEA,IAAI8J,QAAQsB,OAAOtB,KAAK;gBACxB,IAAIA,MAAMH,OAAO,IAAIG,MAAMH,OAAO,KAAK,mBAAmB;oBACtDG,QAAQ,IAAI,CAACuB,mBAAmB,CAACrF,SAAS8D,MAAM9J,IAAI;gBACxD;gBAEA,OAAO;oBACH,CAAC6J,KAAK,EAAE;wBAAE0B,KAAKzB;oBAAM;gBACzB;YACJ;QACJ,OAAO,IAAIsB,OAAOzB,OAAO,KAAK,mBAAmB;YAC7C,IAAI6B;YAEJ,OAAQJ,OAAOxB,QAAQ;gBACnB,KAAK;oBACD4B,MAAMJ,OAAOK,QAAQ;oBACrB,IAAID,IAAI7B,OAAO,IAAI6B,IAAI7B,OAAO,KAAK,mBAAmB;wBAClD6B,MAAM,IAAI,CAACH,mBAAmB,CAACrF,SAASwF,IAAIxL,IAAI,EAAE;oBACtD;oBAEA,OAAO;wBACH,CAACwL,IAAI,EAAE;4BAAEF,KAAK;wBAAK;oBACvB;gBAEJ,KAAK;oBACDE,MAAMJ,OAAOK,QAAQ;oBACrB,IAAID,IAAI7B,OAAO,IAAI6B,IAAI7B,OAAO,KAAK,mBAAmB;wBAClD6B,MAAM,IAAI,CAACH,mBAAmB,CAACrF,SAASwF,IAAIxL,IAAI,EAAE;oBACtD;oBAEA,OAAO;wBACH,CAACwL,IAAI,EAAE;4BAAED,KAAK;wBAAK;oBACvB;gBAEJ;oBACI,MAAM,IAAIhJ,MAAM,uCAAuC6I,OAAOxB,QAAQ;YAC9E;QACJ,OAAO,IAAIwB,OAAOzB,OAAO,KAAK,qBAAqB;YAC/C,OAAQyB,OAAOxB,QAAQ;gBACnB,KAAK;oBACD,OAAO;wBACHjD,MAAM;4BACF,IAAI,CAACF,6BAA6B,CAACT,SAASoF,OAAOvB,IAAI;4BACvD,IAAI,CAACpD,6BAA6B,CAACT,SAASoF,OAAOtB,KAAK;yBAC3D;oBACL;gBAEJ,KAAK;oBACD,OAAO;wBACH4B,KAAK;4BACD,IAAI,CAACjF,6BAA6B,CAACT,SAASoF,OAAOvB,IAAI;4BACvD,IAAI,CAACpD,6BAA6B,CAACT,SAASoF,OAAOtB,KAAK;yBAC3D;oBACL;YACR;QACJ;QAEA,MAAM,IAAIvH,MAAM,qBAAqBwC,KAAKC,SAAS,CAACoG;IACxD;IAEAC,oBAAoBrF,OAAO,EAAE5B,GAAG,EAAEuH,KAAK,EAAE;QACrC,IAAI,CAACC,MAAM,GAAGC,MAAM,GAAGzH,IAAImB,KAAK,CAAC;QAEjC,IAAIuG,aAAa9F,OAAO,CAAC4F,KAAK;QAC9B,IAAI,CAACE,YAAY;YACbC,QAAQhM,GAAG,CAACiG;YACZ,MAAM,IAAIzD,MAAM,CAAC,mBAAmB,EAAE6B,IAAI,uBAAuB,CAAC;QACtE;QAEA,IAAI4H,UAAU;YAACF;eAAeD;SAAM,CAACnK,IAAI,CAAC;QAE1C,IAAIiK,OAAO;YACP,OAAOK;QACX;QAEA,OAAO,IAAI,CAACnG,kBAAkB,CAACmG;IACnC;IAEAb,cAActB,IAAI,EAAEoC,SAAS,EAAEnC,KAAK,EAAEoC,UAAU,EAAErB,WAAW,EAAE;QAC3D,IAAIjI,MAAMC,OAAO,CAACoJ,YAAY;YAC1BA,UAAU7K,OAAO,CAAC,CAAC+K,KAAO,IAAI,CAAChB,aAAa,CAACtB,MAAMsC,IAAIrC,OAAOoC,YAAYrB;YAC1E;QACJ;QAEA,IAAInM,EAAE4E,aAAa,CAAC2I,YAAY;YAC5B,IAAI,CAACd,aAAa,CAACtB,MAAMoC,UAAU1F,EAAE,EAAEuD,MAAMoC,UAAU,EAAErB;YACzD;QACJ;QAEA5I,QAAQ,OAAOgK,cAAc;QAE7B,IAAIG,kBAAkB,IAAI,CAACnI,WAAW,CAAC4F,KAAK;QAC5C,IAAI,CAACuC,iBAAiB;YAClBA,kBAAkB,EAAE;YACpB,IAAI,CAACnI,WAAW,CAAC4F,KAAK,GAAGuC;QAC7B,OAAO;YACH,IAAIC,QAAQ3N,EAAE4N,IAAI,CACdF,iBACA,CAACG,OAASA,KAAKN,SAAS,KAAKA,aAAaM,KAAKzC,KAAK,KAAKA,SAASyC,KAAKL,UAAU,KAAKA;YAG1F,IAAIG,OAAO;QACf;QAEAD,gBAAgBvI,IAAI,CAAC;YAAEoI;YAAWnC;YAAOoC;YAAYrB;QAAY;IACrE;IAEA2B,qBAAqB3C,IAAI,EAAEoC,SAAS,EAAE;QAClC,IAAIG,kBAAkB,IAAI,CAACnI,WAAW,CAAC4F,KAAK;QAC5C,IAAI,CAACuC,iBAAiB;YAClB,OAAOvF;QACX;QAEA,IAAI4F,YAAY/N,EAAE4N,IAAI,CAACF,iBAAiB,CAACG,OAASA,KAAKN,SAAS,KAAKA;QAErE,IAAI,CAACQ,WAAW;YACZ,OAAO5F;QACX;QAEA,OAAO4F;IACX;IAEAC,qBAAqB7C,IAAI,EAAEoC,SAAS,EAAE;QAClC,IAAIG,kBAAkB,IAAI,CAACnI,WAAW,CAAC4F,KAAK;QAC5C,IAAI,CAACuC,iBAAiB,OAAO;QAE7B,OAAOvF,cAAcnI,EAAE4N,IAAI,CAACF,iBAAiB,CAACG,OAASA,KAAKN,SAAS,KAAKA;IAC9E;IAEAU,qBAAqB9C,IAAI,EAAEC,KAAK,EAAE;QAC9B,IAAIsC,kBAAkB,IAAI,CAACnI,WAAW,CAAC4F,KAAK;QAC5C,IAAI,CAACuC,iBAAiB;YAClB,OAAOvF;QACX;QAEA,IAAI4F,YAAY/N,EAAE4N,IAAI,CAACF,iBAAiB,CAACG,OAASA,KAAKzC,KAAK,KAAKA;QAEjE,IAAI,CAAC2C,WAAW;YACZ,OAAO5F;QACX;QAEA,OAAO4F;IACX;IAEAG,qBAAqB/C,IAAI,EAAEC,KAAK,EAAE;QAC9B,IAAIsC,kBAAkB,IAAI,CAACnI,WAAW,CAAC4F,KAAK;QAC5C,IAAI,CAACuC,iBAAiB,OAAO;QAE7B,OAAOvF,cAAcnI,EAAE4N,IAAI,CAACF,iBAAiB,CAACG,OAASA,KAAKzC,KAAK,KAAKA;IAC1E;IAEA/G,gBAAgBpD,MAAM,EAAEe,MAAM,EAAEiC,WAAW,EAAEkK,OAAO,EAAE;QAClD,IAAIvD;QAEJ,OAAQ3G;YACJ,KAAK;gBACD2G,QAAQ5I,OAAO6C,MAAM,CAACsJ,QAAQvD,KAAK,CAAC;gBAEpC,IAAIA,MAAMvC,IAAI,KAAK,aAAa,CAACuC,MAAMwD,SAAS,EAAE;oBAC9CxD,MAAMyD,eAAe,GAAG;oBACxB,IAAI,eAAeF,SAAS;wBACxB,IAAI,CAACtL,OAAO,CAACyL,IAAI,CAAC,qBAAqBtM,OAAOV,IAAI,EAAE,CAACiN;4BACjDA,SAAS,CAAC,iBAAiB,GAAGJ,QAAQK,SAAS;wBACnD;oBACJ;gBACJ;gBACA;YAEJ,KAAK;gBACD5D,QAAQ5I,OAAO6C,MAAM,CAACsJ,QAAQvD,KAAK,CAAC;gBACpCA,MAAM6D,iBAAiB,GAAG;gBAC1B;YAEJ,KAAK;gBACD7D,QAAQ5I,OAAO6C,MAAM,CAACsJ,QAAQvD,KAAK,CAAC;gBACpCA,MAAM8D,iBAAiB,GAAG;gBAC1B;YAEJ,KAAK;gBACD;YAEJ,KAAK;gBACD;YAEJ,KAAK;gBACD;YAEJ,KAAK;gBACD;YAEJ,KAAK;gBACD;YAEJ,KAAK;gBACD;YAEJ,KAAK;gBACD,IAAIC,oBAAoBxO,IAAIc,OAAO2N,kBAAkB,EAAE;gBAEvD,IAAI,CAACD,mBAAmB;oBACpB,MAAM,IAAI9K,MACN,CAAC,sEAAsE,EAAE5C,OAAOK,IAAI,CAAC,EAAE,CAAC;gBAEhG;gBAEA,IAAI,CAACqN,kBAAkBE,UAAU,EAAE;oBAC/B,MAAM,IAAIhL,MAAM,CAAC,4CAA4C,EAAE5C,OAAOK,IAAI,CAAC,CAAC;gBAChF;gBAEAI,OAAO2D,MAAM,CAAC8I,SAASQ;gBACvB;YAEJ;gBACI,MAAM,IAAI9K,MAAM,0BAA0BI,cAAc;QAChE;IACJ;IAEA2B,WAAWY,QAAQ,EAAEsI,OAAO,EAAE;QAC1BxO,GAAGyO,cAAc,CAACvI;QAClBlG,GAAG0O,aAAa,CAACxI,UAAUsI;QAE3B,IAAI,CAAC1N,MAAM,CAACC,GAAG,CAAC,QAAQ,0BAA0BmF;IACtD;IAEA+D,mBACItJ,MAAM,EACNgO,kBAAkB,EAClBC,YAAY,gBAAgB,GAAjB,EACXC,YAAY,gBAAgB,GAAjB,EACXC,eAAe,EACfC,eAAe,EACjB;QACE,IAAIC,aAAa;YACbxL,UAAU;gBAAC;gBAAU;aAAkB;YACvCyL,SAAS;gBACL;oBACI1K,QAAQ;wBAACuK;wBAAiBC;qBAAgB;oBAC1CG,QAAQ;gBACZ;aACH;YACDrN,cAAc;gBACV;oBACIkG,MAAM;oBACNC,YAAY4G;oBACZ9G,UAAUgH;gBACd;gBACA;oBACI/G,MAAM;oBACNC,YAAY6G;oBACZ/G,UAAUiH;gBACd;aACH;QACL;QAEA,IAAIrN,SAAS,IAAIrB,OAAO,IAAI,CAACS,MAAM,EAAE6N,oBAAoBhO,OAAOiE,UAAU,EAAEoK;QAC5EtN,OAAOyN,IAAI;QAEXxO,OAAOyO,SAAS,CAAC1N;QAEjB,OAAOA;IACX;IAEA;;;;;;;;;KASC,GACDwI,sBACImF,cAAc,EACdC,OAAO,EACPC,OAAO,EACPX,YAAY,gBAAgB,GAAjB,EACXC,YAAY,gBAAgB,GAAjB,EACXtF,gBAAgB,EAChBQ,iBAAiB,EACnB;QACE,IAAI4E,qBAAqBU,eAAerO,IAAI;QAE5C,IAAI,CAACwO,iBAAiB,CAACb,mBAAmB,GAAG;QAE7C,IAAIU,eAAezN,IAAI,CAACC,YAAY,EAAE;YAClC,0EAA0E;YAC1E,IAAI4N,kBAAkB,OAClBC,kBAAkB;YAEtBhQ,EAAEsD,IAAI,CAACqM,eAAezN,IAAI,CAACC,YAAY,EAAE,CAACQ;gBACtC,IACIA,MAAM0F,IAAI,KAAK,cACf1F,MAAM2F,UAAU,KAAK4G,eACrB,AAACvM,CAAAA,MAAMyF,QAAQ,IAAI8G,WAAU,MAAOrF,kBACtC;oBACEkG,kBAAkB;gBACtB;gBAEA,IACIpN,MAAM0F,IAAI,KAAK,cACf1F,MAAM2F,UAAU,KAAK6G,eACrB,AAACxM,CAAAA,MAAMyF,QAAQ,IAAI+G,WAAU,MAAO9E,mBACtC;oBACE2F,kBAAkB;gBACtB;YACJ;YAEA,IAAID,mBAAmBC,iBAAiB;gBACpC,wDAAwD;gBACxD;YACJ;QACJ;QAEA,IAAIhG,OAAO,CAAC,EAAEiF,mBAAmB,GAAG,EAAEC,YAAY,GAAG,EAAErF,iBAAiB,CAAC;QACzE,IAAII,OAAO,CAAC,EAAEgF,mBAAmB,GAAG,EAAEE,YAAY,GAAG,EAAE9E,kBAAkB,CAAC;QAE1E,IAAI,IAAI,CAACH,aAAa,CAACC,GAAG,CAACH,OAAO;YAC9BzG,QAAQ,IAAI,CAAC2G,aAAa,CAACC,GAAG,CAACF;YAE/B,yBAAyB;YACzB;QACJ;QAEA,IAAI,CAACC,aAAa,CAACY,GAAG,CAACd;QACvB,IAAI,CAAC5I,MAAM,CAACC,GAAG,CAAC,WAAW,CAAC,8BAA8B,EAAE2I,KAAK,CAAC;QAElE,IAAI,CAACE,aAAa,CAACY,GAAG,CAACb;QACvB,IAAI,CAAC7I,MAAM,CAACC,GAAG,CAAC,WAAW,CAAC,8BAA8B,EAAE4I,KAAK,CAAC;QAElE,IAAIgG,aAAaL,QAAQpH,WAAW;QACpC,IAAItE,MAAMC,OAAO,CAAC8L,aAAa;YAC3B,MAAM,IAAIpM,MAAM,CAAC,kDAAkD,EAAEqL,YAAY,CAAC;QACtF;QAEA,IAAIgB,aAAaL,QAAQrH,WAAW;QACpC,IAAItE,MAAMC,OAAO,CAAC+L,aAAa;YAC3B,MAAM,IAAIrM,MAAM,CAAC,kDAAkD,EAAEsL,YAAY,CAAC;QACtF;QAEAQ,eAAe3D,aAAa,CAACnC,kBAAkB+F,SAASK;QACxDN,eAAe3D,aAAa,CAAC3B,mBAAmBwF,SAASK;QAEzDP,eAAejF,cAAc,CAACb,kBAAkB;YAAE7H,QAAQkN;QAAY;QACtES,eAAejF,cAAc,CAACL,mBAAmB;YAAErI,QAAQmN;QAAY;QAEvE,IAAIgB,aAAa;YAAE9D,UAAU;YAAYE,UAAU;QAAW;QAE9D,IAAI,CAACE,aAAa,CAACwC,oBAAoBpF,kBAAkBqF,aAAae,WAAW3O,IAAI,EAAE6O;QACvF,IAAI,CAAC1D,aAAa,CAACwC,oBAAoB5E,mBAAmB8E,aAAae,WAAW5O,IAAI,EAAE6O;IAC5F;IAEA,OAAOC,WAAWC,EAAE,EAAE;QAClB,OAAQA;YACJ,KAAK;gBACD,OAAO;YAEX;gBACI,MAAM,IAAIxM,MAAM;QACxB;IACJ;IAEA,OAAOyM,SAASrP,MAAM,EAAEsP,GAAG,EAAEC,GAAG,EAAEC,MAAM,EAAE;QACtC,IAAI,CAACD,IAAIvF,OAAO,EAAE;YACd,OAAOuF;QACX;QAEA,OAAQA,IAAIvF,OAAO;YACf,KAAK;gBACD,IAAIE,MAAMC;gBAEV,IAAIoF,IAAIrF,IAAI,CAACF,OAAO,EAAE;oBAClBE,OAAOpK,aAAauP,QAAQ,CAACrP,QAAQsP,KAAKC,IAAIrF,IAAI,EAAEsF;gBACxD,OAAO;oBACHtF,OAAOqF,IAAIrF,IAAI;gBACnB;gBAEA,IAAIqF,IAAIpF,KAAK,CAACH,OAAO,EAAE;oBACnBG,QAAQrK,aAAauP,QAAQ,CAACrP,QAAQsP,KAAKC,IAAIpF,KAAK,EAAEqF;gBAC1D,OAAO;oBACHrF,QAAQoF,IAAIpF,KAAK;gBACrB;gBAEA,OAAOD,OAAO,MAAMpK,aAAaqP,UAAU,CAACI,IAAItF,QAAQ,IAAI,MAAME;YAEtE,KAAK;gBACD,IAAI,CAAC7K,UAAUmQ,cAAc,CAACF,IAAIlP,IAAI,GAAG;oBACrC,IAAImP,UAAUzQ,EAAE4N,IAAI,CAAC6C,QAAQ,CAACE,IAAMA,EAAErP,IAAI,KAAKkP,IAAIlP,IAAI,MAAM,CAAC,GAAG;wBAC7D,OAAO,MAAMtB,EAAE4Q,UAAU,CAACJ,IAAIlP,IAAI;oBACtC;oBAEA,MAAM,IAAIuC,MAAM,CAAC,qCAAqC,EAAE2M,IAAIlP,IAAI,CAAC,EAAE,CAAC;gBACxE;gBAEA,IAAI,EAAEuP,UAAU,EAAE7O,MAAM,EAAE4I,KAAK,EAAE,GAAGrK,UAAUuQ,wBAAwB,CAAC7P,QAAQsP,KAAKC,IAAIlP,IAAI;gBAE5F,OAAOuP,WAAWE,KAAK,GAAG,MAAMhQ,aAAaiQ,eAAe,CAACpG,MAAMtJ,IAAI;YAE3E;gBACI,MAAM,IAAIuC,MAAM;QACxB;IACJ;IAEA,OAAOoN,cAAchQ,MAAM,EAAEsP,GAAG,EAAEC,GAAG,EAAE;QACnC,OACIzP,aAAauP,QAAQ,CAACrP,QAAQsP,KAAK;YAAEtF,SAAS;YAAmB3J,MAAMkP,IAAI5F,KAAK;QAAC,KAChF4F,CAAAA,IAAIU,MAAM,GAAG,KAAK,OAAM;IAEjC;IAEAC,mBAAmB5P,cAAc,EAAE6P,IAAI,EAAE;QACrC,IAAIC,MAAM;QACV,oCAAoC;QACpC,IAAId,MAAMvQ,EAAEsR,SAAS,CAACF,KAAKG,oBAAoB,CAAChQ;QAChD,6CAA6C;QAE7C,wBAAwB;QACxB,IAAI,CAACiQ,SAAST,OAAOU,MAAM,GAAG,IAAI,CAACC,gBAAgB,CAACnQ,gBAAgBgP,KAAK;QAEzEc,OAAO,YAAYG,QAAQxO,IAAI,CAAC,QAAQ,WAAWjC,aAAaiQ,eAAe,CAACT,IAAIvO,MAAM,IAAI,SAAS+O;QAEvG,IAAI,CAAC/Q,EAAEiC,OAAO,CAACwP,QAAQ;YACnBJ,OAAO,MAAMI,MAAMzO,IAAI,CAAC;QAC5B;QAEA,IAAI,CAAChD,EAAEiC,OAAO,CAACmP,KAAKO,QAAQ,GAAG;YAC3BN,OACI,YACAD,KAAKO,QAAQ,CACRjK,GAAG,CAAC,CAACkK,SAAW7Q,aAAauP,QAAQ,CAAC/O,gBAAgBgP,KAAKqB,QAAQR,KAAKX,MAAM,GAC9EzN,IAAI,CAAC;QAClB;QAEA,IAAI,CAAChD,EAAEiC,OAAO,CAACmP,KAAKS,OAAO,GAAG;YAC1BR,OACI,eACAD,KAAKS,OAAO,CAACnK,GAAG,CAAC,CAACoK,MAAQ/Q,aAAakQ,aAAa,CAAC1P,gBAAgBgP,KAAKuB,MAAM9O,IAAI,CAAC;QAC7F;QAEA,IAAI,CAAChD,EAAEiC,OAAO,CAACmP,KAAKW,OAAO,GAAG;YAC1BV,OACI,eACAD,KAAKW,OAAO,CAACrK,GAAG,CAAC,CAACoK,MAAQ/Q,aAAakQ,aAAa,CAAC1P,gBAAgBgP,KAAKuB,MAAM9O,IAAI,CAAC;QAC7F;QAEA,IAAIgP,OAAOZ,KAAKY,IAAI,IAAI;QACxB,IAAIZ,KAAKa,KAAK,EAAE;YACZZ,OACI,YACAtQ,aAAauP,QAAQ,CAAC/O,gBAAgBgP,KAAKyB,MAAMZ,KAAKX,MAAM,IAC5D,OACA1P,aAAauP,QAAQ,CAAC/O,gBAAgBgP,KAAKa,KAAKa,KAAK,EAAEb,KAAKX,MAAM;QAC1E,OAAO,IAAIW,KAAKY,IAAI,EAAE;YAClBX,OAAO,aAAatQ,aAAauP,QAAQ,CAAC/O,gBAAgBgP,KAAKa,KAAKY,IAAI,EAAEZ,KAAKX,MAAM;QACzF;QAEA,OAAOY;IACX;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;KA0BC,GAED/M,sBAAsBxC,UAAU,EAAEE,OAAO,6BAA6B,GAA9B,EAAkC;QACtE,IAAIqP,MAAM,iCAAiCvP,aAAa;QAExD,oBAAoB;QACpB9B,EAAEsD,IAAI,CAACtB,OAAO6C,MAAM,EAAE,CAAC+F,OAAOtJ;YAC1B+P,OAAO,OAAOtQ,aAAaiQ,eAAe,CAAC1P,QAAQ,MAAMP,aAAamR,gBAAgB,CAACtH,SAAS;QACpG;QAEA,aAAa;QACbyG,OAAO,oBAAoBtQ,aAAaoR,gBAAgB,CAACnQ,OAAOoD,GAAG,IAAI;QAEvE,YAAY;QACZ,IAAIpD,OAAOuN,OAAO,IAAIvN,OAAOuN,OAAO,CAAC1N,MAAM,GAAG,GAAG;YAC7CG,OAAOuN,OAAO,CAAC7M,OAAO,CAAC,CAAC0P;gBACpBf,OAAO;gBACP,IAAIe,MAAM5C,MAAM,EAAE;oBACd6B,OAAO;gBACX;gBACAA,OAAO,UAAUtQ,aAAaoR,gBAAgB,CAACC,MAAMvN,MAAM,IAAI;YACnE;QACJ;QAEA,IAAI8B,QAAQ,EAAE;QACd,IAAI,CAAC9D,OAAO,CAACC,IAAI,CAAC,+BAA+BhB,YAAY6E;QAC7D,IAAIA,MAAM9E,MAAM,GAAG,GAAG;YAClBwP,OAAO,OAAO1K,MAAM3D,IAAI,CAAC;QAC7B,OAAO;YACHqO,MAAMA,IAAIgB,MAAM,CAAC,GAAGhB,IAAIxP,MAAM,GAAG;QACrC;QAEAwP,OAAO;QAEP,eAAe;QACf,IAAIiB,aAAa,CAAC;QAClB,IAAI,CAACzP,OAAO,CAACC,IAAI,CAAC,qBAAqBhB,YAAYwQ;QACnD,IAAIC,QAAQ7Q,OAAO2D,MAAM,CAAC,CAAC,GAAG,IAAI,CAACmN,UAAU,CAACC,KAAK,EAAEH;QAErDjB,MAAMrR,EAAEuC,MAAM,CACVgQ,OACA,SAAU/P,MAAM,EAAEkQ,KAAK,EAAEtN,GAAG;YACxB,OAAO5C,SAAS,MAAM4C,MAAM,MAAMsN;QACtC,GACArB;QAGJA,OAAO;QAEP,OAAOA;IACX;IAEA1L,wBAAwB7D,UAAU,EAAE6Q,QAAQ,EAAEzR,kBAAkB,6BAA6B,GAA9B,EAAkC;QAC7F,IAAI0R,WAAWD,SAASvH,KAAK;QAE7B,IAAIwH,SAASnJ,OAAO,CAAC,OAAO,GAAG;YAC3B,IAAI,CAACoJ,YAAYC,cAAc,GAAGF,SAAS/L,KAAK,CAAC;YAEjD,IAAIkM,kBAAkB7R,iBAAiB,CAAC2R,WAAW;YACnDtP,QAAQwP;YAERH,WAAWG,gBAAgBC,QAAQ,GAAG,QAAQF;QAClD;QAEA,IAAIzB,MACA,kBACAvP,aACA,yBACA6Q,SAASpF,SAAS,GAClB,QACA,iBACAqF,WACA,SACAD,SAASnF,UAAU,GACnB;QAEJ6D,OAAO,CAAC,UAAU,EAAEsB,SAASxG,WAAW,CAACE,QAAQ,CAAC,WAAW,EAAEsG,SAASxG,WAAW,CAACI,QAAQ,CAAC,GAAG,CAAC;QAEjG,OAAO8E;IACX;IAEA,OAAO4B,sBAAsBnR,UAAU,EAAEE,MAAM,EAAE;QAC7C,IAAIkR,WAAW9S,OAAO+S,SAAS,CAACrR;QAChC,IAAIsR,YAAYhT,OAAOiT,UAAU,CAACrR,OAAOoD,GAAG;QAE5C,IAAIpF,EAAEsT,QAAQ,CAACJ,UAAUE,YAAY;YACjC,OAAOF;QACX;QAEA,OAAOA,WAAWE;IACtB;IAEA,OAAOG,YAAYC,GAAG,EAAE;QACpB,OAAO,MAAMA,IAAIC,OAAO,CAAC,MAAM,SAAS;IAC5C;IAEA,OAAOzC,gBAAgBwC,GAAG,EAAE;QACxB,OAAO,MAAMA,MAAM;IACvB;IAEA,OAAOrB,iBAAiBuB,GAAG,EAAE;QACzB,OAAO1T,EAAEmE,OAAO,CAACuP,OACXA,IAAIhM,GAAG,CAAC,CAACjF,IAAM1B,aAAaiQ,eAAe,CAACvO,IAAIO,IAAI,CAAC,QACrDjC,aAAaiQ,eAAe,CAAC0C;IACvC;IAEA,OAAOjQ,gBAAgBzB,MAAM,EAAE;QAC3B,IAAIQ,SAAS;YAAEkB,QAAQ,EAAE;YAAEE,UAAU,EAAE;QAAC;QAExC,IAAI,CAAC5B,OAAOoD,GAAG,EAAE;YACb5C,OAAOkB,MAAM,CAACyB,IAAI,CAAC;QACvB;QAEA,OAAO3C;IACX;IAEA,OAAO0P,iBAAiBtH,KAAK,EAAE+I,MAAM,EAAE;QACnC,IAAI7B;QAEJ,OAAQlH,MAAMvC,IAAI;YACd,KAAK;gBACDyJ,MAAM/Q,aAAa6S,mBAAmB,CAAChJ;gBACvC;YAEJ,KAAK;gBACDkH,MAAM/Q,aAAa8S,qBAAqB,CAACjJ;gBACzC;YAEJ,KAAK;gBACDkH,MAAM/Q,aAAa+S,oBAAoB,CAAClJ;gBACxC;YAEJ,KAAK;gBACDkH,MAAM/Q,aAAagT,oBAAoB,CAACnJ;gBACxC;YAEJ,KAAK;gBACDkH,MAAM/Q,aAAaiT,sBAAsB,CAACpJ;gBAC1C;YAEJ,KAAK;gBACDkH,MAAM/Q,aAAakT,wBAAwB,CAACrJ;gBAC5C;YAEJ,KAAK;gBACDkH,MAAM/Q,aAAa+S,oBAAoB,CAAClJ;gBACxC;YAEJ,KAAK;gBACDkH,MAAM/Q,aAAamT,oBAAoB,CAACtJ;gBACxC;YAEJ,KAAK;gBACDkH,MAAM/Q,aAAa+S,oBAAoB,CAAClJ;gBACxC;YAEJ;gBACI,MAAM,IAAI/G,MAAM,uBAAuB+G,MAAMvC,IAAI,GAAG;QAC5D;QAEA,IAAI,EAAEgJ,GAAG,EAAEhJ,IAAI,EAAE,GAAGyJ;QAEpB,IAAI,CAAC6B,QAAQ;YACTtC,OAAO,IAAI,CAAC8C,cAAc,CAACvJ;YAC3ByG,OAAO,IAAI,CAAC+C,YAAY,CAACxJ,OAAOvC;QACpC;QAEA,OAAOgJ;IACX;IAEA,OAAOuC,oBAAoB1R,IAAI,EAAE;QAC7B,IAAImP,KAAKhJ;QAET,IAAInG,KAAKmS,MAAM,EAAE;YACb,IAAInS,KAAKmS,MAAM,GAAG,IAAI;gBAClBhM,OAAOgJ,MAAM;YACjB,OAAO,IAAInP,KAAKmS,MAAM,GAAG,GAAG;gBACxBhM,OAAOgJ,MAAM;YACjB,OAAO,IAAInP,KAAKmS,MAAM,GAAG,GAAG;gBACxBhM,OAAOgJ,MAAM;YACjB,OAAO,IAAInP,KAAKmS,MAAM,GAAG,GAAG;gBACxBhM,OAAOgJ,MAAM;YACjB,OAAO;gBACHhJ,OAAOgJ,MAAM;YACjB;YAEAA,OAAO,CAAC,CAAC,EAAEnP,KAAKmS,MAAM,CAAC,CAAC,CAAC;QAC7B,OAAO;YACHhM,OAAOgJ,MAAM;QACjB;QAEA,IAAInP,KAAKoS,QAAQ,EAAE;YACfjD,OAAO;QACX;QAEA,OAAO;YAAEA;YAAKhJ;QAAK;IACvB;IAEA,OAAOwL,sBAAsB3R,IAAI,EAAE;QAC/B,IAAImP,MAAM,IACNhJ;QAEJ,IAAInG,KAAKmG,IAAI,IAAI,YAAYnG,KAAKqS,KAAK,EAAE;YACrClM,OAAOgJ,MAAM;YAEb,IAAInP,KAAKsS,WAAW,GAAG,IAAI;gBACvB,MAAM,IAAI3Q,MAAM;YACpB;QACJ,OAAO;YACH,IAAI3B,KAAKuS,KAAK,KAAK,KAAKvS,KAAKwS,MAAM,IAAIxS,KAAKsS,WAAW,GAAG,IAAI;gBAC1DnM,OAAOgJ,MAAM;gBAEb,IAAInP,KAAKsS,WAAW,GAAG,IAAI;oBACvB,MAAM,IAAI3Q,MAAM;gBACpB;YACJ,OAAO;gBACHwE,OAAOgJ,MAAM;YACjB;QACJ;QAEA,IAAI,iBAAiBnP,MAAM;YACvBmP,OAAO,MAAMnP,KAAKsS,WAAW;YAC7B,IAAI,mBAAmBtS,MAAM;gBACzBmP,OAAO,OAAOnP,KAAKyS,aAAa;YACpC;YACAtD,OAAO;QACX,OAAO;YACH,IAAI,mBAAmBnP,MAAM;gBACzB,IAAIA,KAAKyS,aAAa,GAAG,IAAI;oBACzBtD,OAAO,UAAUnP,KAAKyS,aAAa,GAAG;gBAC1C,OAAO;oBACHtD,OAAO,UAAUnP,KAAKyS,aAAa,GAAG;gBAC1C;YACJ;QACJ;QAEA,OAAO;YAAEtD;YAAKhJ;QAAK;IACvB;IAEA,OAAOyL,qBAAqB5R,IAAI,EAAE;QAC9B,IAAImP,MAAM,IACNhJ;QAEJ,IAAInG,KAAK0S,WAAW,IAAI1S,KAAK0S,WAAW,IAAI,KAAK;YAC7CvD,MAAM,UAAUnP,KAAK0S,WAAW,GAAG;YACnCvM,OAAO;QACX,OAAO,IAAInG,KAAK2S,SAAS,EAAE;YACvB,IAAI3S,KAAK2S,SAAS,GAAG,UAAU;gBAC3BxM,OAAOgJ,MAAM;YACjB,OAAO,IAAInP,KAAK2S,SAAS,GAAG,OAAO;gBAC/BxM,OAAOgJ,MAAM;YACjB,OAAO,IAAInP,KAAK2S,SAAS,GAAG,MAAM;gBAC9BxM,OAAOgJ,MAAM;YACjB,OAAO;gBACHhJ,OAAOgJ,MAAM;gBACb,IAAInP,KAAK0S,WAAW,EAAE;oBAClBvD,OAAO,MAAMnP,KAAK0S,WAAW,GAAG;gBACpC,OAAO;oBACHvD,OAAO,MAAMnP,KAAK2S,SAAS,GAAG;gBAClC;YACJ;QACJ,OAAO;YACHxM,OAAOgJ,MAAM;QACjB;QAEA,OAAO;YAAEA;YAAKhJ;QAAK;IACvB;IAEA,OAAO2L,uBAAuB9R,IAAI,EAAE;QAChC,IAAImP,MAAM,IACNhJ;QAEJ,IAAInG,KAAK0S,WAAW,IAAI,KAAK;YACzBvD,MAAM,YAAYnP,KAAK0S,WAAW,GAAG;YACrCvM,OAAO;QACX,OAAO,IAAInG,KAAK2S,SAAS,EAAE;YACvB,IAAI3S,KAAK2S,SAAS,GAAG,UAAU;gBAC3BxM,OAAOgJ,MAAM;YACjB,OAAO,IAAInP,KAAK2S,SAAS,GAAG,OAAO;gBAC/BxM,OAAOgJ,MAAM;YACjB,OAAO;gBACHhJ,OAAOgJ,MAAM;gBACb,IAAInP,KAAK0S,WAAW,EAAE;oBAClBvD,OAAO,MAAMnP,KAAK0S,WAAW,GAAG;gBACpC,OAAO;oBACHvD,OAAO,MAAMnP,KAAK2S,SAAS,GAAG;gBAClC;YACJ;QACJ,OAAO;YACHxM,OAAOgJ,MAAM;QACjB;QAEA,OAAO;YAAEA;YAAKhJ;QAAK;IACvB;IAEA,OAAO0L,uBAAuB;QAC1B,OAAO;YAAE1C,KAAK;YAAchJ,MAAM;QAAU;IAChD;IAEA,OAAO4L,yBAAyB/R,IAAI,EAAE;QAClC,IAAImP;QAEJ,IAAI,CAACnP,KAAK4S,KAAK,IAAI5S,KAAK4S,KAAK,KAAK,YAAY;YAC1CzD,MAAM;QACV,OAAO,IAAInP,KAAK4S,KAAK,KAAK,QAAQ;YAC9BzD,MAAM;QACV,OAAO,IAAInP,KAAK4S,KAAK,KAAK,QAAQ;YAC9BzD,MAAM;QACV,OAAO,IAAInP,KAAK4S,KAAK,KAAK,QAAQ;YAC9BzD,MAAM;QACV,OAAO,IAAInP,KAAK4S,KAAK,KAAK,aAAa;YACnCzD,MAAM;QACV;QAEA,OAAO;YAAEA;YAAKhJ,MAAMgJ;QAAI;IAC5B;IAEA,OAAO6C,qBAAqBhS,IAAI,EAAE;QAC9B,OAAO;YAAEmP,KAAK,UAAUrR,EAAE0H,GAAG,CAACxF,KAAK6S,MAAM,EAAE,CAACtS,IAAM1B,aAAawS,WAAW,CAAC9Q,IAAIO,IAAI,CAAC,QAAQ;YAAKqF,MAAM;QAAO;IAClH;IAEA,OAAO8L,eAAejS,IAAI,EAAE;QACxB,IAAIA,KAAK8S,cAAc,CAAC,eAAe9S,KAAKsK,QAAQ,EAAE;YAClD,OAAO;QACX;QAEA,OAAO;IACX;IAEA,OAAO4H,aAAalS,IAAI,EAAEmG,IAAI,EAAE;QAC5B,IAAInG,KAAKuM,iBAAiB,EAAE;YACxBvM,KAAK+S,UAAU,GAAG;YAClB,OAAO;QACX;QAEA,IAAI/S,KAAKmM,eAAe,EAAE;YACtBnM,KAAK+S,UAAU,GAAG;YAClB,OAAO;QACX;QAEA,IAAI/S,KAAKwM,iBAAiB,EAAE;YACxBxM,KAAKgT,UAAU,GAAG;YAClB,OAAO;QACX;QAEA,IAAI7D,MAAM;QAEV,IAAI,CAACnP,KAAKsK,QAAQ,EAAE;YAChB,IAAItK,KAAK8S,cAAc,CAAC,YAAY;gBAChC,IAAIZ,eAAelS,IAAI,CAAC,UAAU;gBAElC,IAAI,OAAOkS,iBAAiB,YAAYA,aAAahN,OAAO,KAAK,eAAe;oBAC5E,MAAM+N,YAAYf,aAAa9S,IAAI,CAAC8T,WAAW;oBAE/C,OAAQD;wBACJ,KAAK;4BACD9D,OAAO;4BACPnP,KAAK+S,UAAU,GAAG;4BAClB;wBAEJ;4BACI,MAAM,IAAIpR,MAAM,CAAC,0BAA0B,EAAEsR,UAAU,EAAE,CAAC;oBAClE;gBACJ,OAAO;oBACH,OAAQjT,KAAKmG,IAAI;wBACb,KAAK;4BACDgJ,OAAO,cAAezQ,CAAAA,MAAMyU,OAAO,CAACC,QAAQ,CAAClB,gBAAgB,MAAM,GAAE;4BACrE;wBAEJ,KAAK;4BACD,IAAIpU,EAAEuV,SAAS,CAACnB,eAAe;gCAC3B/C,OAAO,cAAc+C,aAAaoB,QAAQ;4BAC9C,OAAO;gCACHnE,OAAO,cAAcoE,SAASrB,cAAcoB,QAAQ;4BACxD;4BACA;wBAEJ,KAAK;wBACL,KAAK;4BACDnE,OAAO,cAAcpR,MAAMmU;4BAC3B;wBAEJ,KAAK;4BACD,IAAIpU,EAAE0V,QAAQ,CAACtB,eAAe;gCAC1B/C,OAAO,cAAc+C,aAAaoB,QAAQ;4BAC9C,OAAO;gCACHnE,OAAO,cAAcsE,WAAWvB,cAAcoB,QAAQ;4BAC1D;4BACA;wBAEJ,KAAK;4BACDnE,OAAO,cAAchR,QAAQ+T;4BAC7B;wBAEJ,KAAK;4BACD/C,OACI,cACApR,MAAMW,MAAMgV,QAAQ,CAACN,QAAQ,CAAClB,cAAcyB,KAAK,CAAC;gCAAEC,eAAe;4BAAM;4BAC7E;wBAEJ,KAAK;wBACL,KAAK;4BACDzE,OAAO,cAAcpR,MAAMoG,KAAKC,SAAS,CAAC8N;4BAC1C;wBAEJ;4BACI,MAAM,IAAIvQ,MAAM,CAAC,cAAc,EAAE3B,KAAKmG,IAAI,CAAC,CAAC,CAAC;oBACrD;gBACJ;YACJ,OAAO,IAAI,CAACnG,KAAK8S,cAAc,CAAC,SAAS;gBACrC,IAAInU,0BAA0BsJ,GAAG,CAAC9B,OAAO;oBACrC,OAAO;gBACX;gBAEA,IAAInG,KAAKmG,IAAI,KAAK,aAAanG,KAAKmG,IAAI,KAAK,aAAanG,KAAKmG,IAAI,KAAK,UAAU;oBAC9EgJ,OAAO;gBACX,OAAO,IAAInP,KAAKmG,IAAI,KAAK,YAAY;oBACjCgJ,OAAO;gBACX,OAAO,IAAInP,KAAKmG,IAAI,KAAK,QAAQ;oBAC7BgJ,OAAO,cAAcpR,MAAMiC,KAAK6S,MAAM,CAAC,EAAE;oBACzC7S,KAAK+S,UAAU,GAAG;gBACtB,OAAO;oBACH5D,OAAO;gBACX;YAEA,wDAAwD;YACxD,yBAAyB;YAC7B;QACJ;QAEA,OAAOA;IACX;IAEA,OAAO0E,sBAAsBjU,UAAU,EAAEkU,iBAAiB,EAAE;QACxD,IAAIA,mBAAmB;YACnBlU,aAAa9B,EAAEiW,IAAI,CAACjW,EAAEkW,SAAS,CAACpU;YAEhCkU,oBAAoBhW,EAAEmW,OAAO,CAACnW,EAAEkW,SAAS,CAACF,oBAAoB,OAAO;YAErE,IAAIhW,EAAE+G,UAAU,CAACjF,YAAYkU,oBAAoB;gBAC7ClU,aAAaA,WAAWuQ,MAAM,CAAC2D,kBAAkBnU,MAAM;YAC3D;QACJ;QAEA,OAAOtB,UAAUwJ,YAAY,CAACjI;IAClC;IA9tDA;;;;;;;KAOC,GACDsU,YAAY9O,OAAO,EAAElG,MAAM,EAAEiV,SAAS,EAAEC,SAAS,CAAE;QAC/C,IAAI,CAAClV,MAAM,GAAGA;QACd,IAAI,CAACyE,UAAU,GAAGyB,QAAQiP,UAAU;QACpC,IAAI,CAACF,SAAS,GAAGA;QAEjB,IAAI,CAACxT,OAAO,GAAG,IAAIhD;QAEnB,IAAI,CAAC2S,UAAU,GAAG8D,YACZ;YACIE,IAAIxW,EAAEyW,OAAO,CAACH,UAAUE,EAAE,EAAE,CAAC9D,OAAOtN,MAAQpF,EAAE0W,SAAS,CAACtR;YACxDqN,OAAOzS,EAAEyW,OAAO,CAACH,UAAU7D,KAAK,EAAE,CAACC,OAAOtN,MAAQpF,EAAE0W,SAAS,CAACtR;QAClE,IACA,CAAC;QAEP,IAAI,CAACG,WAAW,GAAG,CAAC;QACpB,IAAI,CAACuK,iBAAiB,GAAG,CAAC;QAC1B,IAAI,CAAC5F,aAAa,GAAG,IAAIpJ;IAC7B;AAssDJ;AAEA6V,OAAOC,OAAO,GAAG7V"}