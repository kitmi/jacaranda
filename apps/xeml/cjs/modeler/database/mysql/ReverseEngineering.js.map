{"version":3,"sources":["../../../../src/modeler/database/mysql/ReverseEngineering.js"],"sourcesContent":["const path = require(\"path\");\nconst { _, eachAsync_, pushIntoBucket } = require(\"@genx/july\");\nconst { fs } = require(\"@genx/sys\");\nconst GemlCodeGen = require(\"../../../lang/GemlCodeGen\");\nconst GemlUtils = require(\"../../../lang/GemlUtils\");\n\nconst defaultRules = {\n    skip: [\"_prisma_migrations\"],\n};\n\nclass MySQLReverseEngineering {\n    constructor(context, logger, connector) {\n        this.logger = logger;\n        this.connector = connector;\n\n        this.reverseRules = { ...defaultRules, ...this.connector.options.reverseRules };\n        this.saveIntermediate = context.saveIntermediate ?? false;\n    }\n\n    async reverse_(outputDir) {\n        this.logger.log(\n            \"info\",\n            `Pulling schema from ${this.connector.driver} database \"${this.connector.database}\" ...`\n        );\n\n        let tables = await this.connector.execute_(\"select * from information_schema.tables where table_schema = ?\", [\n            this.connector.database,\n        ]);\n\n        if (this.saveIntermediate) {\n            fs.writeFileSync(\n                path.join(outputDir, this.connector.database + \".meta.json\"),\n                JSON.stringify(tables, null, 2)\n            );\n        }\n\n        let entities = [],\n            mapOfEntities = {};\n\n        let entitiesGemlPath = path.join(outputDir, \"entities\");\n        fs.ensureDirSync(entitiesGemlPath);\n\n        const skipTables = new Set(this.reverseRules.skip ?? []);\n\n        await eachAsync_(tables, async (table) => {\n            if (skipTables.has(table.TABLE_NAME)) return;\n\n            let entityName = this._entityNaming(table.TABLE_NAME);\n\n            entities.push({ entity: entityName });\n\n            mapOfEntities[entityName] = await this.extractTable_(entityName, table, entitiesGemlPath);\n        });\n\n        this._refineEntityRelationships(mapOfEntities);\n\n        _.forOwn(mapOfEntities, ({ types, entityInfo }, entityName) => {\n            let entity = {\n                type: types,\n                entity: {\n                    [entityName]: entityInfo,\n                },\n            };\n\n            let entityContent = GemlCodeGen.transform(entity);\n            let entityFile = path.join(entitiesGemlPath, entityName + \".geml\");\n\n            if (this.saveIntermediate) {\n                fs.writeFileSync(entityFile + \".json\", JSON.stringify(entity, null, 2));\n            }\n            fs.writeFileSync(entityFile, entityContent);\n            this.logger.log(\"info\", `Generated entity definition file \"${entityFile}\".`);\n        });\n\n        let schemaName = this._schemaNaming(this.connector.database);\n\n        let json = {\n            namespace: [\"entities/**\"],\n            schema: {\n                [schemaName]: {\n                    entities: entities,\n                },\n            },\n        };\n\n        let schemaContent = GemlCodeGen.transform(json);\n        let schemaFile = path.join(outputDir, schemaName + \".geml\");\n        if (this.saveIntermediate) {\n            fs.writeFileSync(schemaFile + \".json\", JSON.stringify(json, null, 2));\n        }\n        fs.writeFileSync(schemaFile, schemaContent);\n        this.logger.log(\"info\", `Extracted schema entry file \"${schemaFile}\".`);\n    }\n\n    async extractTable_(entityName, table, targetGemlPath) {\n        let columns = await this.connector.execute_(\n            \"select * from information_schema.columns where table_schema = ? and table_name = ?\",\n            [this.connector.database, table.TABLE_NAME]\n        );\n\n        if (this.saveIntermediate) {\n            fs.writeFileSync(\n                path.join(targetGemlPath, table.TABLE_NAME + \".meta.json\"),\n                JSON.stringify(columns, null, 2)\n            );\n        }\n\n        let { features, fields, types } = this._processFields(table, columns);\n\n        let indexInfo = await this.connector.execute_(\"SHOW INDEXES FROM ??\", [table.TABLE_NAME]);\n\n        if (this.saveIntermediate && !_.isEmpty(indexInfo)) {\n            fs.writeFileSync(\n                path.join(targetGemlPath, table.TABLE_NAME + \".index.json\"),\n                JSON.stringify(indexInfo, null, 2)\n            );\n        }\n\n        let { pk, indexes, mapNameToIndex } = this._processIndexes(indexInfo);\n\n        if (pk.length === 0) {\n            throw new Error(`Table \"${table.TABLE_NAME}\" has no primary key.`);\n        }\n\n        let referencesInfo = await this.connector.execute_(\n            \"SELECT * FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE `REFERENCED_TABLE_SCHEMA` = ? AND `TABLE_NAME` = ? AND `REFERENCED_TABLE_NAME` IS NOT NULL\",\n            [this.connector.database, table.TABLE_NAME]\n        );\n\n        if (this.saveIntermediate && !_.isEmpty(referencesInfo)) {\n            fs.writeFileSync(\n                path.join(targetGemlPath, table.TABLE_NAME + \".ref.json\"),\n                JSON.stringify(referencesInfo, null, 2)\n            );\n        }\n\n        let associations = await this._processReferences_(referencesInfo, mapNameToIndex, fields);\n\n        let entityInfo = {\n            comment: table.TABLE_COMMENT,\n            features,\n            fields,\n            associations,\n            key: pk.length > 1 ? pk : pk[0],\n            indexes,\n        };\n\n        if (entityName !== table.TABLE_NAME) {\n            entityInfo.code = table.TABLE_NAME;\n        }\n\n        return { types, entityInfo };\n    }\n\n    async _processReferences_(referencesInfo, mapNameToIndex, fields) {\n        let associations = [];\n\n        let l = referencesInfo.length;\n\n        for (let i = 0; i < l; i++) {\n            let ref = referencesInfo[i];\n\n            let [refTableKey] = await this.connector.execute_(\"SHOW INDEXES FROM ?? WHERE `Key_name` = 'PRIMARY'\", [\n                ref.REFERENCED_TABLE_NAME,\n            ]);\n\n            if (refTableKey.Column_name.toLowerCase() !== ref.REFERENCED_COLUMN_NAME.toLowerCase()) {\n                throw new Error(`Foreign key \"${ref.COLUMN_NAME}\" not reference to the primary key.`);\n            }\n\n            let unique = false;\n\n            let fkInfo = mapNameToIndex[ref.CONSTRAINT_NAME];\n            if (fkInfo) {\n                if (fkInfo.length > 1) {\n                    throw new Error(`Combination foreign key is not supported: \"${ref.CONSTRAINT_NAME}\"`);\n                }\n\n                unique = fkInfo[0].Non_unique === 0;\n            }\n\n            let fkColName = this._fieldNaming(ref.COLUMN_NAME);\n\n            if (unique) {\n                associations.push({\n                    type: \"belongsTo\",\n                    srcField: fkColName,\n                    destEntity: this._entityNaming(ref.REFERENCED_TABLE_NAME),\n                });\n            } else {\n                associations.push({\n                    type: \"hasMany\",\n                    srcField: fkColName,\n                    destEntity: this._entityNaming(ref.REFERENCED_TABLE_NAME),\n                });\n            }\n\n            delete fields[fkColName]; // = { type: '$association', code: fields[fkColName].code };\n        }\n\n        return associations;\n    }\n\n    _processIndexes(indexInfo) {\n        let pk = [],\n            indexes = [];\n\n        let mapNameToIndex = {};\n\n        indexInfo.forEach((i) => {\n            pushIntoBucket(mapNameToIndex, i.Key_name, i);\n        });\n\n        _.forOwn(mapNameToIndex, (fields, name) => {\n            if (name === \"PRIMARY\") {\n                pk.push(fields.map((f) => this._fieldNaming(f.Column_name)));\n            } else {\n                indexes.push({\n                    name: name,\n                    fields: fields.map((f) => this._fieldNaming(f.Column_name)),\n                    unique: fields[0].Non_unique === 0,\n                    nullable: fields[0].Null === \"YES\",\n                });\n            }\n        });\n\n        return { pk, indexes, mapNameToIndex };\n    }\n\n    _processFields(table, columns) {\n        let features = [],\n            fields = {},\n            types = {};\n\n        columns.forEach((col) => {\n            let fieldName = this._fieldNaming(col.COLUMN_NAME);\n            if (col.EXTRA === \"auto_increment\") {\n                let featureInfo = {\n                    name: \"autoId\",\n                    options: table.AUTO_INCREMENT\n                        ? {\n                              startFrom: table.AUTO_INCREMENT,\n                          }\n                        : {},\n                };\n\n                if (fieldName !== \"id\") {\n                    featureInfo.options.name = fieldName;\n                }\n                features.push(featureInfo);\n                return;\n            }\n\n            if (col.COLUMN_DEFAULT === \"CURRENT_TIMESTAMP\") {\n                let featureInfo = {\n                    name: \"createTimestamp\",\n                };\n                features.push(featureInfo);\n                return;\n            }\n\n            if (col.EXTRA === \"on update CURRENT_TIMESTAMP\") {\n                let featureInfo = {\n                    name: \"updateTimestamp\",\n                };\n                features.push(featureInfo);\n                return;\n            }\n\n            if (fieldName === \"isDeleted\" && col.COLUMN_TYPE === \"tinyint(1)\") {\n                let featureInfo = {\n                    name: \"logicalDeletion\",\n                };\n                features.push(featureInfo);\n                return;\n            }\n\n            let fieldInfo = this._mysqlTypeToGemlType(table, col, fieldName, types);\n\n            if (col.IS_NULLABLE === \"YES\") {\n                fieldInfo.optional = true;\n            }\n\n            if (col.COLUMN_DEFAULT) {\n                fieldInfo.default = col.COLUMN_DEFAULT;\n            }\n\n            if (col.COLUMN_COMMENT) {\n                fieldInfo.comment = col.COLUMN_COMMENT;\n            }\n\n            fields[fieldName] = fieldInfo;\n        });\n\n        return { features, fields, types };\n    }\n\n    _fieldNaming(name) {\n        if (this.reverseRules.fieldNaming) {\n            return this.reverseRules.fieldNamin(name);\n        }\n\n        return GemlUtils.fieldNaming(name);\n    }\n\n    _entityNaming(name) {\n        if (this.reverseRules.entityNaming) {\n            return this.reverseRules.entityNaming(name);\n        }\n\n        return GemlUtils.entityNaming(name);\n    }\n\n    _schemaNaming(name) {\n        if (this.reverseRules.schemaNaming) {\n            return this.reverseRules.schemaNaming(name);\n        }\n\n        return GemlUtils.schemaNaming(name);\n    }\n\n    _mysqlTypeToGemlType(table, col, fieldName, types) {\n        let applicableRule = _.find(this.reverseRules.columnTypeConversion, (rule) => rule.test(table, col));\n        if (applicableRule) {\n            return applicableRule.apply(table, col);\n        }\n\n        let typeInfo = {};\n        if (col.COLUMN_NAME !== fieldName) {\n            typeInfo.code = col.COLUMN_NAME;\n        }\n\n        switch (col.DATA_TYPE) {\n            case \"varchar\":\n                typeInfo.type = \"text\";\n                if (col.CHARACTER_MAXIMUM_LENGTH) {\n                    typeInfo.maxLength = col.CHARACTER_MAXIMUM_LENGTH;\n                }\n                break;\n\n            case \"char\":\n                typeInfo.type = \"text\";\n                if (col.CHARACTER_MAXIMUM_LENGTH) {\n                    typeInfo.fixedLength = col.CHARACTER_MAXIMUM_LENGTH;\n                }\n                break;\n\n            case \"blob\":\n                typeInfo.type = \"binary\";\n                if (col.CHARACTER_MAXIMUM_LENGTH) {\n                    typeInfo.maxLength = col.CHARACTER_MAXIMUM_LENGTH;\n                }\n                break;\n\n            case \"bigint\":\n                typeInfo.type = \"integer\";\n                typeInfo.digits = col.NUMERIC_PRECISION || 18;\n                typeInfo.bytes = 8;\n                if (_.endsWith(col.COLUMN_TYPE, \" unsigned\")) typeInfo.unsigned = true;\n                break;\n\n            case \"int\":\n                typeInfo.type = \"integer\";\n                typeInfo.digits = col.NUMERIC_PRECISION || 10;\n                typeInfo.bytes = 4;\n                if (_.endsWith(col.COLUMN_TYPE, \" unsigned\")) typeInfo.unsigned = true;\n                break;\n\n            case \"mediumint\":\n                typeInfo.type = \"integer\";\n                typeInfo.digits = col.NUMERIC_PRECISION || 7;\n                typeInfo.bytes = 3;\n                if (_.endsWith(col.COLUMN_TYPE, \" unsigned\")) typeInfo.unsigned = true;\n                break;\n\n            case \"smallint\":\n                typeInfo.type = \"integer\";\n                typeInfo.digits = col.NUMERIC_PRECISION || 4;\n                typeInfo.bytes = 2;\n                if (_.endsWith(col.COLUMN_TYPE, \" unsigned\")) typeInfo.unsigned = true;\n                break;\n\n            case \"tinyint\":\n                if (_.startsWith(col.COLUMN_TYPE, \"tinyint(1)\")) {\n                    typeInfo.type = \"boolean\";\n                } else {\n                    typeInfo.type = \"integer\";\n                    typeInfo.digits = col.NUMERIC_PRECISION || 2;\n                    typeInfo.bytes = 1;\n                    if (_.endsWith(col.COLUMN_TYPE, \" unsigned\")) typeInfo.unsigned = true;\n                }\n                break;\n\n            case \"enum\":\n                let left = col.COLUMN_TYPE.indexOf(\"(\");\n                let right = col.COLUMN_TYPE.lastIndexOf(\")\");\n\n                let typeName = table.TABLE_NAME + _.upperFirst(col.COLUMN_NAME);\n\n                types[typeName] = {\n                    type: \"enum\",\n                    values: col.COLUMN_TYPE.substring(left + 1, right)\n                        .split(\",\")\n                        .map((v) => v.substr(1, v.length - 2)),\n                };\n\n                typeInfo.type = typeName;\n\n                break;\n\n            case \"text\":\n                typeInfo.type = \"text\";\n                typeInfo.maxLength = col.CHARACTER_MAXIMUM_LENGTH;\n                break;\n\n            case \"datetime\":\n            case \"timestamp\":\n                typeInfo.type = \"datetime\";\n                break;\n\n            case \"decimal\":\n                typeInfo.type = \"number\";\n                typeInfo.totalDigits = col.NUMERIC_PRECISION;\n                typeInfo.decimalDigits = col.NUMERIC_SCALE;\n                typeInfo.exact = true;\n                break;\n\n            case \"double\":\n                typeInfo.bytes = 8;\n            case \"float\":\n                typeInfo.type = \"number\";\n                typeInfo.totalDigits = col.NUMERIC_PRECISION;\n                typeInfo.decimalDigits = col.NUMERIC_SCALE;\n                break;\n\n            default:\n                console.log(col);\n                throw new Error(\"To be implemented.\");\n        }\n\n        //_.find(this.reverseRules.columnTypeOptimization, rule => rule.test(table, col));\n\n        return typeInfo;\n    }\n\n    _refineEntityRelationships(mapOfEntities) {\n        let entityAssoc = {};\n\n        //1st round\n        _.forOwn(mapOfEntities, ({ entityInfo }, name) => {\n            if (_.isEmpty(entityInfo.associations)) return;\n\n            entityInfo.associations.forEach(({ type, srcField, destEntity }) => {\n                let refedEntity = mapOfEntities[destEntity];\n                let backRef = _.find(refedEntity.associations, (assoc) => assoc.destEntity === name);\n\n                if (type === \"hasMany\") {\n                    if (!backRef) {\n                        //one-side relation\n                        pushIntoBucket(entityAssoc, name, { type: \"refersTo\", srcField, destEntity });\n                        return;\n                    }\n\n                    //todo:\n                    console.log(entityInfo);\n                    throw new Error(`Back reference: ${backRef.entity} ${backRef.type} ${name}`);\n                } else if (type === \"belongsTo\") {\n                    pushIntoBucket(entityAssoc, name, { type, srcField, destEntity });\n\n                    if (!backRef) {\n                        //one-side relation\n                        pushIntoBucket(entityAssoc, entity, { type: \"hasMany\", destEntity: name });\n                        return;\n                    }\n                } else {\n                    throw new Error(\"Unexpected association type: \" + type);\n                }\n            });\n        });\n\n        //2nd round\n        _.forOwn(entityAssoc, (associations, name) => {\n            let { entityInfo } = mapOfEntities[name];\n\n            let keyAssocs;\n\n            if (Array.isArray(entityInfo.key) && entityInfo.key.length === 2) {\n                keyAssocs = _.filter(associations, (assoc) => entityInfo.key.indexOf(assoc.srcField) !== -1);\n                if (keyAssocs.length === 2) {\n                    this._makeEntityManyToMany(keyAssocs[0].destEntity, keyAssocs[1].destEntity, entityAssoc);\n                }\n            }\n\n            entityInfo.indexes.forEach(({ fields }) => {\n                if (fields.length === 2) {\n                    keyAssocs = _.filter(associations, (assoc) => fields.indexOf(assoc.srcField) !== -1);\n                    if (keyAssocs.length === 2) {\n                        this._makeEntityManyToMany(keyAssocs[0].destEntity, keyAssocs[1].destEntity, entityAssoc);\n                    }\n                }\n            });\n        });\n\n        _.forOwn(mapOfEntities, ({ entityInfo }, name) => {\n            entityInfo.associations = entityAssoc[name];\n        });\n    }\n\n    _makeEntityManyToMany(entityName1, entityName2, entityAssoc) {\n        pushIntoBucket(entityAssoc, entityName1, { type: \"hasMany\", destEntity: entityName2 });\n        pushIntoBucket(entityAssoc, entityName2, { type: \"hasMany\", destEntity: entityName1 });\n    }\n}\n\nmodule.exports = MySQLReverseEngineering;\n"],"names":["path","require","_","eachAsync_","pushIntoBucket","fs","GemlCodeGen","GemlUtils","defaultRules","skip","MySQLReverseEngineering","reverse_","outputDir","logger","log","connector","driver","database","tables","execute_","saveIntermediate","writeFileSync","join","JSON","stringify","entities","mapOfEntities","entitiesGemlPath","ensureDirSync","skipTables","Set","reverseRules","table","has","TABLE_NAME","entityName","_entityNaming","push","entity","extractTable_","_refineEntityRelationships","forOwn","types","entityInfo","type","entityContent","transform","entityFile","schemaName","_schemaNaming","json","namespace","schema","schemaContent","schemaFile","targetGemlPath","columns","features","fields","_processFields","indexInfo","isEmpty","pk","indexes","mapNameToIndex","_processIndexes","length","Error","referencesInfo","associations","_processReferences_","comment","TABLE_COMMENT","key","code","l","i","ref","refTableKey","REFERENCED_TABLE_NAME","Column_name","toLowerCase","REFERENCED_COLUMN_NAME","COLUMN_NAME","unique","fkInfo","CONSTRAINT_NAME","Non_unique","fkColName","_fieldNaming","srcField","destEntity","forEach","Key_name","name","map","f","nullable","Null","col","fieldName","EXTRA","featureInfo","options","AUTO_INCREMENT","startFrom","COLUMN_DEFAULT","COLUMN_TYPE","fieldInfo","_mysqlTypeToGemlType","IS_NULLABLE","optional","default","COLUMN_COMMENT","fieldNaming","fieldNamin","entityNaming","schemaNaming","applicableRule","find","columnTypeConversion","rule","test","apply","typeInfo","DATA_TYPE","CHARACTER_MAXIMUM_LENGTH","maxLength","fixedLength","digits","NUMERIC_PRECISION","bytes","endsWith","unsigned","startsWith","left","indexOf","right","lastIndexOf","typeName","upperFirst","values","substring","split","v","substr","totalDigits","decimalDigits","NUMERIC_SCALE","exact","console","entityAssoc","refedEntity","backRef","assoc","keyAssocs","Array","isArray","filter","_makeEntityManyToMany","entityName1","entityName2","constructor","context","module","exports"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";AAAA,MAAMA,OAAOC,QAAQ;AACrB,MAAM,EAAEC,CAAC,EAAEC,UAAU,EAAEC,cAAc,EAAE,GAAGH,QAAQ;AAClD,MAAM,EAAEI,EAAE,EAAE,GAAGJ,QAAQ;AACvB,MAAMK,cAAcL,QAAQ;AAC5B,MAAMM,YAAYN,QAAQ;AAE1B,MAAMO,eAAe;IACjBC,MAAM;QAAC;KAAqB;AAChC;AAEA,MAAMC;IASF,MAAMC,SAASC,SAAS,EAAE;QACtB,IAAI,CAACC,MAAM,CAACC,GAAG,CACX,QACA,CAAC,oBAAoB,EAAE,IAAI,CAACC,SAAS,CAACC,MAAM,CAAC,WAAW,EAAE,IAAI,CAACD,SAAS,CAACE,QAAQ,CAAC,KAAK,CAAC;QAG5F,IAAIC,SAAS,MAAM,IAAI,CAACH,SAAS,CAACI,QAAQ,CAAC,kEAAkE;YACzG,IAAI,CAACJ,SAAS,CAACE,QAAQ;SAC1B;QAED,IAAI,IAAI,CAACG,gBAAgB,EAAE;YACvBf,GAAGgB,aAAa,CACZrB,KAAKsB,IAAI,CAACV,WAAW,IAAI,CAACG,SAAS,CAACE,QAAQ,GAAG,eAC/CM,KAAKC,SAAS,CAACN,QAAQ,MAAM;QAErC;QAEA,IAAIO,WAAW,EAAE,EACbC,gBAAgB,CAAC;QAErB,IAAIC,mBAAmB3B,KAAKsB,IAAI,CAACV,WAAW;QAC5CP,GAAGuB,aAAa,CAACD;QAEjB,MAAME,aAAa,IAAIC,IAAI,IAAI,CAACC,YAAY,CAACtB,IAAI,IAAI,EAAE;QAEvD,MAAMN,WAAWe,QAAQ,OAAOc;YAC5B,IAAIH,WAAWI,GAAG,CAACD,MAAME,UAAU,GAAG;YAEtC,IAAIC,aAAa,IAAI,CAACC,aAAa,CAACJ,MAAME,UAAU;YAEpDT,SAASY,IAAI,CAAC;gBAAEC,QAAQH;YAAW;YAEnCT,aAAa,CAACS,WAAW,GAAG,MAAM,IAAI,CAACI,aAAa,CAACJ,YAAYH,OAAOL;QAC5E;QAEA,IAAI,CAACa,0BAA0B,CAACd;QAEhCxB,EAAEuC,MAAM,CAACf,eAAe,CAAC,EAAEgB,KAAK,EAAEC,UAAU,EAAE,EAAER;YAC5C,IAAIG,UAAS;gBACTM,MAAMF;gBACNJ,QAAQ;oBACJ,CAACH,WAAW,EAAEQ;gBAClB;YACJ;YAEA,IAAIE,gBAAgBvC,YAAYwC,SAAS,CAACR;YAC1C,IAAIS,aAAa/C,KAAKsB,IAAI,CAACK,kBAAkBQ,aAAa;YAE1D,IAAI,IAAI,CAACf,gBAAgB,EAAE;gBACvBf,GAAGgB,aAAa,CAAC0B,aAAa,SAASxB,KAAKC,SAAS,CAACc,SAAQ,MAAM;YACxE;YACAjC,GAAGgB,aAAa,CAAC0B,YAAYF;YAC7B,IAAI,CAAChC,MAAM,CAACC,GAAG,CAAC,QAAQ,CAAC,kCAAkC,EAAEiC,WAAW,EAAE,CAAC;QAC/E;QAEA,IAAIC,aAAa,IAAI,CAACC,aAAa,CAAC,IAAI,CAAClC,SAAS,CAACE,QAAQ;QAE3D,IAAIiC,OAAO;YACPC,WAAW;gBAAC;aAAc;YAC1BC,QAAQ;gBACJ,CAACJ,WAAW,EAAE;oBACVvB,UAAUA;gBACd;YACJ;QACJ;QAEA,IAAI4B,gBAAgB/C,YAAYwC,SAAS,CAACI;QAC1C,IAAII,aAAatD,KAAKsB,IAAI,CAACV,WAAWoC,aAAa;QACnD,IAAI,IAAI,CAAC5B,gBAAgB,EAAE;YACvBf,GAAGgB,aAAa,CAACiC,aAAa,SAAS/B,KAAKC,SAAS,CAAC0B,MAAM,MAAM;QACtE;QACA7C,GAAGgB,aAAa,CAACiC,YAAYD;QAC7B,IAAI,CAACxC,MAAM,CAACC,GAAG,CAAC,QAAQ,CAAC,6BAA6B,EAAEwC,WAAW,EAAE,CAAC;IAC1E;IAEA,MAAMf,cAAcJ,UAAU,EAAEH,KAAK,EAAEuB,cAAc,EAAE;QACnD,IAAIC,UAAU,MAAM,IAAI,CAACzC,SAAS,CAACI,QAAQ,CACvC,sFACA;YAAC,IAAI,CAACJ,SAAS,CAACE,QAAQ;YAAEe,MAAME,UAAU;SAAC;QAG/C,IAAI,IAAI,CAACd,gBAAgB,EAAE;YACvBf,GAAGgB,aAAa,CACZrB,KAAKsB,IAAI,CAACiC,gBAAgBvB,MAAME,UAAU,GAAG,eAC7CX,KAAKC,SAAS,CAACgC,SAAS,MAAM;QAEtC;QAEA,IAAI,EAAEC,QAAQ,EAAEC,MAAM,EAAEhB,KAAK,EAAE,GAAG,IAAI,CAACiB,cAAc,CAAC3B,OAAOwB;QAE7D,IAAII,YAAY,MAAM,IAAI,CAAC7C,SAAS,CAACI,QAAQ,CAAC,wBAAwB;YAACa,MAAME,UAAU;SAAC;QAExF,IAAI,IAAI,CAACd,gBAAgB,IAAI,CAAClB,EAAE2D,OAAO,CAACD,YAAY;YAChDvD,GAAGgB,aAAa,CACZrB,KAAKsB,IAAI,CAACiC,gBAAgBvB,MAAME,UAAU,GAAG,gBAC7CX,KAAKC,SAAS,CAACoC,WAAW,MAAM;QAExC;QAEA,IAAI,EAAEE,EAAE,EAAEC,OAAO,EAAEC,cAAc,EAAE,GAAG,IAAI,CAACC,eAAe,CAACL;QAE3D,IAAIE,GAAGI,MAAM,KAAK,GAAG;YACjB,MAAM,IAAIC,MAAM,CAAC,OAAO,EAAEnC,MAAME,UAAU,CAAC,qBAAqB,CAAC;QACrE;QAEA,IAAIkC,iBAAiB,MAAM,IAAI,CAACrD,SAAS,CAACI,QAAQ,CAC9C,sJACA;YAAC,IAAI,CAACJ,SAAS,CAACE,QAAQ;YAAEe,MAAME,UAAU;SAAC;QAG/C,IAAI,IAAI,CAACd,gBAAgB,IAAI,CAAClB,EAAE2D,OAAO,CAACO,iBAAiB;YACrD/D,GAAGgB,aAAa,CACZrB,KAAKsB,IAAI,CAACiC,gBAAgBvB,MAAME,UAAU,GAAG,cAC7CX,KAAKC,SAAS,CAAC4C,gBAAgB,MAAM;QAE7C;QAEA,IAAIC,eAAe,MAAM,IAAI,CAACC,mBAAmB,CAACF,gBAAgBJ,gBAAgBN;QAElF,IAAIf,aAAa;YACb4B,SAASvC,MAAMwC,aAAa;YAC5Bf;YACAC;YACAW;YACAI,KAAKX,GAAGI,MAAM,GAAG,IAAIJ,KAAKA,EAAE,CAAC,EAAE;YAC/BC;QACJ;QAEA,IAAI5B,eAAeH,MAAME,UAAU,EAAE;YACjCS,WAAW+B,IAAI,GAAG1C,MAAME,UAAU;QACtC;QAEA,OAAO;YAAEQ;YAAOC;QAAW;IAC/B;IAEA,MAAM2B,oBAAoBF,cAAc,EAAEJ,cAAc,EAAEN,MAAM,EAAE;QAC9D,IAAIW,eAAe,EAAE;QAErB,IAAIM,IAAIP,eAAeF,MAAM;QAE7B,IAAK,IAAIU,IAAI,GAAGA,IAAID,GAAGC,IAAK;YACxB,IAAIC,MAAMT,cAAc,CAACQ,EAAE;YAE3B,IAAI,CAACE,YAAY,GAAG,MAAM,IAAI,CAAC/D,SAAS,CAACI,QAAQ,CAAC,qDAAqD;gBACnG0D,IAAIE,qBAAqB;aAC5B;YAED,IAAID,YAAYE,WAAW,CAACC,WAAW,OAAOJ,IAAIK,sBAAsB,CAACD,WAAW,IAAI;gBACpF,MAAM,IAAId,MAAM,CAAC,aAAa,EAAEU,IAAIM,WAAW,CAAC,mCAAmC,CAAC;YACxF;YAEA,IAAIC,SAAS;YAEb,IAAIC,SAASrB,cAAc,CAACa,IAAIS,eAAe,CAAC;YAChD,IAAID,QAAQ;gBACR,IAAIA,OAAOnB,MAAM,GAAG,GAAG;oBACnB,MAAM,IAAIC,MAAM,CAAC,2CAA2C,EAAEU,IAAIS,eAAe,CAAC,CAAC,CAAC;gBACxF;gBAEAF,SAASC,MAAM,CAAC,EAAE,CAACE,UAAU,KAAK;YACtC;YAEA,IAAIC,YAAY,IAAI,CAACC,YAAY,CAACZ,IAAIM,WAAW;YAEjD,IAAIC,QAAQ;gBACRf,aAAahC,IAAI,CAAC;oBACdO,MAAM;oBACN8C,UAAUF;oBACVG,YAAY,IAAI,CAACvD,aAAa,CAACyC,IAAIE,qBAAqB;gBAC5D;YACJ,OAAO;gBACHV,aAAahC,IAAI,CAAC;oBACdO,MAAM;oBACN8C,UAAUF;oBACVG,YAAY,IAAI,CAACvD,aAAa,CAACyC,IAAIE,qBAAqB;gBAC5D;YACJ;YAEA,OAAOrB,MAAM,CAAC8B,UAAU,EAAE,4DAA4D;QAC1F;QAEA,OAAOnB;IACX;IAEAJ,gBAAgBL,SAAS,EAAE;QACvB,IAAIE,KAAK,EAAE,EACPC,UAAU,EAAE;QAEhB,IAAIC,iBAAiB,CAAC;QAEtBJ,UAAUgC,OAAO,CAAC,CAAChB;YACfxE,eAAe4D,gBAAgBY,EAAEiB,QAAQ,EAAEjB;QAC/C;QAEA1E,EAAEuC,MAAM,CAACuB,gBAAgB,CAACN,QAAQoC;YAC9B,IAAIA,SAAS,WAAW;gBACpBhC,GAAGzB,IAAI,CAACqB,OAAOqC,GAAG,CAAC,CAACC,IAAM,IAAI,CAACP,YAAY,CAACO,EAAEhB,WAAW;YAC7D,OAAO;gBACHjB,QAAQ1B,IAAI,CAAC;oBACTyD,MAAMA;oBACNpC,QAAQA,OAAOqC,GAAG,CAAC,CAACC,IAAM,IAAI,CAACP,YAAY,CAACO,EAAEhB,WAAW;oBACzDI,QAAQ1B,MAAM,CAAC,EAAE,CAAC6B,UAAU,KAAK;oBACjCU,UAAUvC,MAAM,CAAC,EAAE,CAACwC,IAAI,KAAK;gBACjC;YACJ;QACJ;QAEA,OAAO;YAAEpC;YAAIC;YAASC;QAAe;IACzC;IAEAL,eAAe3B,KAAK,EAAEwB,OAAO,EAAE;QAC3B,IAAIC,WAAW,EAAE,EACbC,SAAS,CAAC,GACVhB,QAAQ,CAAC;QAEbc,QAAQoC,OAAO,CAAC,CAACO;YACb,IAAIC,YAAY,IAAI,CAACX,YAAY,CAACU,IAAIhB,WAAW;YACjD,IAAIgB,IAAIE,KAAK,KAAK,kBAAkB;gBAChC,IAAIC,cAAc;oBACdR,MAAM;oBACNS,SAASvE,MAAMwE,cAAc,GACvB;wBACIC,WAAWzE,MAAMwE,cAAc;oBACnC,IACA,CAAC;gBACX;gBAEA,IAAIJ,cAAc,MAAM;oBACpBE,YAAYC,OAAO,CAACT,IAAI,GAAGM;gBAC/B;gBACA3C,SAASpB,IAAI,CAACiE;gBACd;YACJ;YAEA,IAAIH,IAAIO,cAAc,KAAK,qBAAqB;gBAC5C,IAAIJ,cAAc;oBACdR,MAAM;gBACV;gBACArC,SAASpB,IAAI,CAACiE;gBACd;YACJ;YAEA,IAAIH,IAAIE,KAAK,KAAK,+BAA+B;gBAC7C,IAAIC,cAAc;oBACdR,MAAM;gBACV;gBACArC,SAASpB,IAAI,CAACiE;gBACd;YACJ;YAEA,IAAIF,cAAc,eAAeD,IAAIQ,WAAW,KAAK,cAAc;gBAC/D,IAAIL,cAAc;oBACdR,MAAM;gBACV;gBACArC,SAASpB,IAAI,CAACiE;gBACd;YACJ;YAEA,IAAIM,YAAY,IAAI,CAACC,oBAAoB,CAAC7E,OAAOmE,KAAKC,WAAW1D;YAEjE,IAAIyD,IAAIW,WAAW,KAAK,OAAO;gBAC3BF,UAAUG,QAAQ,GAAG;YACzB;YAEA,IAAIZ,IAAIO,cAAc,EAAE;gBACpBE,UAAUI,OAAO,GAAGb,IAAIO,cAAc;YAC1C;YAEA,IAAIP,IAAIc,cAAc,EAAE;gBACpBL,UAAUrC,OAAO,GAAG4B,IAAIc,cAAc;YAC1C;YAEAvD,MAAM,CAAC0C,UAAU,GAAGQ;QACxB;QAEA,OAAO;YAAEnD;YAAUC;YAAQhB;QAAM;IACrC;IAEA+C,aAAaK,IAAI,EAAE;QACf,IAAI,IAAI,CAAC/D,YAAY,CAACmF,WAAW,EAAE;YAC/B,OAAO,IAAI,CAACnF,YAAY,CAACoF,UAAU,CAACrB;QACxC;QAEA,OAAOvF,UAAU2G,WAAW,CAACpB;IACjC;IAEA1D,cAAc0D,IAAI,EAAE;QAChB,IAAI,IAAI,CAAC/D,YAAY,CAACqF,YAAY,EAAE;YAChC,OAAO,IAAI,CAACrF,YAAY,CAACqF,YAAY,CAACtB;QAC1C;QAEA,OAAOvF,UAAU6G,YAAY,CAACtB;IAClC;IAEA7C,cAAc6C,IAAI,EAAE;QAChB,IAAI,IAAI,CAAC/D,YAAY,CAACsF,YAAY,EAAE;YAChC,OAAO,IAAI,CAACtF,YAAY,CAACsF,YAAY,CAACvB;QAC1C;QAEA,OAAOvF,UAAU8G,YAAY,CAACvB;IAClC;IAEAe,qBAAqB7E,KAAK,EAAEmE,GAAG,EAAEC,SAAS,EAAE1D,KAAK,EAAE;QAC/C,IAAI4E,iBAAiBpH,EAAEqH,IAAI,CAAC,IAAI,CAACxF,YAAY,CAACyF,oBAAoB,EAAE,CAACC,OAASA,KAAKC,IAAI,CAAC1F,OAAOmE;QAC/F,IAAImB,gBAAgB;YAChB,OAAOA,eAAeK,KAAK,CAAC3F,OAAOmE;QACvC;QAEA,IAAIyB,WAAW,CAAC;QAChB,IAAIzB,IAAIhB,WAAW,KAAKiB,WAAW;YAC/BwB,SAASlD,IAAI,GAAGyB,IAAIhB,WAAW;QACnC;QAEA,OAAQgB,IAAI0B,SAAS;YACjB,KAAK;gBACDD,SAAShF,IAAI,GAAG;gBAChB,IAAIuD,IAAI2B,wBAAwB,EAAE;oBAC9BF,SAASG,SAAS,GAAG5B,IAAI2B,wBAAwB;gBACrD;gBACA;YAEJ,KAAK;gBACDF,SAAShF,IAAI,GAAG;gBAChB,IAAIuD,IAAI2B,wBAAwB,EAAE;oBAC9BF,SAASI,WAAW,GAAG7B,IAAI2B,wBAAwB;gBACvD;gBACA;YAEJ,KAAK;gBACDF,SAAShF,IAAI,GAAG;gBAChB,IAAIuD,IAAI2B,wBAAwB,EAAE;oBAC9BF,SAASG,SAAS,GAAG5B,IAAI2B,wBAAwB;gBACrD;gBACA;YAEJ,KAAK;gBACDF,SAAShF,IAAI,GAAG;gBAChBgF,SAASK,MAAM,GAAG9B,IAAI+B,iBAAiB,IAAI;gBAC3CN,SAASO,KAAK,GAAG;gBACjB,IAAIjI,EAAEkI,QAAQ,CAACjC,IAAIQ,WAAW,EAAE,cAAciB,SAASS,QAAQ,GAAG;gBAClE;YAEJ,KAAK;gBACDT,SAAShF,IAAI,GAAG;gBAChBgF,SAASK,MAAM,GAAG9B,IAAI+B,iBAAiB,IAAI;gBAC3CN,SAASO,KAAK,GAAG;gBACjB,IAAIjI,EAAEkI,QAAQ,CAACjC,IAAIQ,WAAW,EAAE,cAAciB,SAASS,QAAQ,GAAG;gBAClE;YAEJ,KAAK;gBACDT,SAAShF,IAAI,GAAG;gBAChBgF,SAASK,MAAM,GAAG9B,IAAI+B,iBAAiB,IAAI;gBAC3CN,SAASO,KAAK,GAAG;gBACjB,IAAIjI,EAAEkI,QAAQ,CAACjC,IAAIQ,WAAW,EAAE,cAAciB,SAASS,QAAQ,GAAG;gBAClE;YAEJ,KAAK;gBACDT,SAAShF,IAAI,GAAG;gBAChBgF,SAASK,MAAM,GAAG9B,IAAI+B,iBAAiB,IAAI;gBAC3CN,SAASO,KAAK,GAAG;gBACjB,IAAIjI,EAAEkI,QAAQ,CAACjC,IAAIQ,WAAW,EAAE,cAAciB,SAASS,QAAQ,GAAG;gBAClE;YAEJ,KAAK;gBACD,IAAInI,EAAEoI,UAAU,CAACnC,IAAIQ,WAAW,EAAE,eAAe;oBAC7CiB,SAAShF,IAAI,GAAG;gBACpB,OAAO;oBACHgF,SAAShF,IAAI,GAAG;oBAChBgF,SAASK,MAAM,GAAG9B,IAAI+B,iBAAiB,IAAI;oBAC3CN,SAASO,KAAK,GAAG;oBACjB,IAAIjI,EAAEkI,QAAQ,CAACjC,IAAIQ,WAAW,EAAE,cAAciB,SAASS,QAAQ,GAAG;gBACtE;gBACA;YAEJ,KAAK;gBACD,IAAIE,OAAOpC,IAAIQ,WAAW,CAAC6B,OAAO,CAAC;gBACnC,IAAIC,QAAQtC,IAAIQ,WAAW,CAAC+B,WAAW,CAAC;gBAExC,IAAIC,WAAW3G,MAAME,UAAU,GAAGhC,EAAE0I,UAAU,CAACzC,IAAIhB,WAAW;gBAE9DzC,KAAK,CAACiG,SAAS,GAAG;oBACd/F,MAAM;oBACNiG,QAAQ1C,IAAIQ,WAAW,CAACmC,SAAS,CAACP,OAAO,GAAGE,OACvCM,KAAK,CAAC,KACNhD,GAAG,CAAC,CAACiD,IAAMA,EAAEC,MAAM,CAAC,GAAGD,EAAE9E,MAAM,GAAG;gBAC3C;gBAEA0D,SAAShF,IAAI,GAAG+F;gBAEhB;YAEJ,KAAK;gBACDf,SAAShF,IAAI,GAAG;gBAChBgF,SAASG,SAAS,GAAG5B,IAAI2B,wBAAwB;gBACjD;YAEJ,KAAK;YACL,KAAK;gBACDF,SAAShF,IAAI,GAAG;gBAChB;YAEJ,KAAK;gBACDgF,SAAShF,IAAI,GAAG;gBAChBgF,SAASsB,WAAW,GAAG/C,IAAI+B,iBAAiB;gBAC5CN,SAASuB,aAAa,GAAGhD,IAAIiD,aAAa;gBAC1CxB,SAASyB,KAAK,GAAG;gBACjB;YAEJ,KAAK;gBACDzB,SAASO,KAAK,GAAG;YACrB,KAAK;gBACDP,SAAShF,IAAI,GAAG;gBAChBgF,SAASsB,WAAW,GAAG/C,IAAI+B,iBAAiB;gBAC5CN,SAASuB,aAAa,GAAGhD,IAAIiD,aAAa;gBAC1C;YAEJ;gBACIE,QAAQxI,GAAG,CAACqF;gBACZ,MAAM,IAAIhC,MAAM;QACxB;QAEA,kFAAkF;QAElF,OAAOyD;IACX;IAEApF,2BAA2Bd,aAAa,EAAE;QACtC,IAAI6H,cAAc,CAAC;QAEnB,WAAW;QACXrJ,EAAEuC,MAAM,CAACf,eAAe,CAAC,EAAEiB,UAAU,EAAE,EAAEmD;YACrC,IAAI5F,EAAE2D,OAAO,CAAClB,WAAW0B,YAAY,GAAG;YAExC1B,WAAW0B,YAAY,CAACuB,OAAO,CAAC,CAAC,EAAEhD,IAAI,EAAE8C,QAAQ,EAAEC,UAAU,EAAE;gBAC3D,IAAI6D,cAAc9H,aAAa,CAACiE,WAAW;gBAC3C,IAAI8D,UAAUvJ,EAAEqH,IAAI,CAACiC,YAAYnF,YAAY,EAAE,CAACqF,QAAUA,MAAM/D,UAAU,KAAKG;gBAE/E,IAAIlD,SAAS,WAAW;oBACpB,IAAI,CAAC6G,SAAS;wBACV,mBAAmB;wBACnBrJ,eAAemJ,aAAazD,MAAM;4BAAElD,MAAM;4BAAY8C;4BAAUC;wBAAW;wBAC3E;oBACJ;oBAEA,OAAO;oBACP2D,QAAQxI,GAAG,CAAC6B;oBACZ,MAAM,IAAIwB,MAAM,CAAC,gBAAgB,EAAEsF,QAAQnH,MAAM,CAAC,CAAC,EAAEmH,QAAQ7G,IAAI,CAAC,CAAC,EAAEkD,KAAK,CAAC;gBAC/E,OAAO,IAAIlD,SAAS,aAAa;oBAC7BxC,eAAemJ,aAAazD,MAAM;wBAAElD;wBAAM8C;wBAAUC;oBAAW;oBAE/D,IAAI,CAAC8D,SAAS;wBACV,mBAAmB;wBACnBrJ,eAAemJ,aAAajH,QAAQ;4BAAEM,MAAM;4BAAW+C,YAAYG;wBAAK;wBACxE;oBACJ;gBACJ,OAAO;oBACH,MAAM,IAAI3B,MAAM,kCAAkCvB;gBACtD;YACJ;QACJ;QAEA,WAAW;QACX1C,EAAEuC,MAAM,CAAC8G,aAAa,CAAClF,cAAcyB;YACjC,IAAI,EAAEnD,UAAU,EAAE,GAAGjB,aAAa,CAACoE,KAAK;YAExC,IAAI6D;YAEJ,IAAIC,MAAMC,OAAO,CAAClH,WAAW8B,GAAG,KAAK9B,WAAW8B,GAAG,CAACP,MAAM,KAAK,GAAG;gBAC9DyF,YAAYzJ,EAAE4J,MAAM,CAACzF,cAAc,CAACqF,QAAU/G,WAAW8B,GAAG,CAAC+D,OAAO,CAACkB,MAAMhE,QAAQ,MAAM,CAAC;gBAC1F,IAAIiE,UAAUzF,MAAM,KAAK,GAAG;oBACxB,IAAI,CAAC6F,qBAAqB,CAACJ,SAAS,CAAC,EAAE,CAAChE,UAAU,EAAEgE,SAAS,CAAC,EAAE,CAAChE,UAAU,EAAE4D;gBACjF;YACJ;YAEA5G,WAAWoB,OAAO,CAAC6B,OAAO,CAAC,CAAC,EAAElC,MAAM,EAAE;gBAClC,IAAIA,OAAOQ,MAAM,KAAK,GAAG;oBACrByF,YAAYzJ,EAAE4J,MAAM,CAACzF,cAAc,CAACqF,QAAUhG,OAAO8E,OAAO,CAACkB,MAAMhE,QAAQ,MAAM,CAAC;oBAClF,IAAIiE,UAAUzF,MAAM,KAAK,GAAG;wBACxB,IAAI,CAAC6F,qBAAqB,CAACJ,SAAS,CAAC,EAAE,CAAChE,UAAU,EAAEgE,SAAS,CAAC,EAAE,CAAChE,UAAU,EAAE4D;oBACjF;gBACJ;YACJ;QACJ;QAEArJ,EAAEuC,MAAM,CAACf,eAAe,CAAC,EAAEiB,UAAU,EAAE,EAAEmD;YACrCnD,WAAW0B,YAAY,GAAGkF,WAAW,CAACzD,KAAK;QAC/C;IACJ;IAEAiE,sBAAsBC,WAAW,EAAEC,WAAW,EAAEV,WAAW,EAAE;QACzDnJ,eAAemJ,aAAaS,aAAa;YAAEpH,MAAM;YAAW+C,YAAYsE;QAAY;QACpF7J,eAAemJ,aAAaU,aAAa;YAAErH,MAAM;YAAW+C,YAAYqE;QAAY;IACxF;IApfAE,YAAYC,OAAO,EAAEtJ,MAAM,EAAEE,SAAS,CAAE;QACpC,IAAI,CAACF,MAAM,GAAGA;QACd,IAAI,CAACE,SAAS,GAAGA;QAEjB,IAAI,CAACgB,YAAY,GAAG;YAAE,GAAGvB,YAAY;YAAE,GAAG,IAAI,CAACO,SAAS,CAACwF,OAAO,CAACxE,YAAY;QAAC;QAC9E,IAAI,CAACX,gBAAgB,GAAG+I,QAAQ/I,gBAAgB,IAAI;IACxD;AA+eJ;AAEAgJ,OAAOC,OAAO,GAAG3J"}