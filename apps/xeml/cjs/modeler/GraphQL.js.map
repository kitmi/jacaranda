{"version":3,"sources":["../../src/modeler/GraphQL.js"],"sourcesContent":["\"use strict\";\n\nconst path = require('path');\nconst { _, naming }  = require('@genx/july');\nconst { fs } = require('@genx/sys');\n\nconst { toGraphQLType } = require('./graphql/lang');\n\n/**\n * GraphQL schemas modeler.\n * @class\n */\nclass GraphQLModeler {\n    /**     \n     * @param {object} context   \n     * @property {GemlLinker} context.linker - Geml linker\n     * @property {object} context.modelPath - Generated model output path\n     * @property {object} context.manifestPath - Entities manifest output path\n     * @param {Connector} connector      \n     */\n    constructor(context, linker, connector) {       \n        this.linker = linker;\n        this.outputPath = context.modelPath;\n        this.manifestPath = context.manifestPath;\n\n        this.connector = connector;        \n    }\n\n    modeling_(schema) {\n        this.linker.log('info', 'Generating graphql models for schema \"' + schema.name + '\"...');\n\n        //this._generateSchemaModel(schema);        \n        this._generateGraphQLModel(schema);\n    }\n\n    /*\n    _generateSchemaModel(schema) {\n        let capitalized = pascalCase(schema.name);\n\n        let locals = {\n            driver: this.connector.driver,\n            className: capitalized,\n            schemaName: schema.name,\n            entities: JSON.stringify(Object.keys(schema.entities))\n        };\n\n        let classTemplate = path.resolve(__dirname, 'database', this.connector.driver, 'Database.js.swig');\n        let classCode = swig.renderFile(classTemplate, locals);\n\n        let modelFilePath = path.resolve(this.outputPath, capitalized + '.js');\n        fs.ensureFileSync(modelFilePath);\n        fs.writeFileSync(modelFilePath, classCode);\n\n        this.linker.log('info', 'Generated database model: ' + modelFilePath);\n    }*/\n\n    _generateEnumTypes(schema) {\n        _.forOwn(schema.entities, (entity, entityInstanceName) => {\n            _.forOwn(entity.fields, (field, fieldName) => {\n                if (field.type === 'enum') {\n\n                }\n            });\n        });\n    }\n\n    _generateGraphQLModel(schema) {\n        const generated = new Set();\n\n        const typeDefs = [];\n\n        _.forOwn(schema.entities, (entity, entityInstanceName) => {            \n            let capitalized = naming.pascalCase(entityInstanceName);                  \n\n            let fields = _.map(entity.fields, (field, fieldName) => {  \n                if (fieldName === entity.key) {\n                    return `${fieldName}: ID!`;\n                }\n\n                const typeInfo = toGraphQLType(field);    \n                \n                if (typeInfo.newType) {\n                    if (!generated.has(typeInfo.newType)) {\n                        generated.add(typeInfo.newType);\n\n                        switch (typeInfo.typeName) {\n                            case 'scalar':\n                                typeDefs.push(`scalar ${typeInfo.newType}`);\n                                break;\n\n                            case 'enum':\n                                typeDefs.push(`enum ${typeInfo.newType} {\n    ${typeInfo.values.map(v => _.snakeCase(v).toUpperCase()).join('\\n    ')}\n}`);\n                                break;\n\n                            default:\n                                throw new Error(`Unsupported graphql type: ${typeInfo.newType}`);\n                        }\n                    } \n                }\n                \n                return `${fieldName}: ${typeInfo.type}`;\n            });\n\n            if (_.isEmpty(!entity.associations)) {\n                _.each(entity.associations, (assoc, anchor) => {\n                    const typeName = naming.pascalCase(assoc.entity);\n\n                    if (assoc.list) {\n                        fields.push(`${anchor}_: [${typeName}!]`);\n                    } else {\n                        fields.push(`${anchor}_: ${typeName}`);\n                    }\n                });\n            }\n\n            let classCode = `type ${capitalized} {\n    ${fields.join('\\n    ')}\n}`;                         \n\n            typeDefs.push(classCode);            \n        });\n\n        let modelFilePath = path.resolve(this.manifestPath, 'graphql', schema.name + '.graphql');\n        fs.ensureFileSync(modelFilePath);\n        fs.writeFileSync(modelFilePath, typeDefs.join('\\n\\n'));\n\n        this.linker.log('info', 'Generated graphql model: ' + modelFilePath);\n    }\n\n    _generateEntityManifest(schema) {\n        let entities = Object.keys(schema.entities).sort().reduce((result, v) => { result[v] = {}; return result; }, {});\n        /*\n        let manifest = {};\n\n        _.each(schema.entities, (entity, entityName) => {\n            if (entity.info.restful) {\n                _.each(entity.info.restful, ({ type, methods }, relativeUri) => {                    \n                    let apiInfo = {\n                        type,\n                        methods: {}                                            \n                    };\n\n                    if (type === 'entity') {\n                        apiInfo.entity = entityName;\n                        apiInfo.displayName = entity.displayName;\n\n                        if (entity.comment) {\n                            apiInfo.description = entity.comment;\n                        }\n                    }\n\n                    _.each(methods, (meta, methodName) => {\n\n                        switch (methodName) {\n                            case 'create':\n                                apiInfo.methods['post:' + relativeUri] = meta;\n                            break;\n\n                            case 'findOne':\n                            break;\n\n                            case 'fineAll':\n                            break;\n\n                            case 'updateOne':\n                            break;\n\n                            case 'updateMany':\n                            break;\n\n                            case 'deleteOne':\n                            break;\n\n                            case 'deleteMany':\n                            break;\n                        }\n\n                    });\n                });\n            }\n        });\n        */\n        let outputFilePath = path.resolve(this.manifestPath, schema.name + '.manifest.json');\n        fs.ensureFileSync(outputFilePath);\n        fs.writeFileSync(outputFilePath, JSON.stringify(entities, null, 4));\n\n        this.linker.log('info', 'Generated schema manifest: ' + outputFilePath);\n    }\n\n    /*\n    _generateViewModel(schema, dbService) {        \n        _.forOwn(schema.views, (viewInfo, viewName) => {\n            this.linker.info('Building view: ' + viewName);\n\n            let capitalized = _.upperFirst(viewName);\n\n            let ast = JsLang.astProgram();\n\n            JsLang.astPushInBody(ast, JsLang.astRequire('Mowa', 'mowa'));\n            JsLang.astPushInBody(ast, JsLang.astVarDeclare('Util', JsLang.astVarRef('Mowa.Util'), true));\n            JsLang.astPushInBody(ast, JsLang.astVarDeclare('_', JsLang.astVarRef('Util._'), true));\n            JsLang.astPushInBody(ast, JsLang.astRequire('View', 'mowa/lib/oolong/runtime/view'));\n\n            let compileContext = OolToAst.createCompileContext(viewName, dbService.serviceId, this.linker);\n\n            compileContext.modelVars.add(viewInfo.entity);\n\n            let paramMeta;\n\n            if (viewInfo.params) {\n                paramMeta = this._processParams(viewInfo.params, compileContext);\n            }\n\n            let viewMeta = {\n                isList: viewInfo.isList,\n                params: paramMeta\n            };\n\n            let viewBodyTopoId = OolToAst.createTopoId(compileContext, '$view');\n            OolToAst.dependsOn(compileContext, compileContext.mainStartId, viewBodyTopoId);\n\n            let viewModeler = require(path.resolve(__dirname, './dao/view', dbService.dbType + '.js'));\n            compileContext.astMap[viewBodyTopoId] = viewModeler(dbService, viewName, viewInfo);\n            OolToAst.addCodeBlock(compileContext, viewBodyTopoId, {\n                type: OolToAst.AST_BLK_VIEW_OPERATION\n            });\n\n            let returnTopoId = OolToAst.createTopoId(compileContext, '$return:value');\n            OolToAst.dependsOn(compileContext, viewBodyTopoId, returnTopoId);\n            OolToAst.compileReturn(returnTopoId, {\n                \"oolType\": \"ObjectReference\",\n                \"name\": \"viewData\"\n            }, compileContext);\n\n            let deps = compileContext.topoSort.sort();\n            this.linker.verbose('All dependencies:\\n' + JSON.stringify(deps, null, 2));\n\n            deps = deps.filter(dep => compileContext.mapOfTokenToMeta.has(dep));\n            this.linker.verbose('All necessary source code:\\n' + JSON.stringify(deps, null, 2));\n\n            let astDoLoadMain = [\n                JsLang.astVarDeclare('$meta', JsLang.astVarRef('this.meta'), true, false, 'Retrieving the meta data')\n            ];\n\n            _.each(deps, dep => {\n                let astMeta = compileContext.mapOfTokenToMeta.get(dep);\n\n                let astBlock = compileContext.astMap[dep];\n                assert: astBlock, 'Empty ast block';\n\n                if (astMeta.type === 'ModifierCall') {\n                    let fieldName = getFieldName(astMeta.target);\n                    let astCache = JsLang.astAssign(JsLang.astVarRef(astMeta.target), astBlock, `Modifying ${fieldName}`);\n                    astDoLoadMain.push(astCache);\n                    return;\n                }\n\n                astDoLoadMain = astDoLoadMain.concat(_.castArray(compileContext.astMap[dep]));\n            });\n\n            if (!_.isEmpty(compileContext.mapOfFunctorToFile)) {\n                _.forOwn(compileContext.mapOfFunctorToFile, (fileName, functionName) => {\n                    JsLang.astPushInBody(ast, JsLang.astRequire(functionName, '.' + fileName));\n                });\n            }\n\n            if (!_.isEmpty(compileContext.newFunctorFiles)) {\n                _.each(compileContext.newFunctorFiles, entry => {\n                    this._generateFunctionTemplateFile(dbService, entry);\n                });\n            }\n\n            JsLang.astPushInBody(ast, JsLang.astClassDeclare(capitalized, 'View', [\n                JsLang.astMemberMethod('_doLoad', Object.keys(paramMeta),\n                    astDoLoadMain,\n                    false, true, false, 'Populate view data'\n                )\n            ], `${capitalized} view`));\n            JsLang.astPushInBody(ast, JsLang.astAssign(capitalized + '.meta', JsLang.astValue(viewMeta)));\n            JsLang.astPushInBody(ast, JsLang.astAssign('module.exports', JsLang.astVarRef(capitalized)));\n\n            let modelFilePath = path.resolve(this.outputPath, dbService.dbType, dbService.name, 'views', viewName + '.js');\n            fs.ensureFileSync(modelFilePath);\n            fs.writeFileSync(modelFilePath + '.json', JSON.stringify(ast, null, 2));\n\n            DaoModeler._exportSourceCode(ast, modelFilePath);\n\n            this.linker.log('info', 'Generated view model: ' + modelFilePath);\n        });\n    };\n    */\n}\n\nmodule.exports = GraphQLModeler;"],"names":["path","require","_","naming","fs","toGraphQLType","GraphQLModeler","modeling_","schema","linker","log","name","_generateGraphQLModel","_generateEnumTypes","forOwn","entities","entity","entityInstanceName","fields","field","fieldName","type","generated","Set","typeDefs","capitalized","pascalCase","map","key","typeInfo","newType","has","add","typeName","push","values","v","snakeCase","toUpperCase","join","Error","isEmpty","associations","each","assoc","anchor","list","classCode","modelFilePath","resolve","manifestPath","ensureFileSync","writeFileSync","_generateEntityManifest","Object","keys","sort","reduce","result","outputFilePath","JSON","stringify","constructor","context","connector","outputPath","modelPath","module","exports"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}