{"version":3,"sources":["../../src/modeler/Dao.js"],"sourcesContent":["const path = require(\"path\");\nconst { _, naming, text, pushIntoBucket } = require(\"@genx/july\");\nconst { fs } = require(\"@genx/sys\");\nconst swig = require(\"swig-templates\");\n\nconst GemlTypes = require(\"../lang/GemlTypes\");\nconst JsLang = require(\"./util/ast.js\");\nconst GemlToAst = require(\"./util/gemlToAst.js\");\nconst Snippets = require(\"./dao/snippets\");\nconst { Types } = require(\"@genx/data\");\n\nconst ChainableType = [\n    GemlToAst.AST_BLK_VALIDATOR_CALL,\n    GemlToAst.AST_BLK_PROCESSOR_CALL,\n    GemlToAst.AST_BLK_ACTIVATOR_CALL,\n];\n\nconst getFieldName = (t) => t.split(\".\").pop();\nconst isChainable = (current, next) =>\n    ChainableType.indexOf(current.type) > -1 && current.target === next.target && next.type === current.type;\nconst chainCall = (lastBlock, lastType, currentBlock, currentType) => {\n    if (lastBlock) {\n        if (lastType === \"ValidatorCall\") {\n            assert: currentType === \"ValidatorCall\", \"Unexpected currentType\";\n\n            currentBlock = JsLang.astBinExp(lastBlock, \"&&\", currentBlock);\n        } else {\n            assert: currentType === \"ProcessorCall\", \"Unexpected currentType: \" + currentType + \" last: \" + lastType;\n\n            currentBlock.arguments[0] = lastBlock;\n        }\n    }\n\n    return currentBlock;\n};\nconst asyncMethodNaming = (name) => name + \"_\";\n\nconst indentLines = (lines, indentation) =>\n    lines\n        .split(\"\\n\")\n        .map((line, i) => (i === 0 ? line : _.repeat(\" \", indentation) + line))\n        .join(\"\\n\");\n\nconst OOL_MODIFIER_RETURN = {\n    [GemlTypes.Modifier.VALIDATOR]: () => [JsLang.astThrow('Error', ['To be implemented!']), JsLang.astReturn(true)],\n    [GemlTypes.Modifier.PROCESSOR]: (args) => [JsLang.astThrow('Error', ['To be implemented!']), JsLang.astReturn(JsLang.astId(args[0]))],\n    [GemlTypes.Modifier.ACTIVATOR]: () => [JsLang.astThrow('Error', ['To be implemented!']), JsLang.astReturn(JsLang.astId(\"undefined\"))],\n};\n\n/**\n * Geml database access object (DAO) modeler.\n * @class\n */\nclass DaoModeler {\n    /**\n     * @param {object} context\n     * @property {GemlLinker} context.linker - Geml linker\n     * @property {object} context.modelPath - Generated model output path\n     * @property {object} context.manifestPath - Entities manifest output path\n     * @param {Connector} connector\n     */\n    constructor(context, linker, connector) {\n        this.linker = linker;\n        this.outputPath = context.modelPath;\n        this.manifestPath = context.manifestPath;\n\n        this.connector = connector;\n    }\n\n    modeling_(schema) {\n        this.linker.log(\"info\", 'Generating entity models for schema \"' + schema.name + '\"...');\n\n        this._generateSchemaModel(schema);\n        this._generateEntityModel(schema);\n        this._generateEnumTypes(schema);\n        this._generateEntityInputSchema(schema);\n        //\n        //this._generateViewModel();\n\n        if (this.manifestPath) {\n            this._generateEntityManifest(schema);\n        }\n    }\n\n    _generateSchemaModel(schema) {\n        let capitalized = naming.pascalCase(schema.name);\n\n        let locals = {\n            driver: this.connector.driver,\n            className: capitalized,\n            schemaName: schema.name,\n            entities: JSON.stringify(Object.keys(schema.entities)),\n        };\n\n        let classTemplate = path.resolve(__dirname, \"database\", this.connector.driver, \"Database.js.swig\");\n        let classCode = swig.renderFile(classTemplate, locals);\n\n        let modelFilePath = path.resolve(this.outputPath, capitalized + \".js\");\n        fs.ensureFileSync(modelFilePath);\n        fs.writeFileSync(modelFilePath, classCode);\n\n        this.linker.log(\"info\", \"Generated database model: \" + modelFilePath);\n    }\n\n    _generateEnumTypes(schema) {\n        //build types defined outside of entity\n        _.forOwn(schema.types, (location, type) => {\n            const typeInfo = schema.linker.getTypeInfo(type, location);\n            if (typeInfo.type === Types.ENUM.name) {\n                const capitalized = naming.pascalCase(type);\n\n                const content = `module.exports = {\n    ${typeInfo.values\n        .map((val) => `${naming.snakeCase(val).toUpperCase()}: '${val}'`)\n        .join(\",\\n    \")}                    \n};`;\n\n                const modelFilePath = path.resolve(this.outputPath, schema.name, \"types\", capitalized + \".js\");\n                fs.ensureFileSync(modelFilePath);\n                fs.writeFileSync(modelFilePath, content);\n\n                this.linker.log(\"info\", \"Generated enum type definition: \" + modelFilePath);\n            }\n        });\n    }\n\n    _generateEntityModel(schema) {\n        _.forOwn(schema.entities, (entity, entityInstanceName) => {\n            let capitalized = naming.pascalCase(entityInstanceName);\n\n            //shared information with model CRUD and customized interfaces\n            let sharedContext = {\n                mapOfFunctorToFile: {},\n                newFunctorFiles: [],\n            };\n\n            let { ast: astClassMain, fieldReferences } = this._processFieldModifiers(entity, sharedContext);\n            astClassMain = [astClassMain];\n\n            //prepare meta data\n            let uniqueKeys = [_.castArray(entity.key)];\n\n            if (entity.indexes) {\n                entity.indexes.forEach((index) => {\n                    if (index.unique) {\n                        uniqueKeys.push(index.fields);\n                    }\n                });\n            }\n\n            let modelMeta = {\n                schemaName: schema.name,\n                name: entityInstanceName,\n                keyField: entity.key,\n                fields: _.mapValues(entity.fields, (f) => _.omit(f.toJSON(), \"modifiers\")),\n                features: entity.features || {},\n                uniqueKeys,\n            };\n\n            if (entity.baseClasses) {\n                modelMeta.baseClasses = entity.baseClasses;\n            }\n\n            if (!_.isEmpty(entity.indexes)) {\n                modelMeta.indexes = entity.indexes;\n            }\n\n            if (!_.isEmpty(entity.features)) {\n                modelMeta.features = entity.features;\n            }\n\n            if (!_.isEmpty(entity.associations)) {\n                modelMeta.associations = entity.associations;\n            }\n\n            if (!_.isEmpty(fieldReferences)) {\n                modelMeta.fieldDependencies = fieldReferences;\n            }\n\n            //build customized interfaces\n            if (entity.interfaces) {\n                let astInterfaces = this._buildInterfaces(entity, modelMeta, sharedContext);\n                //console.log(astInterfaces);\n                //let astClass = astClassMain[astClassMain.length - 1];\n                //JsLang.astPushInBody(astClass, astInterfaces);\n                astClassMain = astClassMain.concat(astInterfaces);\n            }\n\n            let importLines = [];\n\n            //generate functors if any\n            if (!_.isEmpty(sharedContext.mapOfFunctorToFile)) {\n                _.forOwn(sharedContext.mapOfFunctorToFile, (fileName, functionName) => {\n                    importLines.push(JsLang.astToCode(JsLang.astRequire(functionName, \".\" + fileName)));\n                });\n            }\n\n            if (!_.isEmpty(sharedContext.newFunctorFiles)) {\n                _.each(sharedContext.newFunctorFiles, (entry) => {\n                    this._generateFunctionTemplateFile(schema, entry);\n                });\n            }\n\n            //add package path\n            const packageName = entity.gemlModule.packageName;\n            if (packageName) {                \n                modelMeta.fromPackage = packageName;                \n                modelMeta.packagePath = this.linker.app.settings.geml.dependencies[packageName]; //path.relative(this.linker.dependencies[packageName], this.linker.app.workingPath);\n            }\n\n            let locals = {\n                imports: importLines.join(\"\\n\"),\n                className: capitalized,\n                entityMeta: indentLines(JSON.stringify(modelMeta, null, 4), 4),\n                classBody: indentLines(astClassMain.map((block) => JsLang.astToCode(block)).join(\"\\n\\n\"), 8),\n                functors: indentLines(\n                    JsLang.astToCode(\n                        JsLang.astValue(\n                            _.reduce(\n                                sharedContext.newFunctorFiles,\n                                (result, functor) => {\n                                    result[\"$\" + functor.functionName] = JsLang.astId(functor.functionName);\n                                    return result;\n                                },\n                                {}\n                            )\n                        )\n                    ),\n                    4\n                ),\n                //mixins\n            };\n\n            let classTemplate = path.resolve(__dirname, \"database\", this.connector.driver, \"EntityModel.js.swig\");\n            let classCode = swig.renderFile(classTemplate, locals);\n\n            let modelFilePath = path.resolve(this.outputPath, schema.name, \"base\", capitalized + \".js\");\n            fs.ensureFileSync(modelFilePath);\n            fs.writeFileSync(modelFilePath, classCode);\n\n            this.linker.log(\"info\", \"Generated entity model: \" + modelFilePath);\n        });\n    }\n\n    _generateEntityInputSchema(schema) {\n        //generate validator config\n        _.forOwn(schema.entities, (entity, entityInstanceName) => {\n            _.each(entity.inputs, (inputs, inputSetName) => {\n                const validationSchema = {};\n                const dependencies = new Set();\n                const ast = JsLang.astProgram();\n\n                inputs.forEach((input) => {\n                    //:address\n                    if (input.name.startsWith(\":\")) {\n                        const assoc = input.name.substr(1);\n                        const assocMeta = entity.associations[assoc];\n\n                        if (!assocMeta) {\n                            throw new Error(`Association \"${assoc}\" not found in entity [${entityInstanceName}].`);\n                        }\n\n                        if (!input.spec) {\n                            throw new Error(\n                                `Input \"spec\" is required for entity reference. Input set: ${inputSetName}, entity: ${entityInstanceName}, local: ${assoc}, referencedEntity: ${assocMeta.entity}`\n                            );\n                        }\n\n                        const dep = `${assocMeta.entity}-${input.spec}`;\n                        dependencies.add(dep);\n\n                        if (assocMeta.list) {\n                            validationSchema[input.name] = JsLang.astValue({\n                                type: \"array\",\n                                elementSchema: {\n                                    type: \"object\",\n                                    schema: JsLang.astCall(_.camelCase(dep), []),\n                                },\n                                ..._.pick(input, [\"optional\"]),\n                            });\n                        } else {\n                            validationSchema[input.name] = JsLang.astValue({\n                                type: \"object\",\n                                schema: JsLang.astCall(_.camelCase(dep), []),\n                                ..._.pick(input, [\"optional\"]),\n                            });\n                        }\n                    } else {\n                        const field = entity.fields[input.name];\n\n                        if (!field) {\n                            throw new Error(`Field \"${input.name}\" not found in entity [${entityInstanceName}].`);\n                        }\n\n                        validationSchema[input.name] = JsLang.astValue({\n                            ..._.pick(field, [\"type\", \"values\"]),\n                            ..._.pick(input, [\"optional\"]),\n                        });\n                    }\n                });\n\n                //console.dir(JsLang.astValue(validationSchema), {depth: 20});\n\n                const exportBody = Array.from(dependencies).map((dep) =>\n                    JsLang.astRequire(_.camelCase(dep), `./${dep}`)\n                );\n\n                JsLang.astPushInBody(\n                    ast,\n                    JsLang.astAssign(\n                        JsLang.astVarRef(\"module.exports\"),\n                        JsLang.astAnonymousFunction([], exportBody.concat(JsLang.astReturn(validationSchema)))\n                    )\n                );\n\n                let inputSchemaFilePath = path.resolve(\n                    this.outputPath,\n                    schema.name,\n                    \"inputs\",\n                    entityInstanceName + \"-\" + inputSetName + \".js\"\n                );\n                fs.ensureFileSync(inputSchemaFilePath);\n                fs.writeFileSync(inputSchemaFilePath, JsLang.astToCode(ast));\n\n                this.linker.log(\"info\", \"Generated entity input schema: \" + inputSchemaFilePath);\n            });\n        });\n    }\n\n    _generateEntityManifest(schema) {\n        /*\n        let manifest = {};\n\n        _.each(schema.entities, (entity, entityName) => {\n            if (entity.info.restful) {\n                _.each(entity.info.restful, ({ type, methods }, relativeUri) => {                    \n                    let apiInfo = {\n                        type,\n                        methods: {}                                            \n                    };\n\n                    if (type === 'entity') {\n                        apiInfo.entity = entityName;\n                        apiInfo.displayName = entity.displayName;\n\n                        if (entity.comment) {\n                            apiInfo.description = entity.comment;\n                        }\n                    }\n\n                    _.each(methods, (meta, methodName) => {\n\n                        switch (methodName) {\n                            case 'create':\n                                apiInfo.methods['post:' + relativeUri] = meta;\n                            break;\n\n                            case 'findOne':\n                            break;\n\n                            case 'fineAll':\n                            break;\n\n                            case 'updateOne':\n                            break;\n\n                            case 'updateMany':\n                            break;\n\n                            case 'deleteOne':\n                            break;\n\n                            case 'deleteMany':\n                            break;\n                        }\n\n                    });\n                });\n            }\n        });\n        */\n\n        /*\n        let outputFilePath = path.resolve(this.manifestPath, schema.name + '.manifest.json');\n        fs.ensureFileSync(outputFilePath);\n        fs.writeFileSync(outputFilePath, JSON.stringify(entities, null, 4));\n\n        this.linker.log('info', 'Generated schema manifest: ' + outputFilePath);\n        */\n\n        const diagram = {};\n\n        //generate validator config\n        _.forOwn(schema.entities, (entity, entityInstanceName) => {\n            /*\n            let validationSchema = {};\n\n            _.forOwn(entity.fields, (field, fieldName) => {\n                if (field.readOnly) return;\n\n                let fieldSchema = {\n                    type: field.type,\n                };\n\n                if (field.type === \"enum\") {\n                    fieldSchema.values = field.values;\n                }\n\n                if (field.optional) {\n                    fieldSchema.optional = true;\n                }\n\n                validationSchema[fieldName] = fieldSchema;\n            });\n            */\n\n            diagram[entityInstanceName] = entity.toJSON();\n\n            /*\n            let entityOutputFilePath = path.resolve(\n                this.manifestPath,\n                schema.name,\n                \"validation\",\n                entityInstanceName + \".manifest.json\"\n            );\n            fs.ensureFileSync(entityOutputFilePath);\n            fs.writeFileSync(entityOutputFilePath, JSON.stringify(validationSchema, null, 4));\n\n            this.linker.log(\"info\", \"Generated entity manifest: \" + entityOutputFilePath);\n            */\n        });\n\n        let diagramOutputFilePath = path.resolve(this.manifestPath, schema.name, \"diagram.json\");\n        fs.ensureFileSync(diagramOutputFilePath);\n        fs.writeFileSync(diagramOutputFilePath, JSON.stringify(diagram, null, 4));\n\n        this.linker.log(\"info\", \"Generated schema manifest: \" + diagramOutputFilePath);\n    }\n\n    /*\n    _generateViewModel(schema, dbService) {        \n        _.forOwn(schema.views, (viewInfo, viewName) => {\n            this.linker.info('Building view: ' + viewName);\n\n            let capitalized = _.upperFirst(viewName);\n\n            let ast = JsLang.astProgram();\n\n            JsLang.astPushInBody(ast, JsLang.astRequire('Mowa', 'mowa'));\n            JsLang.astPushInBody(ast, JsLang.astVarDeclare('Util', JsLang.astVarRef('Mowa.Util'), true));\n            JsLang.astPushInBody(ast, JsLang.astVarDeclare('_', JsLang.astVarRef('Util._'), true));\n            JsLang.astPushInBody(ast, JsLang.astRequire('View', 'mowa/lib/oolong/runtime/view'));\n\n            let compileContext = OolToAst.createCompileContext(viewName, dbService.serviceId, this.linker);\n\n            compileContext.modelVars.add(viewInfo.entity);\n\n            let paramMeta;\n\n            if (viewInfo.params) {\n                paramMeta = this._processParams(viewInfo.params, compileContext);\n            }\n\n            let viewMeta = {\n                isList: viewInfo.isList,\n                params: paramMeta\n            };\n\n            let viewBodyTopoId = OolToAst.createTopoId(compileContext, '$view');\n            OolToAst.dependsOn(compileContext, compileContext.mainStartId, viewBodyTopoId);\n\n            let viewModeler = require(path.resolve(__dirname, './dao/view', dbService.dbType + '.js'));\n            compileContext.astMap[viewBodyTopoId] = viewModeler(dbService, viewName, viewInfo);\n            OolToAst.addCodeBlock(compileContext, viewBodyTopoId, {\n                type: OolToAst.AST_BLK_VIEW_OPERATION\n            });\n\n            let returnTopoId = OolToAst.createTopoId(compileContext, '$return:value');\n            OolToAst.dependsOn(compileContext, viewBodyTopoId, returnTopoId);\n            OolToAst.compileReturn(returnTopoId, {\n                \"oolType\": \"ObjectReference\",\n                \"name\": \"viewData\"\n            }, compileContext);\n\n            let deps = compileContext.topoSort.sort();\n            this.linker.verbose('All dependencies:\\n' + JSON.stringify(deps, null, 2));\n\n            deps = deps.filter(dep => compileContext.mapOfTokenToMeta.has(dep));\n            this.linker.verbose('All necessary source code:\\n' + JSON.stringify(deps, null, 2));\n\n            let astDoLoadMain = [\n                JsLang.astVarDeclare('$meta', JsLang.astVarRef('this.meta'), true, false, 'Retrieving the meta data')\n            ];\n\n            _.each(deps, dep => {\n                let astMeta = compileContext.mapOfTokenToMeta.get(dep);\n\n                let astBlock = compileContext.astMap[dep];\n                assert: astBlock, 'Empty ast block';\n\n                if (astMeta.type === 'ModifierCall') {\n                    let fieldName = getFieldName(astMeta.target);\n                    let astCache = JsLang.astAssign(JsLang.astVarRef(astMeta.target), astBlock, `Modifying ${fieldName}`);\n                    astDoLoadMain.push(astCache);\n                    return;\n                }\n\n                astDoLoadMain = astDoLoadMain.concat(_.castArray(compileContext.astMap[dep]));\n            });\n\n            if (!_.isEmpty(compileContext.mapOfFunctorToFile)) {\n                _.forOwn(compileContext.mapOfFunctorToFile, (fileName, functionName) => {\n                    JsLang.astPushInBody(ast, JsLang.astRequire(functionName, '.' + fileName));\n                });\n            }\n\n            if (!_.isEmpty(compileContext.newFunctorFiles)) {\n                _.each(compileContext.newFunctorFiles, entry => {\n                    this._generateFunctionTemplateFile(dbService, entry);\n                });\n            }\n\n            JsLang.astPushInBody(ast, JsLang.astClassDeclare(capitalized, 'View', [\n                JsLang.astMemberMethod('_doLoad', Object.keys(paramMeta),\n                    astDoLoadMain,\n                    false, true, false, 'Populate view data'\n                )\n            ], `${capitalized} view`));\n            JsLang.astPushInBody(ast, JsLang.astAssign(capitalized + '.meta', JsLang.astValue(viewMeta)));\n            JsLang.astPushInBody(ast, JsLang.astAssign('module.exports', JsLang.astVarRef(capitalized)));\n\n            let modelFilePath = path.resolve(this.outputPath, dbService.dbType, dbService.name, 'views', viewName + '.js');\n            fs.ensureFileSync(modelFilePath);\n            fs.writeFileSync(modelFilePath + '.json', JSON.stringify(ast, null, 2));\n\n            DaoModeler._exportSourceCode(ast, modelFilePath);\n\n            this.linker.log('info', 'Generated view model: ' + modelFilePath);\n        });\n    };\n    */\n\n    _processFieldModifiers(entity, sharedContext) {\n        let compileContext = GemlToAst.createCompileContext(entity.gemlModule.name, this.linker, sharedContext);\n        compileContext.variables[\"raw\"] = { source: \"context\", finalized: true };\n        compileContext.variables[\"i18n\"] = { source: \"context\", finalized: true };\n        compileContext.variables[\"connector\"] = { source: \"context\", finalized: true };\n        compileContext.variables[\"latest\"] = { source: \"context\" };\n\n        const allFinished = GemlToAst.createTopoId(compileContext, \"done.\");\n\n        //map of field name to dependencies\n        let fieldReferences = {};\n\n        _.forOwn(entity.fields, (field, fieldName) => {\n            let topoId = GemlToAst.compileField(fieldName, field, compileContext);\n            GemlToAst.dependsOn(compileContext, topoId, allFinished);\n\n            if (field.writeOnce || field.freezeAfterNonDefault) {\n                pushIntoBucket(fieldReferences, fieldName, { reference: fieldName, writeProtect: true });\n            }\n        });\n\n        let deps = compileContext.topoSort.sort();\n        //this.linker.verbose('All dependencies:\\n' + JSON.stringify(deps, null, 2));\n\n        deps = deps.filter((dep) => compileContext.mapOfTokenToMeta.has(dep));\n        //this.linker.verbose('All necessary source code:\\n' + JSON.stringify(deps, null, 2));\n\n        let methodBodyValidateAndFill = [],\n            lastFieldsGroup,\n            methodBodyCache = [],\n            lastBlock,\n            lastAstType; //, hasValidator = false;\n\n        const _mergeDoValidateAndFillCode = function (fieldName, references, astCache, requireTargetField) {\n            let fields = [fieldName].concat(references);\n            let checker = fields.join(\",\");\n\n            if (lastFieldsGroup && lastFieldsGroup.checker !== checker) {\n                methodBodyValidateAndFill = methodBodyValidateAndFill.concat(\n                    Snippets._fieldRequirementCheck(\n                        lastFieldsGroup.fieldName,\n                        lastFieldsGroup.references,\n                        methodBodyCache,\n                        lastFieldsGroup.requireTargetField\n                    )\n                );\n                methodBodyCache = [];\n            }\n\n            methodBodyCache = methodBodyCache.concat(astCache);\n            lastFieldsGroup = {\n                fieldName,\n                references,\n                requireTargetField,\n                checker,\n            };\n        };\n\n        //console.dir(compileContext.astMap['mobile~isMobilePhone:arg[1]|>stringDasherize'], { depth: 8 });\n\n        _.each(deps, (dep, i) => {\n            //get metadata of source code block\n            let sourceMap = compileContext.mapOfTokenToMeta.get(dep);\n\n            //get source code block\n            let astBlock = compileContext.astMap[dep];\n\n            let targetFieldName = getFieldName(sourceMap.target);\n\n            if (sourceMap.references && sourceMap.references.length > 0) {\n                let fieldReference = fieldReferences[targetFieldName];\n                if (!fieldReference) {\n                    fieldReferences[targetFieldName] = fieldReference = [];\n                }\n\n                if (sourceMap.type === GemlToAst.AST_BLK_ACTIVATOR_CALL) {\n                    sourceMap.references.forEach((ref) => {\n                        fieldReference.push({ reference: ref, whenNull: true });\n                    });\n                } else {\n                    sourceMap.references.forEach((ref) => {\n                        if (fieldReference.indexOf(ref) === -1) fieldReference.push(ref);\n                    });\n                }\n            }\n\n            if (lastBlock) {\n                astBlock = chainCall(lastBlock, lastAstType, astBlock, sourceMap.type);\n                lastBlock = undefined;\n            }\n\n            if (i < deps.length - 1) {\n                let nextType = compileContext.mapOfTokenToMeta.get(deps[i + 1]);\n\n                if (isChainable(sourceMap, nextType)) {\n                    lastBlock = astBlock;\n                    lastAstType = sourceMap.type;\n                    return;\n                }\n            }\n\n            if (sourceMap.type === GemlToAst.AST_BLK_VALIDATOR_CALL) {\n                //hasValidator = true;\n                let astCache = Snippets._validateCheck(targetFieldName, astBlock);\n\n                _mergeDoValidateAndFillCode(targetFieldName, sourceMap.references, astCache, true);\n            } else if (sourceMap.type === GemlToAst.AST_BLK_PROCESSOR_CALL) {\n                let astCache = JsLang.astAssign(\n                    JsLang.astVarRef(sourceMap.target, true),\n                    astBlock,\n                    `Processing \"${targetFieldName}\"`\n                );\n\n                _mergeDoValidateAndFillCode(targetFieldName, sourceMap.references, astCache, true);\n            } else if (sourceMap.type === GemlToAst.AST_BLK_ACTIVATOR_CALL) {\n                let astCache = Snippets._checkAndAssign(\n                    astBlock,\n                    JsLang.astVarRef(sourceMap.target, true),\n                    `Activating \"${targetFieldName}\"`\n                );\n\n                _mergeDoValidateAndFillCode(targetFieldName, sourceMap.references, astCache, false);\n            } else {\n                throw new Error(\"To be implemented.\");\n                //astBlock = _.castArray(astBlock);\n                //_mergeDoValidateAndFillCode(targetFieldName, [], astBlock);\n            }\n        });\n\n        /* Changed to throw error instead of returning a error object\n        if (hasValidator) {\n            let declare = JsLang.astVarDeclare(validStateName, false);\n            methodBodyCreate.unshift(declare);\n            methodBodyUpdate.unshift(declare);\n        }\n        */\n\n        if (!_.isEmpty(methodBodyCache)) {\n            methodBodyValidateAndFill = methodBodyValidateAndFill.concat(\n                Snippets._fieldRequirementCheck(\n                    lastFieldsGroup.fieldName,\n                    lastFieldsGroup.references,\n                    methodBodyCache,\n                    lastFieldsGroup.requireTargetField\n                )\n            );\n        }\n\n        /*\n        let ast = JsLang.astProgram(false);\n        JsLang.astPushInBody(ast, JsLang.astClassDeclare('Abc', 'Model', [\n            JsLang.astMemberMethod(asyncMethodNaming('prepareEntityData_'), [ 'context' ],\n            Snippets._doValidateAndFillHeader.concat(methodBodyValidateAndFill).concat([ JsLang.astReturn(JsLang.astId('context')) ]),\n            false, true, true\n        )], 'comment'));\n        */\n\n        return {\n            ast: JsLang.astMemberMethod(\n                asyncMethodNaming(\"applyModifiers\"),\n                [\"context\", \"isUpdating\"],\n                Snippets._applyModifiersHeader\n                    .concat(methodBodyValidateAndFill)\n                    .concat([JsLang.astReturn(JsLang.astId(\"context\"))]),\n                false,\n                true,\n                true,\n                \"Applying predefined modifiers to entity fields.\"\n            ),\n            fieldReferences,\n        };\n    }\n\n    _generateFunctionTemplateFile(schema, { functionName, functorType, fileName, args }) {\n        let filePath = path.resolve(this.outputPath, schema.name, fileName);\n\n        if (fs.existsSync(filePath)) {\n            //todo: analyse code, compare arguments\n            this.linker.log(\"info\", `${_.upperFirst(functorType)} \"${fileName}\" exists. File generating skipped.`);\n\n            return;\n        }\n\n        let ast = JsLang.astProgram();\n\n        JsLang.astPushInBody(ast, JsLang.astFunction(functionName, args, OOL_MODIFIER_RETURN[functorType](args)));\n        JsLang.astPushInBody(ast, JsLang.astAssign(\"module.exports\", JsLang.astVarRef(functionName)));\n\n        fs.ensureFileSync(filePath);\n        fs.writeFileSync(filePath, JsLang.astToCode(ast));\n        this.linker.log(\"info\", `Generated ${functorType} file: ${filePath}`);\n    }\n\n    _buildInterfaces(entity, modelMetaInit, sharedContext) {\n        let ast = [];\n\n        _.forOwn(entity.interfaces, (method, name) => {\n            this.linker.info(\"Building interface: \" + name);\n\n            let astBody = [\n                JsLang.astVarDeclare(\n                    \"$meta\",\n                    JsLang.astVarRef(\"this.meta.interfaces.\" + name),\n                    true,\n                    false,\n                    \"Retrieving the meta data\"\n                ),\n            ];\n\n            let compileContext = GemlToAst.createCompileContext(entity.gemlModule.name, this.linker, sharedContext);\n\n            let paramMeta;\n\n            if (method.accept) {\n                paramMeta = this._processParams(method.accept, compileContext);\n            }\n\n            //metadata\n            modelMetaInit[\"interfaces\"] || (modelMetaInit[\"interfaces\"] = {});\n            modelMetaInit[\"interfaces\"][name] = { params: Object.values(paramMeta) };\n\n            _.each(method.implementation, (operation, index) => {\n                //let lastTopoId =\n                GemlToAst.compileDbOperation(index, operation, compileContext, compileContext.mainStartId);\n            });\n\n            if (method.return) {\n                GemlToAst.compileExceptionalReturn(method.return, compileContext);\n            }\n\n            let deps = compileContext.topoSort.sort();\n            //this.linker.verbose('All dependencies:\\n' + JSON.stringify(deps, null, 2));\n\n            deps = deps.filter((dep) => compileContext.mapOfTokenToMeta.has(dep));\n            //this.linker.verbose('All necessary source code:\\n' + JSON.stringify(deps, null, 2));\n\n            _.each(deps, (dep) => {\n                let sourceMap = compileContext.mapOfTokenToMeta.get(dep);\n                let astBlock = compileContext.astMap[dep];\n\n                //this.linker.verbose('Code point \"' + dep + '\":\\n' + JSON.stringify(sourceMap, null, 2));\n\n                let targetFieldName = sourceMap.target; //getFieldName(sourceMap.target);\n\n                if (sourceMap.type === GemlToAst.AST_BLK_VALIDATOR_CALL) {\n                    astBlock = Snippets._validateCheck(targetFieldName, astBlock);\n                } else if (sourceMap.type === GemlToAst.AST_BLK_PROCESSOR_CALL) {\n                    if (sourceMap.needDeclare) {\n                        astBlock = JsLang.astVarDeclare(\n                            JsLang.astVarRef(sourceMap.target),\n                            astBlock,\n                            false,\n                            false,\n                            `Processing \"${targetFieldName}\"`\n                        );\n                    } else {\n                        astBlock = JsLang.astAssign(\n                            JsLang.astVarRef(sourceMap.target, true),\n                            astBlock,\n                            `Processing \"${targetFieldName}\"`\n                        );\n                    }\n                } else if (sourceMap.type === GemlToAst.AST_BLK_ACTIVATOR_CALL) {\n                    if (sourceMap.needDeclare) {\n                        astBlock = JsLang.astVarDeclare(\n                            JsLang.astVarRef(sourceMap.target),\n                            astBlock,\n                            false,\n                            false,\n                            `Processing \"${targetFieldName}\"`\n                        );\n                    } else {\n                        astBlock = JsLang.astAssign(\n                            JsLang.astVarRef(sourceMap.target, true),\n                            astBlock,\n                            `Activating \"${targetFieldName}\"`\n                        );\n                    }\n                }\n\n                astBody = astBody.concat(_.castArray(astBlock));\n            });\n\n            ast.push(\n                JsLang.astMemberMethod(\n                    asyncMethodNaming(name),\n                    Object.keys(paramMeta),\n                    astBody,\n                    false,\n                    true,\n                    true,\n                    text.replaceAll(_.kebabCase(name), \"-\", \" \")\n                )\n            );\n        });\n\n        return ast;\n    }\n\n    _processParams(acceptParams, compileContext) {\n        let paramMeta = {};\n\n        acceptParams.forEach((param, i) => {\n            GemlToAst.compileParam(i, param, compileContext);\n            paramMeta[param.name] = param;\n            compileContext.variables[param.name] = { source: \"argument\" };\n        });\n\n        return paramMeta;\n    }\n}\n\nmodule.exports = DaoModeler;\n"],"names":["path","require","_","naming","text","pushIntoBucket","fs","swig","GemlTypes","JsLang","GemlToAst","Snippets","Types","ChainableType","AST_BLK_VALIDATOR_CALL","AST_BLK_PROCESSOR_CALL","AST_BLK_ACTIVATOR_CALL","getFieldName","t","split","pop","isChainable","current","next","indexOf","type","target","chainCall","lastBlock","lastType","currentBlock","currentType","assert","astBinExp","arguments","asyncMethodNaming","name","indentLines","lines","indentation","map","line","i","repeat","join","OOL_MODIFIER_RETURN","Modifier","VALIDATOR","astThrow","astReturn","PROCESSOR","args","astId","ACTIVATOR","DaoModeler","modeling_","schema","linker","log","_generateSchemaModel","_generateEntityModel","_generateEnumTypes","_generateEntityInputSchema","manifestPath","_generateEntityManifest","capitalized","pascalCase","locals","driver","connector","className","schemaName","entities","JSON","stringify","Object","keys","classTemplate","resolve","__dirname","classCode","renderFile","modelFilePath","outputPath","ensureFileSync","writeFileSync","forOwn","types","location","typeInfo","getTypeInfo","ENUM","content","values","val","snakeCase","toUpperCase","entity","entityInstanceName","sharedContext","mapOfFunctorToFile","newFunctorFiles","ast","astClassMain","fieldReferences","_processFieldModifiers","uniqueKeys","castArray","key","indexes","forEach","index","unique","push","fields","modelMeta","keyField","mapValues","f","omit","toJSON","features","baseClasses","isEmpty","associations","fieldDependencies","interfaces","astInterfaces","_buildInterfaces","concat","importLines","fileName","functionName","astToCode","astRequire","each","entry","_generateFunctionTemplateFile","packageName","gemlModule","fromPackage","packagePath","app","settings","geml","dependencies","imports","entityMeta","classBody","block","functors","astValue","reduce","result","functor","inputs","inputSetName","validationSchema","Set","astProgram","input","startsWith","assoc","substr","assocMeta","Error","spec","dep","add","list","elementSchema","astCall","camelCase","pick","field","exportBody","Array","from","astPushInBody","astAssign","astVarRef","astAnonymousFunction","inputSchemaFilePath","diagram","diagramOutputFilePath","compileContext","createCompileContext","variables","source","finalized","allFinished","createTopoId","fieldName","topoId","compileField","dependsOn","writeOnce","freezeAfterNonDefault","reference","writeProtect","deps","topoSort","sort","filter","mapOfTokenToMeta","has","methodBodyValidateAndFill","lastFieldsGroup","methodBodyCache","lastAstType","_mergeDoValidateAndFillCode","references","astCache","requireTargetField","checker","_fieldRequirementCheck","sourceMap","get","astBlock","astMap","targetFieldName","length","fieldReference","ref","whenNull","undefined","nextType","_validateCheck","_checkAndAssign","astMemberMethod","_applyModifiersHeader","functorType","filePath","existsSync","upperFirst","astFunction","modelMetaInit","method","info","astBody","astVarDeclare","paramMeta","accept","_processParams","params","implementation","operation","compileDbOperation","mainStartId","return","compileExceptionalReturn","needDeclare","replaceAll","kebabCase","acceptParams","param","compileParam","constructor","context","modelPath","module","exports"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}