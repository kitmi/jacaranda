{"version":3,"sources":["../../../src/modeler/util/ast.js"],"sourcesContent":["\"use strict\";\n\n/**\n * @module\n * @ignore\n */\n\nconst { _ } = require('@genx/july');\nconst escodegen = require('escodegen');\nconst esprima = require('esprima');\n\nconst AST_OBJECT_TYPES = [\n    'ThisExpression',\n    'MemberExpression',\n    'BinaryExpression',\n    'UnaryExpression',\n    'ArrowFunctionExpression',\n    'FunctionExpression',\n    'ArrayExpression',\n    'ObjectExpression',\n    'CallExpression',\n    'YieldExpression',\n    'AwaitExpression',\n    'AssignmentExpression',\n    'Literal',\n    'Identifier'\n];\n\nfunction astParams(params) {\n    params = Array.isArray(params) ? params : [ params ];\n\n    return params.map(p => {\n         if (typeof p === 'string') {\n             return astId(p);\n         }\n\n        if (_.isPlainObject(p)) {\n            if (p.type === 'Identifier' || p.type === 'AssignmentPattern') {\n                return p;\n            }\n\n            if (p.oolType === 'Parameter') {\n                if (p.defaultValue) {\n                    return {\n                        \"type\": \"AssignmentPattern\",\n                        \"left\": {\n                            \"type\": \"Identifier\",\n                            \"name\": p.name\n                        },\n                        \"right\": astLiteral(p.defaultValue)\n                    };\n                }\n\n                return astId(p.name);\n            }\n        }\n\n        throw new Error('Invalid param: ' + JSON.stringify(p));\n    });\n}\n\nfunction mapArgs(args) {\n    args = Array.isArray(args) ? args : [ args ];\n\n    if (_.isEmpty(args)) return [];\n\n    return args.map(a => {\n        if (_.isPlainObject(a) && 'type' in a) {\n            return a;\n        }\n\n        return astValue(a);\n    });\n}\n\nfunction mapBody(body) {\n    if (Array.isArray(body)) {\n        return astBlock(body);\n    }\n    \n    if (_.isPlainObject(body) && 'type' in body) {\n        return body;\n    }\n\n    return astValue(body);\n}\n\nfunction astProgram(strict = true) {\n    return {\n        \"type\": \"Program\",\n        \"body\": strict ? [astExpression(astValue('use strict'))] : [],\n        \"sourceType\": \"script\"\n    };\n}\n\nfunction astRequire(varName, requirePath, isObjDestruct = false) {\n    return {\n        \"type\": \"VariableDeclaration\",\n        \"declarations\": [\n            {\n                \"type\": \"VariableDeclarator\",\n                \"id\": isObjDestruct ? astObjPat(varName) : astId(varName),\n                \"init\": astCall('require', [ astValue(requirePath) ])\n            }\n        ],\n        \"kind\": \"const\"\n    };\n}\n\nfunction astLeadingComments(comment, type = 'Line') {\n    return comment ? { \"leadingComments\": [\n        {\n            \"type\": type,\n            \"value\": comment,\n            \"range\": [\n                1,\n                comment.length+3\n            ]\n        }\n    ]} : {};\n}\n\nfunction astVarDeclare(left, right, isConstant = false, isObjDestruct = false, comment = false) {\n    return {\n        \"type\": \"VariableDeclaration\",\n        \"declarations\": [\n            {\n                \"type\": \"VariableDeclarator\",\n                \"id\": isObjDestruct ? astObjPat(left) : astId(left),\n                \"init\": _.isNil(right) ? null : astValue(right)\n            }\n        ],\n        \"kind\": isConstant ? \"const\" : \"let\",\n        ...astLeadingComments(comment)\n    };\n}\n\nfunction astClassDeclare(className, superClassName, body, comment = false) {\n    let ast = {\n        \"type\": \"ClassDeclaration\",\n        \"id\": astId(className),\n        ...(comment ? astLeadingComments(`*\\n * ${comment}\\n * @class\\n `, 'Block') : {})\n    };\n\n    if (superClassName) {\n        ast['superClass'] = astId(superClassName);\n    }\n\n    ast['body'] = {\n        \"type\": \"ClassBody\",\n        \"body\": body ? (Array.isArray(body) ? body : [ body ]) : []\n    };\n\n    return ast;\n}\n\nfunction astMemberMethod(name, params, body, generator = false, async = false, isStatic = false, comment = false) {\n    return {\n        \"type\": \"MethodDefinition\",\n        \"key\": astId(name),\n        \"computed\": false,\n        \"value\": astAnonymousFunction(params, body, generator, async),\n        \"kind\": \"method\",\n        \"static\": isStatic,\n        //\"*\\n * \\n * @param identity\\n * @param password\\n * @returns {*}\\n \"\n        ...(comment ? astLeadingComments(`*\\n * ${comment}${params.map(p => `\\n * @param ${p}`).join('')}${Array.isArray(body) && _.last(body).type === 'ReturnStatement' ? '\\n * @returns {*}' : ''}\\n `, 'Block') : {})\n    };\n}\n\nfunction astIf(test, consequent, alternate, comment = false) {\n    return {\n        \"type\": \"IfStatement\",\n        \"test\": astValue(test),\n        \"consequent\": mapBody(consequent),\n        \"alternate\": _.isNil(alternate) ? null : mapBody(alternate),\n        ...astLeadingComments(comment)\n    };\n}\n\nfunction astBinExp(left, operator, right) {\n    return {\n        \"type\": \"BinaryExpression\",\n        \"operator\": operator,\n        \"left\": astValue(left),\n        \"right\": astValue(right)\n    }\n}\n\nfunction astLogicalExp(left, operator, right) {\n    return {\n        \"type\": \"LogicalExpression\",\n        \"operator\": operator,\n        \"left\": astValue(left),\n        \"right\": astValue(right)\n    }\n}\n\nfunction astCall(functionName, args) {\n    return {\n        \"type\": \"CallExpression\",\n        \"callee\": _.isPlainObject(functionName) ? functionName : astVarRef(functionName),\n        \"arguments\": mapArgs(args)\n    };\n}\n\nfunction astYield(target, delegate = false) {\n    return {\n        \"type\": \"YieldExpression\",\n        \"argument\": target,\n        \"delegate\": delegate\n    };\n}\n\nfunction astAwait(functionName, args) {\n    return {\n        \"type\": \"AwaitExpression\",\n        \"argument\": astCall(functionName, args)\n    };\n}\n\nfunction astArrayAccess(name, index) {\n    return {\n        \"type\": \"MemberExpression\",\n        \"computed\": true,\n        \"object\": astVarRef(name),\n        \"property\": {\n            \"type\": \"Literal\",\n            \"value\": index,\n            \"raw\": `${index}`\n        }\n    }\n}\n\nfunction astVarRef(name, elementStyle = false) {\n    if (_.isPlainObject(name)) {\n        if (name.type === 'MemberExpression' || name.type === 'Identifier') {\n            return name;\n        }\n\n        if (name.oolType === 'ObjectReference') {\n            return astVarRef(name.name, elementStyle);\n        }\n\n        throw new Error('Invalid reference: ' + JSON.stringify(name));\n    }\n\n    let p = name.split('.');\n    if (p.length > 1) {\n        //p.reverse();\n        let result = {\n            \"type\": \"MemberExpression\",\n            \"computed\": elementStyle,\n            \"property\": elementStyle ? astLiteral(p.pop()) : astId(p.pop())\n        };\n\n        let last = result;\n\n        while (p.length > 1) {\n            last[\"object\"] = {\n                \"type\": \"MemberExpression\",\n                \"computed\": elementStyle,\n                \"property\": elementStyle ? astLiteral(p.pop()) : astId(p.pop())\n            };\n\n            last = last[\"object\"];\n        }\n\n        last[\"object\"] = p[0] === 'this' \n            ? astThis()\n            : astId(p[0]);\n\n        return result;\n    } else {\n        return astId(name);\n    }\n}\n\nfunction astThis() {\n    return { \"type\": \"ThisExpression\" };\n}\n\nfunction astId(name) {\n    if (typeof name === 'string') {\n        return {\n            \"type\": \"Identifier\",\n            \"name\": name\n        };\n    } else if (_.isPlainObject(name) && name.type === 'Identifier') {\n        return name;\n    }\n\n    throw new Error('Invalid identifier name: ' + JSON.stringify(name));\n}\n\nfunction astObjPat(keys) {\n    return {\n        \"type\": \"ObjectPattern\",\n        \"properties\": _.map(keys, (k) => ({\n            \"type\": \"Property\",\n            \"key\": astId(k),\n            \"computed\": false,\n            \"value\": astId(k),\n            \"kind\": \"init\",\n            \"method\": false,\n            \"shorthand\": true\n        }))\n    };\n}\n\nfunction astMember(key, any, shorthand = false) {\n    return {\n        \"type\": \"Property\",\n        \"key\": key.startsWith(':') ? astLiteral(key) : astId(key),\n        \"computed\": false,\n        \"value\": any,\n        \"kind\": \"init\",\n        \"method\": false,\n        \"shorthand\": shorthand\n    };\n}\n\nfunction astValue(value) {\n    if (Array.isArray(value)) {\n        return {\n            \"type\": \"ArrayExpression\",\n            \"elements\": _.map(value, e => astValue(e))\n        };\n    }\n\n    if (_.isPlainObject(value)) {\n        if (AST_OBJECT_TYPES.indexOf(value.type) !== -1) {\n            return value;\n        }\n\n        if (value.oolType === 'ObjectReference') {\n            return astVarRef(value.name, true);\n        }\n\n        if (value.oolType === 'RegExp') {\n            let [ literal ] = esprima.tokenize(value.value);\n            return {\n                \"type\": \"NewExpression\",\n                \"callee\": {\n                    \"type\": \"Identifier\",\n                    \"name\": \"RegExp\"\n                },\n                \"arguments\": [\n                    astLiteral(literal.regex.pattern),\n                    ...(literal.regex.flags ? [ astLiteral(literal.regex.flags) ] : [])\n                ]\n            };\n        }\n\n        let props = [];\n\n        _.forOwn(value, (any, key) => {\n            props.push(astMember(key, astValue(any)));\n        });\n\n        return {\n            \"type\": \"ObjectExpression\",\n            \"properties\": props\n        };\n    }\n\n    if (_.isObject(value)) {\n        throw new Error('Only plain object supported. Given: ' + JSON.stringify(value));\n    }\n\n    return astLiteral(value);\n}\n\nfunction astLiteral(value) {\n    return {\n        \"type\": \"Literal\",\n        \"value\": value,\n        \"raw\": JSON.stringify(value)\n    };\n}\n\nfunction astAddMember(obj, member) {\n    obj.properties.push(member);\n}\n\nfunction astPushInBody(obj, expr) {\n    if (Array.isArray(obj.body)) {\n        obj.body = obj.body.concat(_.castArray(expr));\n    } else {\n        obj.body.body = obj.body.body.concat(_.castArray(expr));\n    }\n}\n\nfunction astFunction(name, params, body, generator = false, async = false) {\n    return {\n        \"type\": \"FunctionDeclaration\",\n        \"id\": astId(name),\n        \"generator\": generator,\n        \"expression\": false,\n        \"async\": async,\n        \"defaults\": [],\n        \"params\": astParams(params),\n        \"body\": astBlock(body)\n    };\n}\n\nfunction astAnonymousFunction(params, body, generator = false, async = false) {\n    return {\n        \"type\": \"FunctionExpression\",\n        \"id\": null,\n        \"params\": astParams(params),\n        \"defaults\": [],\n        \"body\": astBlock(body),\n        \"generator\": generator,\n        \"expression\": false,\n        \"async\": async\n    };\n}\n\nfunction astArrowFunction(params, body, generator = false, async = false) {\n    return {\n        \"type\": \"ArrowFunctionExpression\",\n        \"id\": null,\n        \"params\": astParams(params),\n        \"body\": mapBody(body),\n        \"generator\": generator,\n        \"expression\": true,\n        \"async\": async\n    }\n}\n\nfunction astBlock(body) {\n    return {\n        \"type\": \"BlockStatement\",\n        \"body\": Array.isArray(body) ? body : [ body ]\n    };\n}\n\nfunction astMatchObject(idList, right, isConstant = true) {\n    return {\n        \"type\": \"VariableDeclaration\",\n        \"declarations\": [\n            {\n                \"type\": \"VariableDeclarator\",\n                \"id\": {\n                    \"type\": \"ObjectPattern\",\n                    \"properties\": _.map(idList, id => astMember(id, astId(id), true))\n                },\n                \"init\": right\n            }\n        ],\n        \"kind\": isConstant ? \"const\" : \"let\"\n    };\n}\n\nfunction astExpression(expr, comment = false) {\n    return {\n        \"type\": \"ExpressionStatement\",\n        \"expression\": expr,\n        ...astLeadingComments(comment)\n    };\n}\n\nfunction astAssign(left, right, comment = false) {\n    return astExpression({\n        \"type\": \"AssignmentExpression\",\n        \"operator\": \"=\",\n        \"left\": astVarRef(left),\n        \"right\": astValue(right)\n    }, comment);\n}\n\nfunction astConditional(test, consequent, alternate) {\n    return {\n        \"type\": \"ConditionalExpression\",\n        \"test\": astValue(test),\n        \"consequent\": astValue(consequent),\n        \"alternate\": astValue(alternate)\n    }\n}\n\nfunction astThrow(name, args) {\n    return {\n        \"type\": \"ThrowStatement\",\n        \"argument\": {\n            \"type\": \"NewExpression\",\n            \"callee\": astVarRef(name),\n            \"arguments\": mapArgs(args)\n        }\n    };\n}\n\nfunction astNot(expr) {\n    return {\n        \"type\": \"UnaryExpression\",\n        \"operator\": \"!\",\n        \"argument\": astValue(expr),\n        \"prefix\": true\n    };\n}\n\nfunction astReturn(val) {\n    return {\n        \"type\": \"ReturnStatement\",\n        \"argument\": astValue(val)\n    };\n}\n\nfunction astToCode(ast) {       \n    return escodegen.generate(ast, {\n        format: {\n            indent: {\n                style: '    ',\n                base: 0,\n                adjustMultilineComment: false\n            },\n            newline: '\\n',\n            space: ' ',\n            json: false,\n            renumber: false,\n            hexadecimal: false,\n            quotes: 'single',\n            escapeless: false,\n            compact: false,\n            parentheses: true,\n            semicolons: true,\n            safeConcatenation: false\n        },\n        comment: true\n    });\n}\n\nmodule.exports = {\n    astProgram,\n    astRequire,\n    astVarDeclare,\n    astClassDeclare,\n    astMemberMethod,\n    astCall,\n    astYield,\n    astAwait,\n    astThis,\n    astId,\n    astVarRef,\n    astValue,\n    astFunction,\n    astAnonymousFunction,\n    astArrowFunction,\n    astIf,\n    astConditional,\n    astBinExp,\n    astLogicalExp,\n    astBlock,\n    astMatchObject,\n    astExpression,\n    astAssign,\n    astAddMember,\n    astMember,\n    astPushInBody,\n    astThrow,\n    astNot,\n    astReturn,\n    astLiteral,\n    astParams,\n    astArrayAccess,\n    astToCode\n};"],"names":["_","require","escodegen","esprima","AST_OBJECT_TYPES","astParams","params","Array","isArray","map","p","astId","isPlainObject","type","oolType","defaultValue","name","astLiteral","Error","JSON","stringify","mapArgs","args","isEmpty","a","astValue","mapBody","body","astBlock","astProgram","strict","astExpression","astRequire","varName","requirePath","isObjDestruct","astObjPat","astCall","astLeadingComments","comment","length","astVarDeclare","left","right","isConstant","isNil","astClassDeclare","className","superClassName","ast","astMemberMethod","generator","async","isStatic","astAnonymousFunction","join","last","astIf","test","consequent","alternate","astBinExp","operator","astLogicalExp","functionName","astVarRef","astYield","target","delegate","astAwait","astArrayAccess","index","elementStyle","split","result","pop","astThis","keys","k","astMember","key","any","shorthand","startsWith","value","e","indexOf","literal","tokenize","regex","pattern","flags","props","forOwn","push","isObject","astAddMember","obj","member","properties","astPushInBody","expr","concat","castArray","astFunction","astArrowFunction","astMatchObject","idList","id","astAssign","astConditional","astThrow","astNot","astReturn","val","astToCode","generate","format","indent","style","base","adjustMultilineComment","newline","space","json","renumber","hexadecimal","quotes","escapeless","compact","parentheses","semicolons","safeConcatenation","module","exports"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}