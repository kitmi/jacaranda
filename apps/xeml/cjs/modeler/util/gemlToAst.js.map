{"version":3,"sources":["../../../src/modeler/util/gemlToAst.js"],"sourcesContent":["\"use strict\";\n\n/**\n * @module\n * @ignore\n */\n\nconst { _ } = require('@genx/july');\nconst { TopoSort } = require('@genx/algorithm');\n\nconst JsLang = require('./ast.js');\nconst GemlTypes = require('../../lang/GemlTypes.js');\nconst { isDotSeparateName, extractDotSeparateName, extractReferenceBaseName } = require('../../lang/GemlUtils.js');\nconst { Types, Validators, Processors, Activators } = require('@genx/data');\n\nconst defaultError = 'InvalidRequest';\n\nconst AST_BLK_FIELD_PRE_PROCESS = 'FieldPreProcess';\nconst AST_BLK_PARAM_SANITIZE = 'ParameterSanitize';\nconst AST_BLK_PROCESSOR_CALL = 'ProcessorCall';\nconst AST_BLK_VALIDATOR_CALL = 'ValidatorCall';\nconst AST_BLK_ACTIVATOR_CALL = 'ActivatorCall';\nconst AST_BLK_VIEW_OPERATION = 'ViewOperation';\nconst AST_BLK_VIEW_RETURN = 'ViewReturn';\nconst AST_BLK_INTERFACE_OPERATION = 'InterfaceOperation';\nconst AST_BLK_INTERFACE_RETURN = 'InterfaceReturn';\nconst AST_BLK_EXCEPTION_ITEM = 'ExceptionItem';\n\nconst OOL_MODIFIER_CODE_FLAG = {\n    [GemlTypes.Modifier.VALIDATOR]: AST_BLK_VALIDATOR_CALL,\n    [GemlTypes.Modifier.PROCESSOR]: AST_BLK_PROCESSOR_CALL,\n    [GemlTypes.Modifier.ACTIVATOR]: AST_BLK_ACTIVATOR_CALL\n};\n\nconst OOL_MODIFIER_OP = {\n    [GemlTypes.Modifier.VALIDATOR]: '|~',\n    [GemlTypes.Modifier.PROCESSOR]: '|>',\n    [GemlTypes.Modifier.ACTIVATOR]: '|=' \n};\n\nconst OOL_MODIFIER_PATH = {\n    [GemlTypes.Modifier.VALIDATOR]: 'validators',\n    [GemlTypes.Modifier.PROCESSOR]: 'processors',\n    [GemlTypes.Modifier.ACTIVATOR]: 'activators' \n};\n\nconst OOL_MODIFIER_BUILTIN = {\n    [GemlTypes.Modifier.VALIDATOR]: Validators,\n    [GemlTypes.Modifier.PROCESSOR]: Processors,\n    [GemlTypes.Modifier.ACTIVATOR]: Activators \n};\n\nconst OPERATOR_TOKEN = {\n    \">\": \"$gt\",\n    \"<\": \"$lt\",\n    \">=\": \"$gte\",\n    \"<=\": \"$lte\",\n    \"==\": \"$eq\",\n    \"!=\": \"$ne\",\n    \"in\": \"$in\",\n    \"notIn\": \"$nin\"\n};\n\n/**\n * Compile a conditional expression\n * @param {object} test\n * @param {object} compileContext\n * @property {string} compileContext.moduleName\n * @property {TopoSort} compileContext.topoSort\n * @property {object} compileContext.astMap - Topo Id to ast map\n * @param {string} startTopoId\n * @returns {string} Topo Id\n */\nfunction compileConditionalExpression(test, compileContext, startTopoId) {\n    if (_.isPlainObject(test)) {        \n        if (test.oolType === 'ValidateExpression') {\n            let endTopoId = createTopoId(compileContext, startTopoId + '$valiOp:done');\n            let operandTopoId = createTopoId(compileContext, startTopoId + '$valiOp');\n\n            dependsOn(compileContext, startTopoId, operandTopoId);\n\n            let lastOperandTopoId = compileConcreteValueExpression(operandTopoId, test.caller, compileContext);\n            dependsOn(compileContext, lastOperandTopoId, endTopoId);\n\n            let astArgument = getCodeRepresentationOf(lastOperandTopoId, compileContext);\n\n            let retTopoId = compileAdHocValidator(endTopoId, astArgument, test.callee, compileContext);\n\n            assert: retTopoId === endTopoId;\n\n            /*\n            compileContext.astMap[endTopoId] = JsLang.astCall('_.isEmpty', astArgument);\n\n            switch (test.operator) {\n                case 'exists':\n                    compileContext.astMap[endTopoId] = JsLang.astNot(JsLang.astCall('_.isEmpty', astArgument));\n                    break;\n\n                case 'is-not-null':\n                    compileContext.astMap[endTopoId] = JsLang.astNot(JsLang.astCall('_.isNil', astArgument));\n                    break;\n\n                case 'not-exists':\n                    \n                    break;\n\n                case 'is-null':\n                    compileContext.astMap[endTopoId] = JsLang.astCall('_.isNil', astArgument);\n                    break;\n\n                case 'not':\n                    compileContext.astMap[endTopoId] = JsLang.astNot(astArgument);\n                    break;\n\n                default:\n                    throw new Error('Unsupported test operator: ' + test.operator);\n            }\n            */\n\n            return endTopoId;\n\n        } else if (test.oolType === 'LogicalExpression') {\n            let endTopoId = createTopoId(compileContext, startTopoId + '$lopOp:done');\n\n            let op;\n\n            switch (test.operator) {\n                case 'and':\n                    op = '&&';\n                    break;\n\n                case 'or':\n                    op = '||';\n                    break;\n\n                default:\n                    throw new Error('Unsupported test operator: ' + test.operator);\n            }\n\n            let leftTopoId = createTopoId(compileContext, startTopoId + '$lopOp:left');\n            let rightTopoId = createTopoId(compileContext, startTopoId + '$lopOp:right');\n\n            dependsOn(compileContext, startTopoId, leftTopoId);\n            dependsOn(compileContext, startTopoId, rightTopoId);\n\n            let lastLeftId = compileConditionalExpression(test.left, compileContext, leftTopoId);\n            let lastRightId = compileConditionalExpression(test.right, compileContext, rightTopoId);\n\n            dependsOn(compileContext, lastLeftId, endTopoId);\n            dependsOn(compileContext, lastRightId, endTopoId);\n\n            compileContext.astMap[endTopoId] = JsLang.astBinExp(\n                getCodeRepresentationOf(lastLeftId, compileContext),\n                op,\n                getCodeRepresentationOf(lastRightId, compileContext)\n            ); \n\n            return endTopoId;\n\n        } else if (test.oolType === 'BinaryExpression') {\n            let endTopoId = createTopoId(compileContext, startTopoId + '$binOp:done');\n\n            let op;\n\n            switch (test.operator) {\n                case '>':\n                case '<':\n                case '>=':\n                case '<=':\n                case 'in':\n                    op = test.operator;\n                    break;\n\n                case '==':\n                    op = '===';\n                    break;\n\n                case '!=':\n                    op = '!==';\n                    break;\n\n                default:\n                    throw new Error('Unsupported test operator: ' + test.operator);\n            }\n\n            let leftTopoId = createTopoId(compileContext, startTopoId + '$binOp:left');\n            let rightTopoId = createTopoId(compileContext, startTopoId + '$binOp:right');\n\n            dependsOn(compileContext, startTopoId, leftTopoId);\n            dependsOn(compileContext, startTopoId, rightTopoId);\n\n            let lastLeftId = compileConcreteValueExpression(leftTopoId, test.left, compileContext);\n            let lastRightId = compileConcreteValueExpression(rightTopoId, test.right, compileContext);\n\n            dependsOn(compileContext, lastLeftId, endTopoId);\n            dependsOn(compileContext, lastRightId, endTopoId);\n\n            compileContext.astMap[endTopoId] = JsLang.astBinExp(\n                getCodeRepresentationOf(lastLeftId, compileContext),\n                op,\n                getCodeRepresentationOf(lastRightId, compileContext)\n            ); \n\n            return endTopoId;\n\n        } else if (test.oolType === 'UnaryExpression') {\n            let endTopoId = createTopoId(compileContext, startTopoId + '$unaOp:done');\n            let operandTopoId = createTopoId(compileContext, startTopoId + '$unaOp');\n\n            dependsOn(compileContext, startTopoId, operandTopoId);\n\n            let lastOperandTopoId = test.operator === 'not' ? compileConcreteValueExpression(operandTopoId, test.argument, compileContext) : compileConditionalExpression(test.argument, compileContext, operandTopoId);\n            dependsOn(compileContext, lastOperandTopoId, endTopoId);\n\n            let astArgument = getCodeRepresentationOf(lastOperandTopoId, compileContext);\n\n            switch (test.operator) {\n                case 'exists':\n                    compileContext.astMap[endTopoId] = JsLang.astNot(JsLang.astCall('_.isEmpty', astArgument));\n                    break;\n\n                case 'is-not-null':\n                    compileContext.astMap[endTopoId] = JsLang.astNot(JsLang.astCall('_.isNil', astArgument));\n                    break;\n\n                case 'not-exists':\n                    compileContext.astMap[endTopoId] = JsLang.astCall('_.isEmpty', astArgument);\n                    break;\n\n                case 'is-null':\n                    compileContext.astMap[endTopoId] = JsLang.astCall('_.isNil', astArgument);\n                    break;\n\n                case 'not':\n                    compileContext.astMap[endTopoId] = JsLang.astNot(astArgument);\n                    break;\n\n                default:\n                    throw new Error('Unsupported test operator: ' + test.operator);\n            }\n\n            return endTopoId;\n\n        } else {\n            let valueStartTopoId = createTopoId(compileContext, startTopoId + '$value');\n            dependsOn(compileContext, startTopoId, valueStartTopoId);\n            return compileConcreteValueExpression(valueStartTopoId, test, compileContext);\n        } \n    }\n\n    compileContext.astMap[startTopoId] = JsLang.astValue(test);\n    return startTopoId;\n}\n\n/**\n * Compile a validator called in a logical expression.\n * @param value\n * @param functors\n * @param compileContext\n * @param topoInfo\n * @property {string} topoInfo.topoIdPrefix\n * @property {string} topoInfo.lastTopoId\n * @returns {*|string}\n */\nfunction compileAdHocValidator(topoId, value, functor, compileContext) {\n    assert: functor.oolType === GemlTypes.Modifier.VALIDATOR;        \n\n    let callArgs;\n    \n    if (functor.args) {\n        callArgs = translateArgs(topoId, functor.args, compileContext);        \n    } else {\n        callArgs = [];\n    }            \n    \n    let arg0 = value;\n    \n    compileContext.astMap[topoId] = JsLang.astCall('Validators.' + functor.name, [ arg0 ].concat(callArgs));\n\n    return topoId;\n}\n\n/**\n * Compile a modifier from ool to ast.\n * @param topoId - startTopoId\n * @param value\n * @param functors\n * @param compileContext\n * @param topoInfo\n * @property {string} topoInfo.topoIdPrefix\n * @property {string} topoInfo.lastTopoId\n * @returns {*|string}\n */\nfunction compileModifier(topoId, value, functor, compileContext) {\n    let declareParams;\n\n    if (functor.oolType === GemlTypes.Modifier.ACTIVATOR) { \n        declareParams = translateFunctionParams([{name: compileContext.moduleName}, {name: 'context'}].concat(functor.args));        \n    } else {\n        declareParams = translateFunctionParams(_.isEmpty(functor.args) ? [value] : [value].concat(functor.args));        \n    }        \n\n    let functorId = translateModifier(functor, compileContext, declareParams);\n\n    let callArgs, references;\n    \n    if (functor.args) {\n        callArgs = translateArgs(topoId, functor.args, compileContext);\n        references = extractReferencedFields(functor.args);\n\n        if (_.find(references, ref => ref === value.name)) {\n            throw new Error('Cannot use the target field itself as an argument of a modifier.');\n        }\n    } else {\n        callArgs = [];\n    }        \n    \n    if (functor.oolType === GemlTypes.Modifier.ACTIVATOR) {            \n        compileContext.astMap[topoId] = JsLang.astAwait(functorId, [ JsLang.astVarRef('this'), JsLang.astVarRef('context') ].concat(callArgs));\n    } else {\n        let arg0 = value;\n        if (!isTopLevelBlock(topoId) && _.isPlainObject(value) && value.oolType === 'ObjectReference' && value.name.startsWith('latest.')) {\n            //let existingRef =            \n            arg0 = JsLang.astConditional(\n                JsLang.astCall('latest.hasOwnProperty', [ extractReferenceBaseName(value.name) ]), /** test */\n                value, /** consequent */\n                replaceVarRefScope(value, 'existing')\n            );  \n        }\n        compileContext.astMap[topoId] = JsLang.astCall(functorId, [ arg0 ].concat(callArgs));\n    }    \n\n    if (isTopLevelBlock(topoId)) {\n        let targetVarName = value.name;\n        let needDeclare = false;\n\n        if (!isDotSeparateName(value.name) && compileContext.variables[value.name] && functor.oolType !== GemlTypes.Modifier.VALIDATOR) {\n            //conflict with existing variables, need to rename to another variable\n            let counter = 1;\n            do {\n                counter++;       \n                targetVarName = value.name + counter.toString();         \n            } while (compileContext.variables.hasOwnProperty(targetVarName));            \n\n            compileContext.variables[targetVarName] = { type: 'localVariable', source: 'modifier' };\n            needDeclare = true;\n        }\n\n        //if (compileContext.variables[])\n\n        addCodeBlock(compileContext, topoId, {\n            type: OOL_MODIFIER_CODE_FLAG[functor.oolType],\n            target: targetVarName,\n            references,   // latest., exsiting., raw.\n            needDeclare\n        });\n    }\n\n    return topoId;\n}  \n      \nfunction extractReferencedFields(oolArgs) {   \n    oolArgs = _.castArray(oolArgs);    \n\n    let refs = [];\n\n    oolArgs.forEach(a => {\n        if (Array.isArray(a)) {\n            refs = refs.concat(extractReferencedFields(a));\n            return;\n        } \n\n        let result = checkReferenceToField(a);\n        if (result) {\n            refs.push(result);\n        }\n    });\n\n    return refs;\n}\n\nfunction checkReferenceToField(obj) {\n    if (_.isPlainObject(obj) && obj.oolType) {\n        if (obj.oolType === 'PipedValue') return checkReferenceToField(obj.value);\n        if (obj.oolType === 'ObjectReference') {\n            return obj.name;\n        }\n    }\n\n    return undefined;\n}\n\nfunction addModifierToMap(functorId, functorType, functorJsFile, mapOfFunctorToFile) {\n    if (mapOfFunctorToFile[functorId] && mapOfFunctorToFile[functorId] !== functorJsFile) {\n        throw new Error(`Conflict: ${functorType} naming \"${functorId}\" conflicts!`);\n    }\n    mapOfFunctorToFile[functorId] = functorJsFile;\n}\n\n/**\n * Check whether a functor is user-defined or built-in\n * @param functor\n * @param compileContext\n * @param args - Used to make up the function signature\n * @returns {string} functor id\n */\nfunction translateModifier(functor, compileContext, args) {\n    let functionName, fileName, functorId;\n\n    //extract validator naming and import information\n    if (isDotSeparateName(functor.name)) {\n        let names = extractDotSeparateName(functor.name);\n        if (names.length > 2) {\n            throw new Error('Not supported reference type: ' + functor.name);\n        }\n\n        //reference to other entity file\n        let refEntityName = names[0];\n        functionName = names[1];\n        fileName = './' + OOL_MODIFIER_PATH[functor.oolType] + '/' + refEntityName + '-' + functionName + '.js';\n        functorId = refEntityName + _.upperFirst(functionName);\n        addModifierToMap(functorId, functor.oolType, fileName, compileContext.mapOfFunctorToFile);\n\n    } else {\n        functionName = functor.name;\n\n        let builtins = OOL_MODIFIER_BUILTIN[functor.oolType];\n\n        if (!(functionName in builtins)) {\n            fileName = './' + OOL_MODIFIER_PATH[functor.oolType] + '/' + compileContext.moduleName + '-' + functionName + '.js';\n            functorId = functionName;\n\n            if (!compileContext.mapOfFunctorToFile[functorId]) {\n                compileContext.newFunctorFiles.push({\n                    functionName,\n                    functorType: functor.oolType,\n                    fileName,\n                    args\n                });\n            }\n\n            addModifierToMap(functorId, functor.oolType, fileName, compileContext.mapOfFunctorToFile);            \n        } else {            \n            functorId = functor.oolType + 's.' + functionName;\n        }\n    }\n\n    return functorId;\n}\n\n/**\n * Compile a piped value from ool to ast.\n * @param {string} startTopoId - The topological id of the starting process to the target value, default as the param name\n * @param {object} varOol - Target value ool node.\n * @param {object} compileContext - Compilation context.\n * @property {string} compileContext.moduleName\n * @property {TopoSort} compileContext.topoSort\n * @property {object} compileContext.astMap - Topo Id to ast map\n * @returns {string} Last topo Id\n */\nfunction compilePipedValue(startTopoId, varOol, compileContext) {\n    let lastTopoId = compileConcreteValueExpression(startTopoId, varOol.value, compileContext);\n\n    varOol.modifiers.forEach(modifier => {\n        let modifierStartTopoId = createTopoId(compileContext, startTopoId + OOL_MODIFIER_OP[modifier.oolType] + modifier.name);\n        dependsOn(compileContext, lastTopoId, modifierStartTopoId);\n\n        lastTopoId = compileModifier(\n            modifierStartTopoId,\n            varOol.value,\n            modifier,\n            compileContext\n        );\n    });\n\n    return lastTopoId;\n}\n\n/**\n * Compile a variable reference from ool to ast.\n * @param {string} startTopoId - The topological id of the starting process to the target value, default as the param name\n * @param {object} varOol - Target value ool node.\n * @param {object} compileContext - Compilation context.\n * @property {string} compileContext.moduleName\n * @property {TopoSort} compileContext.topoSort\n * @property {object} compileContext.astMap - Topo Id to ast map\n * @returns {string} Last topo Id\n */\nfunction compileVariableReference(startTopoId, varOol, compileContext) {\n    pre: _.isPlainObject(varOol) && varOol.oolType === 'ObjectReference';\n\n    //let [ baseName, others ] = varOol.name.split('.', 2);\n    /*\n    if (compileContext.modelVars && compileContext.modelVars.has(baseName) && others) {\n        varOol.name = baseName + '.data' + '.' + others;\n    }*/    \n\n    //simple value\n    compileContext.astMap[startTopoId] = JsLang.astValue(varOol);\n    return startTopoId;\n}\n\n/**\n * Get an array of parameter names.\n * @param {array} args - An array of arguments in ool syntax\n * @returns {array}\n */\nfunction translateFunctionParams(args) {\n    if (_.isEmpty(args)) return [];\n\n    let names = new Set();\n\n    function translateFunctionParam(arg, i) {\n        if (_.isPlainObject(arg)) {\n            if (arg.oolType === 'PipedValue') {\n                return translateFunctionParam(arg.value);\n            }\n\n            if (arg.oolType === 'ObjectReference') {\n                if (isDotSeparateName(arg.name)) {\n                    return extractDotSeparateName(arg.name).pop();\n                }\n            }            \n\n            return arg.name;\n        }\n\n        return 'param' + (i + 1).toString();\n    }\n\n    return _.map(args, (arg, i) => {\n        let baseName = translateFunctionParam(arg, i);\n        let name = baseName;\n        let count = 2;\n        \n        while (names.has(name)) {\n            name = baseName + count.toString();\n            count++;\n        }\n\n        names.add(name);\n        return name;        \n    });\n}\n\n/**\n * Compile a concrete value expression from ool to ast\n * @param {string} startTopoId - The topo id of the starting process to the target value expression\n * @param {object} value - Ool node\n * @param {object} compileContext - Compilation context\n * @returns {string} Last topoId\n */\nfunction compileConcreteValueExpression(startTopoId, value, compileContext) {\n    if (_.isPlainObject(value)) {\n        if (value.oolType === 'PipedValue') {\n            return compilePipedValue(startTopoId, value, compileContext);\n        }\n\n        if (value.oolType === 'ObjectReference') {\n            let [ refBase, ...rest ] = extractDotSeparateName(value.name);\n\n            let dependency;\n\n            if (!compileContext.variables[refBase]) {\n                throw new Error(`Referenced undefined variable: ${value.name}`);                \n            } \n\n            if (compileContext.variables[refBase].type === 'entity' && !compileContext.variables[refBase].ongoing) {\n                dependency = refBase;\n            } else if (refBase === 'latest' && rest.length > 0) {\n                //latest.password\n                let refFieldName = rest.pop();\n                if (refFieldName !== startTopoId) {\n                    dependency = refFieldName + ':ready';\n                }\n            } else if (_.isEmpty(rest)) {\n                dependency = refBase + ':ready';\n            } \n\n            if (dependency) {\n                dependsOn(compileContext, dependency, startTopoId);\n            }\n\n            return compileVariableReference(startTopoId, value, compileContext);\n        }\n\n        if (value.oolType === 'RegExp') {\n            compileContext.astMap[startTopoId] = JsLang.astValue(value);            \n            return startTopoId;\n        }\n\n        if (value.oorType === 'SymbolToken') {\n            compileContext.astMap[startTopoId] = JsLang.astValue(translateSymbolToken(value.name));            \n            return startTopoId;\n        }\n        \n        value = _.mapValues(value, (valueOfElement, key) => { \n            let sid = createTopoId(compileContext, startTopoId + '.' + key);\n            let eid = compileConcreteValueExpression(sid, valueOfElement, compileContext);\n            if (sid !== eid) {\n                dependsOn(compileContext, eid, startTopoId);\n            }\n            return compileContext.astMap[eid];\n        });\n    } else if (Array.isArray(value)) {\n        value = _.map(value, (valueOfElement, index) => { \n            let sid = createTopoId(compileContext, startTopoId + '[' + index + ']');\n            let eid = compileConcreteValueExpression(sid, valueOfElement, compileContext);\n            if (sid !== eid) {\n                dependsOn(compileContext, eid, startTopoId);\n            }\n            return compileContext.astMap[eid];\n        });\n    }\n\n    compileContext.astMap[startTopoId] = JsLang.astValue(value);\n    return startTopoId;\n}\n\nfunction translateSymbolToken(name) {\n    if (name === 'NOW') {\n        return {\n            \"type\": \"CallExpression\",\n            \"callee\": {\n                \"type\": \"MemberExpression\",\n                \"computed\": false,\n                \"object\": {\n                    \"type\": \"MemberExpression\",\n                    \"computed\": false,\n                    \"object\": {\n                        \"type\": \"MemberExpression\",\n                        \"computed\": false,\n                        \"object\": {\n                            \"type\": \"Identifier\",\n                            \"name\": \"Types\"\n                        },\n                        \"property\": {\n                            \"type\": \"Identifier\",\n                            \"name\": \"DATETIME\"\n                        }\n                    },\n                    \"property\": {\n                        \"type\": \"Identifier\",\n                        \"name\": \"typeObject\"\n                    }\n                },\n                \"property\": {\n                    \"type\": \"Identifier\",\n                    \"name\": \"local\"\n                }\n            },\n            \"arguments\": []\n        };\n    } \n    \n    throw new Error('not support: ' + name);\n}\n\n/**\n * Translate an array of function arguments from ool into ast.\n * @param topoId - The modifier function topo \n * @param args - \n * @param compileContext - \n * @returns {Array}\n */\nfunction translateArgs(topoId, args, compileContext) {\n    args = _.castArray(args);\n    if (_.isEmpty(args)) return [];\n\n    let callArgs = [];\n\n    _.each(args, (arg, i) => {                \n        let argTopoId = createTopoId(compileContext, topoId + ':arg[' + (i+1).toString() + ']');\n        let lastTopoId = compileConcreteValueExpression(argTopoId, arg, compileContext);\n\n        dependsOn(compileContext, lastTopoId, topoId);\n\n        callArgs = callArgs.concat(_.castArray(getCodeRepresentationOf(lastTopoId, compileContext)));\n    });\n\n    return callArgs;\n}\n\n/**\n * Compile a param of interface from ool into ast\n * @param index\n * @param param\n * @param compileContext\n * @returns {string}\n */\nfunction compileParam(index, param, compileContext) {\n    let type = param.type;    \n\n    let typeObject = Types[type];\n\n    if (!typeObject) {\n        throw new Error('Unknown field type: ' + type);\n    }\n\n    let sanitizerName = `Types.${type.toUpperCase()}.sanitize`;\n\n    let varRef = JsLang.astVarRef(param.name);\n    let callAst = JsLang.astCall(sanitizerName, [varRef, JsLang.astArrayAccess('$meta.params', index), JsLang.astVarRef('this.db.i18n')]);\n\n    let prepareTopoId = createTopoId(compileContext, '$params:sanitize[' + index.toString() + ']');\n    //let sanitizeStarting;\n\n    //if (index === 0) {\n        //declare $sanitizeState variable for the first time\n    //    sanitizeStarting = JsLang.astVarDeclare(varRef, callAst, false, false, `Sanitize param \"${param.name}\"`);\n    //} else {\n    //let sanitizeStarting = ;\n\n        //let lastPrepareTopoId = '$params:sanitize[' + (index - 1).toString() + ']';\n        //dependsOn(compileContext, lastPrepareTopoId, prepareTopoId);\n    //}\n\n    compileContext.astMap[prepareTopoId] = [\n        JsLang.astAssign(varRef, callAst, `Sanitize argument \"${param.name}\"`)\n    ];\n\n    addCodeBlock(compileContext, prepareTopoId, {\n        type: AST_BLK_PARAM_SANITIZE\n    });\n\n    dependsOn(compileContext, prepareTopoId, compileContext.mainStartId);\n\n    let topoId = createTopoId(compileContext, param.name);\n    dependsOn(compileContext, compileContext.mainStartId, topoId);\n\n    let value = wrapParamReference(param.name, param);\n    let endTopoId = compileVariableReference(topoId, value, compileContext);\n\n    let readyTopoId = createTopoId(compileContext, topoId + ':ready');\n    dependsOn(compileContext, endTopoId, readyTopoId);\n\n    return readyTopoId;\n}\n\n/**\n * Compile a model field preprocess information into ast.\n * @param {object} param - Field information\n * @param {object} compileContext - Compilation context\n * @returns {string}\n */\nfunction compileField(paramName, param, compileContext) {\n    // 1. reference to the latest object that is passed qualifier checks\n    // 2. if modifiers exist, wrap the ref into a piped value\n    // 3. process the ref (or piped ref) and mark as end\n    // 4. build dependencies: latest.field -> ... -> field:ready \n    let topoId = createTopoId(compileContext, paramName);\n    let contextName = 'latest.' + paramName;\n    //compileContext.astMap[topoId] = JsLang.astVarRef(contextName, true);\n\n    let value = wrapParamReference(contextName, param);    \n    let endTopoId = compileConcreteValueExpression(topoId, value, compileContext);\n\n    let readyTopoId = createTopoId(compileContext, topoId + ':ready');\n    dependsOn(compileContext, endTopoId, readyTopoId);\n\n    return readyTopoId;\n}\n\nfunction wrapParamReference(name, value) {\n    let ref = Object.assign({ oolType: 'ObjectReference', name: name });\n    \n    if (!_.isEmpty(value.modifiers)) {\n        return { oolType: 'PipedValue', value: ref, modifiers: value.modifiers };\n    }\n    \n    return ref;\n}\n\nfunction hasModelField(operand, compileContext) {\n    if (_.isPlainObject(operand) && operand.oolType === 'ObjectReference') {\n        let [ baseVar, ...rest ] = operand.name.split('.');\n\n        return compileContext.variables[baseVar] && compileContext.variables[baseVar].ongoing && rest.length > 0;        \n    }\n\n    return false;    \n}\n\n/**\n * Translate a then clause from ool into ast in return block.\n * @param {string} startId\n * @param {string} endId\n * @param then\n * @param compileContext\n * @returns {object} AST object\n */\nfunction translateReturnThenAst(startId, endId, then, compileContext) {\n    if (_.isPlainObject(then)) {\n        if (then.oolType === 'ThrowExpression') {\n            let args;\n            if (then.args) {\n                args = translateArgs(startId, then.args, compileContext);\n            } else {\n                args = [];\n            }\n            return JsLang.astThrow(then.errorType || defaultError, then.message || args);\n        }\n\n        if (then.oolType === 'ReturnExpression') {\n            return translateReturnValueAst(startId, endId, then.value, compileContext);\n        }        \n    }\n\n    //then expression is an oolong concrete value    \n    if (_.isArray(then) || _.isPlainObject(then)) {\n        let valueEndId = compileConcreteValueExpression(startId, then, compileContext);    \n        then = compileContext.astMap[valueEndId]; \n    }   \n\n    return JsLang.astReturn(then);\n}\n\n/**\n * Translate a then clause from ool into ast\n * @param {string} startId\n * @param {string} endId\n * @param then\n * @param compileContext\n * @param assignTo\n * @returns {object} AST object\n */\nfunction translateThenAst(startId, endId, then, compileContext, assignTo) {\n    if (_.isPlainObject(then)) {\n        if (then.oolType === 'ThrowExpression') {\n            let args;\n            if (then.args) {\n                args = translateArgs(startId, then.args, compileContext);\n            } else {\n                args = [];\n            }\n            return JsLang.astThrow(then.errorType || defaultError, then.message || args);\n        }\n\n        if (then.oolType === 'LogicalExpression') {\n            /*\n            switch (then.operator) {\n                case 'and':\n                    op = '&&';\n                    break;\n\n                case 'or':\n                    op = '||';\n                    break;\n\n                default:\n                    throw new Error('Unsupported test operator: ' + test.operator);\n            }\n            */\n        }\n\n        if (then.oolType === 'BinaryExpression') {\n            if (!hasModelField(then.left, compileContext)) {                \n                throw new Error('Invalid query condition: the left operand need to be an entity field.');\n            }\n\n            if (hasModelField(then.right, compileContext)) {                \n                throw new Error('Invalid query condition: the right operand should not be an entity field. Use dataset instead if joining is required.');\n            }\n\n            let condition = {};\n            let startRightId = createTopoId(compileContext, startId + '$binOp:right');\n            dependsOn(compileContext, startId, startRightId);\n\n            let lastRightId = compileConcreteValueExpression(startRightId, then.right, compileContext);\n            dependsOn(compileContext, lastRightId, endId);\n            \n            if (then.operator === '==') {\n                condition[then.left.name.split('.', 2)[1]] = compileContext.astMap[lastRightId];\n            } else {\n                condition[then.left.name.split('.', 2)[1]] = { [OPERATOR_TOKEN[op]]: compileContext.astMap[lastRightId] };\n            }\n\n            return JsLang.astAssign(assignTo, JsLang.astValue(condition));           \n        }\n\n        if (then.oolType === 'UnaryExpression') {\n            \n        }\n    }\n\n    //then expression is an oolong concrete value    \n    if (_.isArray(then) || _.isPlainObject(then)) {\n        let valueEndId = compileConcreteValueExpression(startId, then, compileContext);    \n        then = compileContext.astMap[valueEndId]; \n    }   \n\n    return JsLang.astAssign(assignTo, then);\n}\n\n/**\n * Translate a return clause from ool into ast\n * @param {string} startTopoId - The topo id of the starting state of return clause\n * @param {string} endTopoId - The topo id of the ending state of return clause\n * @param value\n * @param compileContext\n * @returns {object} AST object\n */\nfunction translateReturnValueAst(startTopoId, endTopoId, value, compileContext) {\n    let valueTopoId = compileConcreteValueExpression(startTopoId, value, compileContext);\n    if (valueTopoId !== startTopoId) {\n        dependsOn(compileContext, valueTopoId, endTopoId);\n    }\n\n    return JsLang.astReturn(getCodeRepresentationOf(valueTopoId, compileContext));\n}\n\n/**\n * Compile a return clause from ool into ast\n * @param {string} startTopoId - The topo id of the starting process to the target value expression\n * @param value\n * @param compileContext\n * @returns {object} AST object\n */\nfunction compileReturn(startTopoId, value, compileContext) {\n    let endTopoId = createTopoId(compileContext, '$return');\n    dependsOn(compileContext, startTopoId, endTopoId);\n\n    compileContext.astMap[endTopoId] = translateReturnValueAst(startTopoId, endTopoId, value, compileContext);\n\n    addCodeBlock(compileContext, endTopoId, {\n        type: AST_BLK_VIEW_RETURN\n    });\n\n    return endTopoId;\n}\n\n/**\n * Compile a find one operation from ool into ast\n * @param {int} index\n * @param {object} operation - Ool node\n * @param {object} compileContext -\n * @param {string} dependency\n * @returns {string} last topoId\n */\nfunction compileFindOne(index, operation, compileContext, dependency) {\n    pre: dependency;\n\n    let endTopoId = createTopoId(compileContext, 'op$' + index.toString());\n    let conditionVarName = endTopoId + '$condition';\n\n    let ast = [\n        JsLang.astVarDeclare(conditionVarName)\n    ];\n\n    assert: operation.condition;\n\n    compileContext.variables[operation.model] = { type: 'entity', source: 'findOne', ongoing: true };\n\n    if (operation.condition.oolType) {\n        //special condition\n\n        if (operation.condition.oolType === 'cases') {\n            let topoIdPrefix = endTopoId + '$cases';\n            let lastStatement;\n\n            if (operation.condition.else) {\n                let elseStart = createTopoId(compileContext, topoIdPrefix + ':else');\n                let elseEnd = createTopoId(compileContext, topoIdPrefix + ':end');\n                dependsOn(compileContext, elseStart, elseEnd);\n                dependsOn(compileContext, elseEnd, endTopoId);\n\n                lastStatement = translateThenAst(elseStart, elseEnd, operation.condition.else, compileContext, conditionVarName);\n            } else {\n                lastStatement = JsLang.astThrow('ServerError', 'Unexpected state.');\n            }\n\n            if (_.isEmpty(operation.condition.items)) {\n                throw new Error('Missing case items');\n            }\n\n            _.reverse(operation.condition.items).forEach((item, i) => {\n                if (item.oolType !== 'ConditionalStatement') {\n                    throw new Error('Invalid case item.');\n                }\n\n                i = operation.condition.items.length - i - 1;\n\n                let casePrefix = topoIdPrefix + '[' + i.toString() + ']';\n                let caseTopoId = createTopoId(compileContext, casePrefix);\n                dependsOn(compileContext, dependency, caseTopoId);\n\n                let caseResultVarName = '$' + topoIdPrefix + '_' + i.toString();\n\n                let lastTopoId = compileConditionalExpression(item.test, compileContext, caseTopoId);\n                let astCaseTtem = getCodeRepresentationOf(lastTopoId, compileContext);\n\n                assert: !Array.isArray(astCaseTtem), 'Invalid case item ast.';\n\n                astCaseTtem = JsLang.astVarDeclare(caseResultVarName, astCaseTtem, true, false, `Condition ${i} for find one ${operation.model}`);\n\n                let ifStart = createTopoId(compileContext, casePrefix + ':then');\n                let ifEnd = createTopoId(compileContext, casePrefix + ':end');\n                dependsOn(compileContext, lastTopoId, ifStart);\n                dependsOn(compileContext, ifStart, ifEnd);\n\n                lastStatement = [\n                    astCaseTtem,\n                    JsLang.astIf(JsLang.astVarRef(caseResultVarName), JsLang.astBlock(translateThenAst(ifStart, ifEnd, item.then, compileContext, conditionVarName)), lastStatement)\n                ];\n                dependsOn(compileContext, ifEnd, endTopoId);\n            });\n\n            ast = ast.concat(_.castArray(lastStatement));\n        } else {\n            throw new Error('todo');\n        }\n\n\n    } else {\n        throw new Error('todo');\n    }\n\n    ast.push(\n        JsLang.astVarDeclare(operation.model, JsLang.astAwait(`this.findOne_`, JsLang.astVarRef(conditionVarName)))\n    );\n\n    delete compileContext.variables[operation.model].ongoing;\n\n    let modelTopoId = createTopoId(compileContext, operation.model);\n    dependsOn(compileContext, endTopoId, modelTopoId);\n    compileContext.astMap[endTopoId] = ast;\n    return endTopoId;\n}\n\nfunction compileDbOperation(index, operation, compileContext, dependency) {\n    let lastTopoId;\n\n    switch (operation.oolType) {\n        case 'FindOneStatement':\n            lastTopoId = compileFindOne(index, operation, compileContext, dependency);\n            break;\n\n        case 'find':\n            //prepareDbConnection(compileContext);\n            throw new Error('tbi');\n            break;\n\n        case 'update':\n            throw new Error('tbi');\n            //prepareDbConnection(compileContext);\n            break;\n\n        case 'create':\n            throw new Error('tbi');\n            //prepareDbConnection(compileContext);\n            break;\n\n        case 'delete':\n            throw new Error('tbi');\n            //prepareDbConnection(compileContext);\n            break;\n\n        case 'DoStatement':\n            let doBlock = operation.do;\n            lastTopoId = compileDoStatement(index, doBlock, compileContext, dependency);\n            break;\n\n        case 'assignment':\n            throw new Error('tbi');\n            break;\n\n        default:\n            throw new Error('Unsupported operation type: ' + operation.type);\n    }\n\n    addCodeBlock(compileContext, lastTopoId, {\n        type: AST_BLK_INTERFACE_OPERATION\n    });\n\n    return lastTopoId;\n}\n\nfunction compileDoStatement(index, operation, compileContext, dependency) {\n        \n}\n\n/**\n * Compile exceptional return \n * @param {object} oolNode\n * @param {object} compileContext\n * @param {string} [dependency]\n * @returns {string} last topoId\n */\nfunction compileExceptionalReturn(oolNode, compileContext, dependency) {\n    pre: (_.isPlainObject(oolNode) && oolNode.oolType === 'ReturnExpression');\n\n    let endTopoId = createTopoId(compileContext, '$return'), lastExceptionId = dependency;\n\n    if (!_.isEmpty(oolNode.exceptions)) {\n        oolNode.exceptions.forEach((item, i) => {\n            if (_.isPlainObject(item)) {\n                if (item.oolType !== 'ConditionalStatement') {\n                    throw new Error('Unsupported exceptional type: ' + item.oolType);\n                }\n\n                let exceptionStartId = createTopoId(compileContext, endTopoId + ':except[' + i.toString() + ']');\n                let exceptionEndId = createTopoId(compileContext, endTopoId + ':except[' + i.toString() + ']:done');\n                if (lastExceptionId) {\n                    dependsOn(compileContext, lastExceptionId, exceptionStartId);\n                }\n\n                let lastTopoId = compileConditionalExpression(item.test, compileContext, exceptionStartId);\n\n                let thenStartId = createTopoId(compileContext, exceptionStartId + ':then');\n                dependsOn(compileContext, lastTopoId, thenStartId);\n                dependsOn(compileContext, thenStartId, exceptionEndId);\n\n                compileContext.astMap[exceptionEndId] = JsLang.astIf(\n                    getCodeRepresentationOf(lastTopoId, compileContext),\n                    JsLang.astBlock(translateReturnThenAst(\n                        thenStartId,\n                        exceptionEndId,\n                        item.then, compileContext)),\n                    null,\n                    `Return on exception #${i}`\n                );\n\n                addCodeBlock(compileContext, exceptionEndId, {\n                    type: AST_BLK_EXCEPTION_ITEM\n                });\n\n                lastExceptionId = exceptionEndId;\n            } else {\n                throw new Error('Unexpected.');\n            }\n        });\n    }\n\n    dependsOn(compileContext, lastExceptionId, endTopoId);\n\n    let returnStartTopoId = createTopoId(compileContext, '$return:value');\n    dependsOn(compileContext, returnStartTopoId, endTopoId);\n\n    compileContext.astMap[endTopoId] = translateReturnValueAst(returnStartTopoId, endTopoId, oolNode.value, compileContext);\n\n    addCodeBlock(compileContext, endTopoId, {\n        type: AST_BLK_INTERFACE_RETURN\n    });\n    \n    return endTopoId;\n}\n\nfunction createTopoId(compileContext, name) {\n    if (compileContext.topoNodes.has(name)) {\n        throw new Error(`Topo id \"${name}\" already created.`);\n    }\n\n    assert: !compileContext.topoSort.hasDependency(name), 'Already in topoSort!';\n\n    compileContext.topoNodes.add(name);\n\n    return name;\n}\n\nfunction dependsOn(compileContext, previousOp, currentOp) {\n    pre: previousOp !== currentOp, 'Self depending';\n\n    compileContext.linker.log('debug', currentOp + ' \\x1b[33mdepends on\\x1b[0m ' + previousOp);\n\n    if (!compileContext.topoNodes.has(currentOp)) {\n        throw new Error(`Topo id \"${currentOp}\" not created.`);\n    }\n\n    compileContext.topoSort.add(previousOp, currentOp);\n}\n\nfunction addCodeBlock(compileContext, topoId, blockMeta) {\n    if (!(topoId in compileContext.astMap)) {\n        throw new Error(`AST not found for block with topoId: ${topoId}`);\n    }\n\n    compileContext.mapOfTokenToMeta.set(topoId, blockMeta);\n\n    compileContext.linker.log('verbose', `Adding ${blockMeta.type} \"${topoId}\" into source code.`);    \n}\n\nfunction getCodeRepresentationOf(topoId, compileContext) {\n    let lastSourceType = compileContext.mapOfTokenToMeta.get(topoId);\n\n    if (lastSourceType && (lastSourceType.type === AST_BLK_PROCESSOR_CALL || lastSourceType.type === AST_BLK_ACTIVATOR_CALL)) {\n        //for modifier, just use the final result\n        return JsLang.astVarRef(lastSourceType.target, true);\n    }\n\n    let ast = compileContext.astMap[topoId];\n    if (ast.type === 'MemberExpression' && ast.object.name === 'latest') {\n        return JsLang.astConditional(\n            JsLang.astCall('latest.hasOwnProperty', [ ast.property.value ]), /** test */\n            ast, /** consequent */\n            { ...ast, object: { ...ast.object, name: 'existing' } }\n        );   \n    }\n\n    return compileContext.astMap[topoId];\n}\n\nfunction createCompileContext(moduleName, linker, sharedContext) {\n    let compileContext = {\n        moduleName,        \n        linker,\n        variables: {},\n        topoNodes: new Set(),\n        topoSort: new TopoSort(),\n        astMap: {}, // Store the AST for a node\n        mapOfTokenToMeta: new Map(), // Store the source code block point\n        modelVars: new Set(),\n        mapOfFunctorToFile: (sharedContext && sharedContext.mapOfFunctorToFile) || {}, // Use to record import lines\n        newFunctorFiles: (sharedContext && sharedContext.newFunctorFiles) || []\n    };\n\n    compileContext.mainStartId = createTopoId(compileContext, '$main');\n\n    linker.log('verbose', `Created compilation context for \"${moduleName}\".`);\n\n    return compileContext;\n}\n\nfunction isTopLevelBlock(topoId) {\n    return topoId.indexOf(':arg[') === -1 && topoId.indexOf('$cases[') === -1 && topoId.indexOf('$exceptions[') === -1;\n}\n\nfunction replaceVarRefScope(varRef, targetScope) {\n    if (_.isPlainObject(varRef)) {\n        assert: varRef.oolType === 'ObjectReference';\n\n        return { oolType: 'ObjectReference', name: replaceVarRefScope(varRef.name, targetScope) };        \n    } \n\n    assert: typeof varRef === 'string';\n\n    let parts = varRef.split('.');\n    assert: parts.length > 1;\n\n    parts.splice(0, 1, targetScope);\n    return parts.join('.');\n}\n\nmodule.exports = {\n    compileParam,\n    compileField,\n    compileDbOperation,\n    compileExceptionalReturn,\n    compileReturn,\n    createTopoId,\n    createCompileContext,\n    dependsOn,\n    addCodeBlock,\n\n    AST_BLK_FIELD_PRE_PROCESS,\n    AST_BLK_PROCESSOR_CALL,\n    AST_BLK_VALIDATOR_CALL,\n    AST_BLK_ACTIVATOR_CALL,\n    AST_BLK_VIEW_OPERATION,\n    AST_BLK_VIEW_RETURN,\n    AST_BLK_INTERFACE_OPERATION,\n    AST_BLK_INTERFACE_RETURN, \n    AST_BLK_EXCEPTION_ITEM,\n\n    OOL_MODIFIER_CODE_FLAG\n};"],"names":["_","require","TopoSort","JsLang","GemlTypes","isDotSeparateName","extractDotSeparateName","extractReferenceBaseName","Types","Validators","Processors","Activators","defaultError","AST_BLK_FIELD_PRE_PROCESS","AST_BLK_PARAM_SANITIZE","AST_BLK_PROCESSOR_CALL","AST_BLK_VALIDATOR_CALL","AST_BLK_ACTIVATOR_CALL","AST_BLK_VIEW_OPERATION","AST_BLK_VIEW_RETURN","AST_BLK_INTERFACE_OPERATION","AST_BLK_INTERFACE_RETURN","AST_BLK_EXCEPTION_ITEM","OOL_MODIFIER_CODE_FLAG","Modifier","VALIDATOR","PROCESSOR","ACTIVATOR","OOL_MODIFIER_OP","OOL_MODIFIER_PATH","OOL_MODIFIER_BUILTIN","OPERATOR_TOKEN","compileConditionalExpression","test","compileContext","startTopoId","isPlainObject","oolType","endTopoId","createTopoId","operandTopoId","dependsOn","lastOperandTopoId","compileConcreteValueExpression","caller","astArgument","getCodeRepresentationOf","retTopoId","compileAdHocValidator","callee","assert","op","operator","Error","leftTopoId","rightTopoId","lastLeftId","left","lastRightId","right","astMap","astBinExp","argument","astNot","astCall","valueStartTopoId","astValue","topoId","value","functor","callArgs","args","translateArgs","arg0","name","concat","compileModifier","declareParams","translateFunctionParams","moduleName","isEmpty","functorId","translateModifier","references","extractReferencedFields","find","ref","astAwait","astVarRef","isTopLevelBlock","startsWith","astConditional","replaceVarRefScope","targetVarName","needDeclare","variables","counter","toString","hasOwnProperty","type","source","addCodeBlock","target","oolArgs","castArray","refs","forEach","a","Array","isArray","result","checkReferenceToField","push","obj","undefined","addModifierToMap","functorType","functorJsFile","mapOfFunctorToFile","functionName","fileName","names","length","refEntityName","upperFirst","builtins","newFunctorFiles","compilePipedValue","varOol","lastTopoId","modifiers","modifier","modifierStartTopoId","compileVariableReference","pre","Set","translateFunctionParam","arg","i","pop","map","baseName","count","has","add","refBase","rest","dependency","ongoing","refFieldName","oorType","translateSymbolToken","mapValues","valueOfElement","key","sid","eid","index","each","argTopoId","compileParam","param","typeObject","sanitizerName","toUpperCase","varRef","callAst","astArrayAccess","prepareTopoId","astAssign","mainStartId","wrapParamReference","readyTopoId","compileField","paramName","contextName","Object","assign","hasModelField","operand","baseVar","split","translateReturnThenAst","startId","endId","then","astThrow","errorType","message","translateReturnValueAst","valueEndId","astReturn","translateThenAst","assignTo","condition","startRightId","valueTopoId","compileReturn","compileFindOne","operation","conditionVarName","ast","astVarDeclare","model","topoIdPrefix","lastStatement","else","elseStart","elseEnd","items","reverse","item","casePrefix","caseTopoId","caseResultVarName","astCaseTtem","ifStart","ifEnd","astIf","astBlock","modelTopoId","compileDbOperation","doBlock","do","compileDoStatement","compileExceptionalReturn","oolNode","lastExceptionId","exceptions","exceptionStartId","exceptionEndId","thenStartId","returnStartTopoId","topoNodes","topoSort","hasDependency","previousOp","currentOp","linker","log","blockMeta","mapOfTokenToMeta","set","lastSourceType","get","object","property","createCompileContext","sharedContext","Map","modelVars","indexOf","targetScope","parts","splice","join","module","exports"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}