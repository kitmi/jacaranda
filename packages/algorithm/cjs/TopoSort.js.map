{"version":3,"sources":["../src/TopoSort.js"],"sourcesContent":["import { _ } from '@kitmi/utils';\n\n/**\n * @class\n */\nclass TopoSort {\n    /**\n     * Map of nodes to a set of nodes as dependents, <string, Set.<string>>\n     * @member {object}\n     */\n    mapOfDependents = {};\n\n    /** -\n     * Map of nodes to a set of nodes as dependencies, <string, Set.<string>>\n     * @member {object}\n     */\n    mapOfDependencies = {};\n\n    /**\n     * Add edges(or one edge, if values is non-array).\n     * @param {string} dependency - Incoming node (dependency)\n     * @param {string|array} dependents - Outgoing node or nodes\n     */\n    add(dependency, newDependents) {\n        // cast to array\n        newDependents = Array.isArray(newDependents) ? newDependents : newDependents == null ? [] : [newDependents];\n\n        // get the existing dependents\n        const dependents = this.mapOfDependents[dependency];\n\n        newDependents.forEach((dependent) => {\n            // get the existing dependencies\n            const dependencies = this.mapOfDependencies[dependent];\n            if (!dependencies) {\n                // new set of dependencies\n                this.mapOfDependencies[dependent] = new Set([dependency]);\n            } else {\n                dependencies.add(dependency);\n            }\n\n            if (dependents) {\n                dependents.add(dependent);\n            }\n        });\n\n        if (!dependents) {\n            // new set of dependents\n            this.mapOfDependents[dependency] = new Set(newDependents);\n        }\n    }\n\n    depends(node, dependencies) {\n        // cast to array\n        dependencies = Array.isArray(dependencies) ? dependencies : dependencies == null ? [] : [dependencies];\n\n        // get the existing dependencies\n        const _dependencies = this.mapOfDependencies[node];\n        if (!_dependencies) {\n            // new set of dependencies\n            this.mapOfDependencies[node] = new Set(dependencies);\n        } else {\n            dependencies.forEach((dependency) => {\n                _dependencies.add(dependency);\n            });\n        }\n\n        // get the existing dependents\n        dependencies.forEach((dependency) => {\n            const dependents = this.mapOfDependents[dependency];\n\n            if (dependents) {\n                dependents.add(node);\n            } else {\n                // new set of dependents\n                this.mapOfDependents[dependency] = new Set([node]);\n            }\n        });\n    }\n\n    hasDependency(node) {\n        return (this.mapOfDependencies[node] && this.mapOfDependencies[node].size > 0) || false;\n    }\n\n    hasDependent(node) {\n        return (this.mapOfDependents[node] && this.mapOfDependents[node].size > 0) || false;\n    }\n\n    /**\n     * Sort the graph. Circular graph throw an error with the circular nodes info.\n     * Implementation of http://en.wikipedia.org/wiki/Topological_sorting#Algorithms\n     * Reference: http://courses.cs.washington.edu/courses/cse326/03wi/lectures/RaoLect20.pdf\n     * @return {Array} Sorted list\n     */\n    sort() {\n        // The list contains the final sorted nodes.\n        const l = [];\n\n        // Find all the initial 0 incoming edge nodes. If not found, this is is a circular graph, cannot be sorted.\n        const nodesWithDependents = Object.keys(this.mapOfDependents);\n        const nodesWithDependencies = Object.keys(this.mapOfDependencies);\n\n        const initialNodes = new Set(nodesWithDependents);\n        nodesWithDependencies.forEach((nodeHasDependency) => initialNodes.delete(nodeHasDependency));\n\n        // List of nodes with no unsorted dependencies\n        const s = [...initialNodes];\n\n        const allNodes = new Set(nodesWithDependents.concat(nodesWithDependencies));\n\n        // number of unsorted nodes. If it is not zero at the end, this graph is a circular graph and cannot be sorted.\n        let unsorted = allNodes.size;\n\n        if (s.length === 0 && (nodesWithDependencies.length === 0 || nodesWithDependents.length === 0)) {\n            // only 1 node in the graph, no need to sort.\n            return Array.from(allNodes);\n        }\n\n        const numWithDependencies = _.mapValues(this.mapOfDependencies, (node) => node.size);\n\n        while (s.length !== 0) {\n            const n = s.shift();\n            l.push(n);\n\n            // decrease unsorted count, node n has been sorted.\n            --unsorted;\n\n            // n node might have no dependency, so have to check it.\n            const dependentsOfN = this.mapOfDependents[n];\n            if (dependentsOfN) {\n                // decease n's adjacent nodes' incoming edges count. If any of them has 0 incoming edges, push them into s get them ready for detaching from the graph.\n                for (const dependentOfN of dependentsOfN) {\n                    if (--numWithDependencies[dependentOfN] === 0) {\n                        // no unsorted dependencies\n                        s.push(dependentOfN);\n                    }\n                }\n            }\n        }\n\n        // If there are unsorted nodes left, this graph is a circular graph and cannot be sorted.\n        // At least 1 circular dependency exist in the nodes with non-zero incoming edges.\n        if (unsorted !== 0) {\n            const circular = [];\n\n            for (const node in numWithDependencies) {\n                if (numWithDependencies[node] !== 0) {\n                    circular.push(node);\n                }\n            }\n\n            throw new Error(\n                'At least 1 circular dependency in nodes: \\n\\n' + circular.join('\\n') + '\\n\\nGraph cannot be sorted!'\n            );\n        }\n\n        return l;\n    }\n}\n\nexport default TopoSort;\n"],"names":["TopoSort","add","dependency","newDependents","Array","isArray","dependents","mapOfDependents","forEach","dependent","dependencies","mapOfDependencies","Set","depends","node","_dependencies","hasDependency","size","hasDependent","sort","l","nodesWithDependents","Object","keys","nodesWithDependencies","initialNodes","nodeHasDependency","delete","s","allNodes","concat","unsorted","length","from","numWithDependencies","_","mapValues","n","shift","push","dependentsOfN","dependentOfN","circular","Error","join"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}