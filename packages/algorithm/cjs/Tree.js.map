{"version":3,"sources":["../src/Tree.js"],"sourcesContent":["import { _ } from '@kitmi/utils';\n\n/**\n * A closure function to be called to check the data of each node whether meets certain condition\n * @callback predicateFunction\n * @param {Node} node\n * @returns {boolean}\n */\n\n/**\n * Tree factory.\n * @param {Node} Node\n * @returns {Tree}\n */\nconst Tree = (Node) =>\n    class extends Node {\n        static Node = Node;\n\n        /**\n         * Find a node by BFS.\n         * @param {predicateFunction} predicate\n         */\n        find(predicate) {\n            let queue = Node.cloneChildrenList(this);\n\n            while (queue.length > 0) {\n                const node = queue.shift();\n\n                if (predicate(node)) return node;\n\n                queue = queue.concat(Node.cloneChildrenList(node));\n            }\n\n            return undefined;\n        }\n    };\n\n/**\n * Tree node with data property.\n * @class\n */\nclass DataNode {\n    static cloneChildrenList(node) {\n        return node.children.concat();\n    }\n\n    /**\n     * Array of children nodes.\n     * @member {array}\n     */\n    children = [];\n\n    /**\n     * Create a data node with given data.\n     * @param {*} data\n     */\n    constructor(data) {\n        /**\n         * Data property.\n         * @member {*}\n         */\n        this.data = data;\n    }\n\n    /**\n     * Number of nodes.\n     * @member {number}\n     */\n    get size() {\n        return this.children.length;\n    }\n\n    /**\n     * Append the given node to the end of the children list.\n     * @param {DataNode} node\n     */\n    append(node) {\n        node.parent = this;\n        this.children.push(node);\n    }\n\n    /**\n     * Insert the given node at specified index in the children list.\n     * @param {number} i\n     * @param {DataNode} node\n     */\n    insert(i, node) {\n        node.parent = this;\n        this.children.splice(Math.max(0, i), 0, node);\n    }\n\n    /**\n     * Remove the given node from the branch.\n     * @param {DataNode} node\n     * @returns {DataNode}\n     */\n    remove(node) {\n        if (node.parent !== this) {\n            throw new Error('Removing a node which is not a child of the current node.');\n        }\n\n        this.children = _.reject(this.children, (n) => n === node);\n        delete node.parent;\n\n        return node;\n    }\n\n    /**\n     * Remove the node at the given index from the branch.\n     * @param {number} i\n     * @returns {DataNode}\n     */\n    removeAtIndex(i) {\n        const [removed] = this.children.splice(i, 1);\n        if (removed) {\n            delete removed.parent;\n        }\n\n        return removed;\n    }\n}\n\n/**\n * Tree node with key property and data property.\n * @class\n */\nclass KeyDataNode {\n    static cloneChildrenList(node) {\n        return Object.values(node.children);\n    }\n\n    /**\n     * Map of keys to children nodes.\n     * @member {object}\n     */\n    children = {};\n\n    /**\n     * Create a key-data node with key and given data.\n     * @param {string} key\n     * @param {*} data\n     */\n    constructor(key, data) {\n        /**\n         * Node key.\n         * @member {string}\n         */\n        this.key = key;\n\n        /**\n         * Data property.\n         * @member {*}\n         */\n        this.data = data;\n    }\n\n    /**\n     * Number of nodes.\n     * @member {number}\n     */\n    get size() {\n        return Object.keys(this.children).length;\n    }\n\n    /**\n     * Fina a node by path being an array of keys.\n     * @param {array.<string>} keys\n     */\n    findByKeyPath(keys) {\n        keys = keys.concat();\n\n        if (keys.length === 0 || keys[0] !== this.key) {\n            return undefined;\n        }\n\n        let value = { children: { [this.key]: this } };\n\n        _.find(keys, (key) => {\n            value = value.children[key];\n            return typeof value === 'undefined';\n        });\n\n        return value;\n    }\n\n    /**\n     * Append data by path being an array of keys.\n     * @param {array.<string>} keys\n     * @param {*} data\n     * @returns {KeyDataNode} The newly created node containing the data.\n     */\n    appendDataByKeyPath(keys, data) {\n        keys = keys.concat();\n\n        if (keys.length === 0 || keys[0] !== this.key) {\n            throw new Error(\n                `The given key path \"${keys.join(' / ')}\" is not starting from the correct initial key \"${this.key}\".`\n            );\n        }\n\n        const lastKey = keys.pop();\n        let lastNode = { children: { [this.key]: this } };\n        let node;\n\n        _.each(keys, (key) => {\n            if (key in lastNode.children) {\n                lastNode = lastNode.children[key];\n            } else {\n                node = new KeyDataNode(key);\n                lastNode.append(node);\n                lastNode = node;\n            }\n        });\n\n        node = new KeyDataNode(lastKey, data);\n        lastNode.append(node);\n\n        return node;\n    }\n\n    /**\n     * Append the given node to the end of the children list.\n     * @param {KeyDataNode} node\n     */\n    append(node) {\n        node.parent = this;\n\n        if (node.key in this.children) {\n            throw new Error(`Duplicate node key: ${node.key}`);\n        }\n\n        this.children[node.key] = node;\n    }\n\n    /**\n     * Remove the given node from the branch.\n     * @param {KeyDataNode} node\n     */\n    remove(node) {\n        if (node.parent !== this || !(node.key in this.children)) {\n            throw new Error('Removing a node which is not a child of the current node.');\n        }\n\n        delete this.children[node.key];\n        delete node.parent;\n\n        return node;\n    }\n\n    /**\n     * Get key path of current node (a key chain from root to itself).\n     * @returns {array}\n     */\n    getKeyPath() {\n        const paths = [this.key];\n        let curr = this;\n\n        while (curr.parent) {\n            curr = curr.parent;\n            paths.push(curr.key);\n        }\n\n        return paths.reverse();\n    }\n}\n\nexport const KeyTree = Tree(KeyDataNode);\n\nexport default Tree(DataNode);\n"],"names":["KeyTree","Tree","Node","find","predicate","queue","cloneChildrenList","length","node","shift","concat","undefined","DataNode","children","size","append","parent","push","insert","i","splice","Math","max","remove","Error","_","reject","n","removeAtIndex","removed","constructor","data","KeyDataNode","Object","values","keys","findByKeyPath","key","value","appendDataByKeyPath","join","lastKey","pop","lastNode","each","getKeyPath","paths","curr","reverse"],"mappings":"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"}