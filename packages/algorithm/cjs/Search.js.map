{"version":3,"sources":["../src/Search.js"],"sourcesContent":["/**\n * Perform a breadth-first search on a graph or tree.\n * @param {Object} root - The root node to start the search from.\n * @param {Function} visit - A function to call for each visited node, return true to end up the search.\n * @param {Function} getChildren - A function to get the children of a node.\n * @returns {Object} The node found\n */\nexport function bfs(root, visit, getChildren) {\n    const queue = Array.isArray(root) ? [...root] : [root];\n    const visited = new Set();\n    visited.add(root);\n\n    let found;\n\n    while (queue.length > 0) {\n        const node = queue.shift();\n        if (visit(node)) {\n            found = node;\n            break;\n        }\n\n        const children = getChildren(node);\n        children?.forEach((child) => {\n            if (!visited.has(child)) {\n                visited.add(child);\n                queue.push(child);\n            }\n        });\n    }\n\n    return found;\n}\n\n/**\n * Perform a depth-first search on a graph or tree.\n * @param {Object} root - The root node to start the search from.\n * @param {Function} visit - A function to call for each visited node, return true to end up the search.\n * @param {Function} getChildren - A function to get the children of a node.\n * @returns {Object} The node found\n */\nexport function dfs(root, visit, getChildren) {\n    const stack = Array.isArray(root) ? [...root].reverse() : [root];\n    const visited = new Set();\n\n    let found;\n\n    while (stack.length > 0) {\n        const node = stack.pop();\n\n        if (!visited.has(node)) {\n            if (visit(node)) {\n                found = node;\n                break;\n            }\n            visited.add(node);\n\n            const children = getChildren(node);\n            if (!children || children.length === 0) {\n                continue;\n            }\n\n            const [leftNode, ...right] = children;\n\n            right.reverse().forEach((child) => {\n                stack.push(child);\n            });\n\n            stack.push(leftNode);\n        }\n    }\n\n    return found;\n}\n"],"names":["bfs","dfs","root","visit","getChildren","queue","Array","isArray","visited","Set","add","found","length","node","shift","children","forEach","child","has","push","stack","reverse","pop","leftNode","right"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"AAAA;;;;;;CAMC;;;;;;;;;;;IACeA,GAAG;eAAHA;;IAiCAC,GAAG;eAAHA;;;AAjCT,SAASD,IAAIE,IAAI,EAAEC,KAAK,EAAEC,WAAW;IACxC,MAAMC,QAAQC,MAAMC,OAAO,CAACL,QAAQ;WAAIA;KAAK,GAAG;QAACA;KAAK;IACtD,MAAMM,UAAU,IAAIC;IACpBD,QAAQE,GAAG,CAACR;IAEZ,IAAIS;IAEJ,MAAON,MAAMO,MAAM,GAAG,EAAG;QACrB,MAAMC,OAAOR,MAAMS,KAAK;QACxB,IAAIX,MAAMU,OAAO;YACbF,QAAQE;YACR;QACJ;QAEA,MAAME,WAAWX,YAAYS;QAC7BE,UAAUC,QAAQ,CAACC;YACf,IAAI,CAACT,QAAQU,GAAG,CAACD,QAAQ;gBACrBT,QAAQE,GAAG,CAACO;gBACZZ,MAAMc,IAAI,CAACF;YACf;QACJ;IACJ;IAEA,OAAON;AACX;AASO,SAASV,IAAIC,IAAI,EAAEC,KAAK,EAAEC,WAAW;IACxC,MAAMgB,QAAQd,MAAMC,OAAO,CAACL,QAAQ;WAAIA;KAAK,CAACmB,OAAO,KAAK;QAACnB;KAAK;IAChE,MAAMM,UAAU,IAAIC;IAEpB,IAAIE;IAEJ,MAAOS,MAAMR,MAAM,GAAG,EAAG;QACrB,MAAMC,OAAOO,MAAME,GAAG;QAEtB,IAAI,CAACd,QAAQU,GAAG,CAACL,OAAO;YACpB,IAAIV,MAAMU,OAAO;gBACbF,QAAQE;gBACR;YACJ;YACAL,QAAQE,GAAG,CAACG;YAEZ,MAAME,WAAWX,YAAYS;YAC7B,IAAI,CAACE,YAAYA,SAASH,MAAM,KAAK,GAAG;gBACpC;YACJ;YAEA,MAAM,CAACW,UAAU,GAAGC,MAAM,GAAGT;YAE7BS,MAAMH,OAAO,GAAGL,OAAO,CAAC,CAACC;gBACrBG,MAAMD,IAAI,CAACF;YACf;YAEAG,MAAMD,IAAI,CAACI;QACf;IACJ;IAEA,OAAOZ;AACX"}