{"version":3,"sources":["../src/transform.js"],"sourcesContent":["// JSON Expression Syntax (JES)\nimport { get as _get, set as _set, isInteger } from '@kitmi/utils';\n\nimport _isEmpty from 'lodash/isEmpty';\nimport _reduce from 'lodash/reduce';\nimport _map from 'lodash/map';\nimport _mapValues from 'lodash/mapValues';\n\nimport { initContext, getChildContext } from './config';\nimport { isOperator } from './utils';\nimport ops from './transformerOperators';\n\nexport const processExprLikeValue = (exprLikeValue, context) =>\n    typeof exprLikeValue === 'object' && exprLikeValue?.$expr !== undefined\n        ? transform(undefined, exprLikeValue.$expr, context)\n        : exprLikeValue;\n\nexport const processExprLikeValueWithLeft = (left, exprLikeValue, context) =>\ntypeof exprLikeValue === 'object' && exprLikeValue?.$expr !== undefined\n    ? transform(left, exprLikeValue.$expr, context)\n    : exprLikeValue;\n    \n\nconst PFX_MAP = '|>'; // map\nconst PFX_REDUCE = '|+'; // reduce 1. intermediate = result op [key, value] 2. result = result op intermediate\n\n/**\n * Apply a bianry operator to a value\n * @param {*} value\n * @param {*} op\n * @param {*} opValue\n * @param {*} context\n * @returns {*}\n */\nfunction applyBinaryOperator(value, op, opValue, context) {\n    const handler = context.config.getTransformer(op);\n\n    if (!handler) {\n        throw new Error(context.config.messages.INVALID_TRANSFORMER_HANDLER(op));\n    }\n\n    return handler(value, opValue, context);\n}\n\n/**\n * Apply an unary operator to a value\n * @param {*} value\n * @param {*} tag\n * @param {*} context\n * @returns {*}\n */\nfunction applyUnaryOperator(value, tag, context) {\n    const handler = context.config.getTransformer(tag);\n\n    if (!handler) {\n        throw new Error(context.config.messages.INVALID_TRANSFORMER_HANDLER(tag));\n    }\n\n    return handler(value, context);\n}\n\n/**\n * Apply an operator to a value with operator meta\n * @param {*} currentValue\n * @param {*} rightValue\n * @param {*} opMeta\n * @param {*} context\n * @returns {*}\n */\nfunction applyOperator(currentValue, rightValue, [op, isUnary], context) {\n    if (isUnary) {\n        return applyUnaryOperator(currentValue, op, context);\n    }\n\n    return applyBinaryOperator(currentValue, op, rightValue, context);\n}\n\n/**\n * Apply an collection iteration operator with operator meta\n * @param {*} currentValue\n * @param {*} collectionOp\n * @param {*} opMeta\n * @param {*} expectedFieldValue\n * @param {*} context\n * @returns {*}\n */\nfunction transformCollection(currentValue, collectionOp, opMeta, expectedFieldValue, context) {\n    const isUnary = opMeta[1];\n\n    switch (collectionOp) {\n        case PFX_MAP:\n            return (Array.isArray(currentValue) ? _map : _mapValues)(currentValue, (item, key) =>\n                applyOperator(item, expectedFieldValue, opMeta, getChildContext(context, currentValue, key, item))\n            );\n\n        case PFX_REDUCE:\n            if (!Array.isArray(expectedFieldValue) || (isUnary && expectedFieldValue.length !== 1)) {\n                throw new Error(\n                    context.config.messages.INVALID_COLLECTION_OP_EXPR(ops.REDUCE, opMeta[0], expectedFieldValue)\n                );\n            }\n\n            return _reduce(\n                currentValue,\n                (result, item, key) =>\n                    applyOperator(\n                        result,\n                        expectedFieldValue[1],\n                        opMeta,\n                        getChildContext(context, currentValue, key, item)\n                    ),\n                expectedFieldValue[0]\n            );\n\n        default:\n            throw new Error(context.config.messages.INVALID_COLLECTION_OP(collectionOp));\n    }\n}\n\n/**\n * If $ operator used, only one a time is allowed\n * e.g.\n * {\n *    $groupBy: 'key'\n * }\n *\n *\n * @param {*} currentValue\n * @param {*} jsx\n * @param {*} context\n * @param {boolean} replaceLeft - Whether the expression will replace the left value chain, like a setOp\n * @return {*}\n */\nfunction transform(currentValue, jsx, context, replaceLeft) {\n    // Null jsx means\n    //  - no change if replaceLeft is false\n    //  - undefined if replaceLeft is true\n    if (jsx == null) {\n        return replaceLeft ? jsx : currentValue;\n    }\n\n    context = initContext(context, currentValue);\n\n    if (Array.isArray(jsx)) {\n        if (replaceLeft) {\n            return jsx.map((item) => transform(undefined, item, context, true));\n        }\n\n        return jsx.reduce((result, exprItem) => transform(result, exprItem, context), currentValue);\n    }\n\n    const typeExpr = typeof jsx;\n\n    if (typeExpr === 'boolean') {\n        if (replaceLeft) {\n            return jsx;\n        }\n\n        return jsx ? currentValue : undefined;\n    }\n\n    if (typeExpr === 'number' || typeExpr === 'bigint') {\n        if (replaceLeft) {\n            return jsx;\n        }\n\n        if (isInteger(jsx) && Array.isArray(currentValue)) {\n            return currentValue[jsx];\n        }\n\n        throw new Error(context.config.messages.SYNTAX_NUMBER_AS_EXPR);\n    }\n\n    if (typeExpr === 'string') {\n        if (replaceLeft) {\n            return jsx;\n        }        \n\n        if (isOperator(jsx)) {\n            const posDot = jsx.indexOf('.');\n            if (posDot !== -1) {\n                const arrayOp = [ jsx.substring(0, posDot), jsx.substring(posDot + 1) ];\n                if (context.config.getTransformerTagAndType(arrayOp[0]) != null) {\n                    return transform(currentValue, [ arrayOp[0], { $valueOf: arrayOp[1] } ], context);\n                }\n            }            \n\n            const opMeta = context.config.getTransformerTagAndType(jsx);\n            if (!opMeta) {\n                throw new Error(context.config.messages.INVALID_TRANSFORMER_OP(jsx));\n            }\n\n            if (!opMeta[1]) {\n                return applyBinaryOperator(currentValue, opMeta[0], null, context);\n            }\n\n            return applyUnaryOperator(currentValue, opMeta[0], context);\n        }\n\n        if (currentValue != null && typeof currentValue !== 'object') {\n            throw new Error(context.config.messages.SYNTAX_INVALID_EXPR(jsx));\n        }\n\n        return _get(currentValue, jsx);\n    }\n\n    if (typeExpr !== 'object') {\n        throw new Error(context.config.messages.SYNTAX_INVALID_EXPR(jsx));\n    }\n\n    if (replaceLeft) {\n        return _mapValues(jsx, (item) => transform(undefined, item, context, true));\n    }\n\n    let result,\n        hasOperator = false;\n\n    for (let fieldName in jsx) {\n        let expectedFieldValue = jsx[fieldName];\n\n        const l = fieldName.length;\n\n        if (l > 1) {\n            if (fieldName[0] === '$') {\n                if (result) {\n                    throw new Error(context.config.messages.SYNTAX_OP_NOT_ALONE);\n                }\n\n                const opMeta = context.config.getTransformerTagAndType(fieldName);\n                if (!opMeta) {\n                    throw new Error(context.config.messages.INVALID_TRANSFORMER_OP(fieldName));\n                }\n\n                if (hasOperator) {\n                    throw new Error(context.config.messages.SYNTAX_OP_NOT_ALONE);\n                }\n\n                result = applyOperator(currentValue, expectedFieldValue, opMeta, context);\n                hasOperator = true;\n                continue;\n            }\n\n            if (l > 3 && fieldName[0] === '|' && fieldName[2] === '$') {\n                if (result) {\n                    throw new Error(context.config.messages.SYNTAX_OP_NOT_ALONE);\n                }\n\n                const collectionOp = fieldName.substring(0, 2);\n                fieldName = fieldName.substring(2);\n\n                const opMeta = context.config.getTransformerTagAndType(fieldName);\n                if (!opMeta) {\n                    throw new Error(context.config.messages.INVALID_TRANSFORMER_OP(fieldName));\n                }\n\n                if (hasOperator) {\n                    throw new Error(context.config.messages.SYNTAX_OP_NOT_ALONE);\n                }\n\n                result = transformCollection(currentValue, collectionOp, opMeta, expectedFieldValue, context);\n                hasOperator = true;\n                continue;\n            }\n        }\n\n        if (hasOperator) {\n            throw new Error(context.config.messages.SYNTAX_OP_NOT_ALONE);\n        }\n\n        let complexKey = fieldName.indexOf('.') !== -1;\n\n        //pick a field and then apply manipulation\n        let actualFieldValue =\n            currentValue != null ? (complexKey ? _get(currentValue, fieldName) : currentValue[fieldName]) : undefined;\n\n        const childFieldValue = transform(\n            actualFieldValue,\n            expectedFieldValue,\n            getChildContext(context, currentValue, fieldName, actualFieldValue)\n        );\n\n        if (typeof childFieldValue !== 'undefined') {\n            result == null && (result = {});\n            if (complexKey) {\n                _set(result, fieldName, childFieldValue);\n            } else {\n                result[fieldName] = childFieldValue;\n            }\n        }\n    }\n\n    return result;\n}\n\nexport default transform;\n"],"names":["processExprLikeValue","processExprLikeValueWithLeft","exprLikeValue","context","$expr","undefined","transform","left","PFX_MAP","PFX_REDUCE","applyBinaryOperator","value","op","opValue","handler","config","getTransformer","Error","messages","INVALID_TRANSFORMER_HANDLER","applyUnaryOperator","tag","applyOperator","currentValue","rightValue","isUnary","transformCollection","collectionOp","opMeta","expectedFieldValue","Array","isArray","_map","_mapValues","item","key","getChildContext","length","INVALID_COLLECTION_OP_EXPR","ops","REDUCE","_reduce","result","INVALID_COLLECTION_OP","jsx","replaceLeft","initContext","map","reduce","exprItem","typeExpr","isInteger","SYNTAX_NUMBER_AS_EXPR","isOperator","posDot","indexOf","arrayOp","substring","getTransformerTagAndType","$valueOf","INVALID_TRANSFORMER_OP","SYNTAX_INVALID_EXPR","_get","hasOperator","fieldName","l","SYNTAX_OP_NOT_ALONE","complexKey","actualFieldValue","childFieldValue","_set"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"AAAA,+BAA+B;;;;;;;;;;;;IAsS/B,OAAyB;eAAzB;;IA1RaA,oBAAoB;eAApBA;;IAKAC,4BAA4B;eAA5BA;;;uBAhBuC;gEAE/B;+DACD;4DACH;kEACM;wBAEsB;wBAClB;6EACX;;;;;;AAET,MAAMD,uBAAuB,CAACE,eAAeC,UAChD,OAAOD,kBAAkB,YAAYA,eAAeE,UAAUC,YACxDC,UAAUD,WAAWH,cAAcE,KAAK,EAAED,WAC1CD;AAEH,MAAMD,+BAA+B,CAACM,MAAML,eAAeC,UAClE,OAAOD,kBAAkB,YAAYA,eAAeE,UAAUC,YACxDC,UAAUC,MAAML,cAAcE,KAAK,EAAED,WACrCD;AAGN,MAAMM,UAAU,MAAM,MAAM;AAC5B,MAAMC,aAAa,MAAM,qFAAqF;AAE9G;;;;;;;CAOC,GACD,SAASC,oBAAoBC,KAAK,EAAEC,EAAE,EAAEC,OAAO,EAAEV,OAAO;IACpD,MAAMW,UAAUX,QAAQY,MAAM,CAACC,cAAc,CAACJ;IAE9C,IAAI,CAACE,SAAS;QACV,MAAM,IAAIG,MAAMd,QAAQY,MAAM,CAACG,QAAQ,CAACC,2BAA2B,CAACP;IACxE;IAEA,OAAOE,QAAQH,OAAOE,SAASV;AACnC;AAEA;;;;;;CAMC,GACD,SAASiB,mBAAmBT,KAAK,EAAEU,GAAG,EAAElB,OAAO;IAC3C,MAAMW,UAAUX,QAAQY,MAAM,CAACC,cAAc,CAACK;IAE9C,IAAI,CAACP,SAAS;QACV,MAAM,IAAIG,MAAMd,QAAQY,MAAM,CAACG,QAAQ,CAACC,2BAA2B,CAACE;IACxE;IAEA,OAAOP,QAAQH,OAAOR;AAC1B;AAEA;;;;;;;CAOC,GACD,SAASmB,cAAcC,YAAY,EAAEC,UAAU,EAAE,CAACZ,IAAIa,QAAQ,EAAEtB,OAAO;IACnE,IAAIsB,SAAS;QACT,OAAOL,mBAAmBG,cAAcX,IAAIT;IAChD;IAEA,OAAOO,oBAAoBa,cAAcX,IAAIY,YAAYrB;AAC7D;AAEA;;;;;;;;CAQC,GACD,SAASuB,oBAAoBH,YAAY,EAAEI,YAAY,EAAEC,MAAM,EAAEC,kBAAkB,EAAE1B,OAAO;IACxF,MAAMsB,UAAUG,MAAM,CAAC,EAAE;IAEzB,OAAQD;QACJ,KAAKnB;YACD,OAAO,AAACsB,CAAAA,MAAMC,OAAO,CAACR,gBAAgBS,YAAI,GAAGC,kBAAU,AAAD,EAAGV,cAAc,CAACW,MAAMC,MAC1Eb,cAAcY,MAAML,oBAAoBD,QAAQQ,IAAAA,uBAAe,EAACjC,SAASoB,cAAcY,KAAKD;QAGpG,KAAKzB;YACD,IAAI,CAACqB,MAAMC,OAAO,CAACF,uBAAwBJ,WAAWI,mBAAmBQ,MAAM,KAAK,GAAI;gBACpF,MAAM,IAAIpB,MACNd,QAAQY,MAAM,CAACG,QAAQ,CAACoB,0BAA0B,CAACC,6BAAG,CAACC,MAAM,EAAEZ,MAAM,CAAC,EAAE,EAAEC;YAElF;YAEA,OAAOY,IAAAA,eAAO,EACVlB,cACA,CAACmB,QAAQR,MAAMC,MACXb,cACIoB,QACAb,kBAAkB,CAAC,EAAE,EACrBD,QACAQ,IAAAA,uBAAe,EAACjC,SAASoB,cAAcY,KAAKD,QAEpDL,kBAAkB,CAAC,EAAE;QAG7B;YACI,MAAM,IAAIZ,MAAMd,QAAQY,MAAM,CAACG,QAAQ,CAACyB,qBAAqB,CAAChB;IACtE;AACJ;AAEA;;;;;;;;;;;;;CAaC,GACD,SAASrB,UAAUiB,YAAY,EAAEqB,GAAG,EAAEzC,OAAO,EAAE0C,WAAW;IACtD,iBAAiB;IACjB,uCAAuC;IACvC,sCAAsC;IACtC,IAAID,OAAO,MAAM;QACb,OAAOC,cAAcD,MAAMrB;IAC/B;IAEApB,UAAU2C,IAAAA,mBAAW,EAAC3C,SAASoB;IAE/B,IAAIO,MAAMC,OAAO,CAACa,MAAM;QACpB,IAAIC,aAAa;YACb,OAAOD,IAAIG,GAAG,CAAC,CAACb,OAAS5B,UAAUD,WAAW6B,MAAM/B,SAAS;QACjE;QAEA,OAAOyC,IAAII,MAAM,CAAC,CAACN,QAAQO,WAAa3C,UAAUoC,QAAQO,UAAU9C,UAAUoB;IAClF;IAEA,MAAM2B,WAAW,OAAON;IAExB,IAAIM,aAAa,WAAW;QACxB,IAAIL,aAAa;YACb,OAAOD;QACX;QAEA,OAAOA,MAAMrB,eAAelB;IAChC;IAEA,IAAI6C,aAAa,YAAYA,aAAa,UAAU;QAChD,IAAIL,aAAa;YACb,OAAOD;QACX;QAEA,IAAIO,IAAAA,gBAAS,EAACP,QAAQd,MAAMC,OAAO,CAACR,eAAe;YAC/C,OAAOA,YAAY,CAACqB,IAAI;QAC5B;QAEA,MAAM,IAAI3B,MAAMd,QAAQY,MAAM,CAACG,QAAQ,CAACkC,qBAAqB;IACjE;IAEA,IAAIF,aAAa,UAAU;QACvB,IAAIL,aAAa;YACb,OAAOD;QACX;QAEA,IAAIS,IAAAA,kBAAU,EAACT,MAAM;YACjB,MAAMU,SAASV,IAAIW,OAAO,CAAC;YAC3B,IAAID,WAAW,CAAC,GAAG;gBACf,MAAME,UAAU;oBAAEZ,IAAIa,SAAS,CAAC,GAAGH;oBAASV,IAAIa,SAAS,CAACH,SAAS;iBAAI;gBACvE,IAAInD,QAAQY,MAAM,CAAC2C,wBAAwB,CAACF,OAAO,CAAC,EAAE,KAAK,MAAM;oBAC7D,OAAOlD,UAAUiB,cAAc;wBAAEiC,OAAO,CAAC,EAAE;wBAAE;4BAAEG,UAAUH,OAAO,CAAC,EAAE;wBAAC;qBAAG,EAAErD;gBAC7E;YACJ;YAEA,MAAMyB,SAASzB,QAAQY,MAAM,CAAC2C,wBAAwB,CAACd;YACvD,IAAI,CAAChB,QAAQ;gBACT,MAAM,IAAIX,MAAMd,QAAQY,MAAM,CAACG,QAAQ,CAAC0C,sBAAsB,CAAChB;YACnE;YAEA,IAAI,CAAChB,MAAM,CAAC,EAAE,EAAE;gBACZ,OAAOlB,oBAAoBa,cAAcK,MAAM,CAAC,EAAE,EAAE,MAAMzB;YAC9D;YAEA,OAAOiB,mBAAmBG,cAAcK,MAAM,CAAC,EAAE,EAAEzB;QACvD;QAEA,IAAIoB,gBAAgB,QAAQ,OAAOA,iBAAiB,UAAU;YAC1D,MAAM,IAAIN,MAAMd,QAAQY,MAAM,CAACG,QAAQ,CAAC2C,mBAAmB,CAACjB;QAChE;QAEA,OAAOkB,IAAAA,UAAI,EAACvC,cAAcqB;IAC9B;IAEA,IAAIM,aAAa,UAAU;QACvB,MAAM,IAAIjC,MAAMd,QAAQY,MAAM,CAACG,QAAQ,CAAC2C,mBAAmB,CAACjB;IAChE;IAEA,IAAIC,aAAa;QACb,OAAOZ,IAAAA,kBAAU,EAACW,KAAK,CAACV,OAAS5B,UAAUD,WAAW6B,MAAM/B,SAAS;IACzE;IAEA,IAAIuC,QACAqB,cAAc;IAElB,IAAK,IAAIC,aAAapB,IAAK;QACvB,IAAIf,qBAAqBe,GAAG,CAACoB,UAAU;QAEvC,MAAMC,IAAID,UAAU3B,MAAM;QAE1B,IAAI4B,IAAI,GAAG;YACP,IAAID,SAAS,CAAC,EAAE,KAAK,KAAK;gBACtB,IAAItB,QAAQ;oBACR,MAAM,IAAIzB,MAAMd,QAAQY,MAAM,CAACG,QAAQ,CAACgD,mBAAmB;gBAC/D;gBAEA,MAAMtC,SAASzB,QAAQY,MAAM,CAAC2C,wBAAwB,CAACM;gBACvD,IAAI,CAACpC,QAAQ;oBACT,MAAM,IAAIX,MAAMd,QAAQY,MAAM,CAACG,QAAQ,CAAC0C,sBAAsB,CAACI;gBACnE;gBAEA,IAAID,aAAa;oBACb,MAAM,IAAI9C,MAAMd,QAAQY,MAAM,CAACG,QAAQ,CAACgD,mBAAmB;gBAC/D;gBAEAxB,SAASpB,cAAcC,cAAcM,oBAAoBD,QAAQzB;gBACjE4D,cAAc;gBACd;YACJ;YAEA,IAAIE,IAAI,KAAKD,SAAS,CAAC,EAAE,KAAK,OAAOA,SAAS,CAAC,EAAE,KAAK,KAAK;gBACvD,IAAItB,QAAQ;oBACR,MAAM,IAAIzB,MAAMd,QAAQY,MAAM,CAACG,QAAQ,CAACgD,mBAAmB;gBAC/D;gBAEA,MAAMvC,eAAeqC,UAAUP,SAAS,CAAC,GAAG;gBAC5CO,YAAYA,UAAUP,SAAS,CAAC;gBAEhC,MAAM7B,SAASzB,QAAQY,MAAM,CAAC2C,wBAAwB,CAACM;gBACvD,IAAI,CAACpC,QAAQ;oBACT,MAAM,IAAIX,MAAMd,QAAQY,MAAM,CAACG,QAAQ,CAAC0C,sBAAsB,CAACI;gBACnE;gBAEA,IAAID,aAAa;oBACb,MAAM,IAAI9C,MAAMd,QAAQY,MAAM,CAACG,QAAQ,CAACgD,mBAAmB;gBAC/D;gBAEAxB,SAAShB,oBAAoBH,cAAcI,cAAcC,QAAQC,oBAAoB1B;gBACrF4D,cAAc;gBACd;YACJ;QACJ;QAEA,IAAIA,aAAa;YACb,MAAM,IAAI9C,MAAMd,QAAQY,MAAM,CAACG,QAAQ,CAACgD,mBAAmB;QAC/D;QAEA,IAAIC,aAAaH,UAAUT,OAAO,CAAC,SAAS,CAAC;QAE7C,0CAA0C;QAC1C,IAAIa,mBACA7C,gBAAgB,OAAQ4C,aAAaL,IAAAA,UAAI,EAACvC,cAAcyC,aAAazC,YAAY,CAACyC,UAAU,GAAI3D;QAEpG,MAAMgE,kBAAkB/D,UACpB8D,kBACAvC,oBACAO,IAAAA,uBAAe,EAACjC,SAASoB,cAAcyC,WAAWI;QAGtD,IAAI,OAAOC,oBAAoB,aAAa;YACxC3B,UAAU,QAASA,CAAAA,SAAS,CAAC,CAAA;YAC7B,IAAIyB,YAAY;gBACZG,IAAAA,UAAI,EAAC5B,QAAQsB,WAAWK;YAC5B,OAAO;gBACH3B,MAAM,CAACsB,UAAU,GAAGK;YACxB;QACJ;IACJ;IAEA,OAAO3B;AACX;MAEA,WAAepC"}