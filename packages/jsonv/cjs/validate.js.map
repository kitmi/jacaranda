{"version":3,"sources":["../src/validate.js"],"sourcesContent":["// JSON Validation Syntax\nimport { get as _get } from '@kitmi/utils';\nimport JsvError from './JsvError';\nimport { initContext, getChildContext } from './config';\nimport { isOperator } from './utils';\nimport ops from './validateOperators';\nimport transform from './transform'\n\nfunction getUnmatchedExplanation(op, leftValue, rightValue, context) {\n    if (context.ERROR) {\n        return context.ERROR;\n    }\n\n    const formatter = context.config.messages.validationErrors?.[op];\n    if (formatter == null) {\n        throw new Error('Missing validation error formatter for operator: ' + op);\n    }\n    \n    return formatter(context.name, leftValue, rightValue, context);\n}\n\n/**\n * Tests whether a left-hand value satisfies a given operator and right-hand value.\n * @param {*} left - The left-hand value to test.\n * @param {string} op - The operator to use for the test.\n * @param {*} right - The right-hand value to test against.\n * @param {Object} options - Options to use for the test.\n * @param {Object} context - The current context of the data structure being validated.\n * @returns {*} The result of the test.\n * @throws {Error} If the specified operator does not have a registered validator.\n */\nexport function test(left, op, right, options, context) {\n    const handler = context.config.getValidator(op);\n\n    if (!handler) {\n        throw new Error(context.config.messages.INVALID_TEST_HANLDER(op));\n    }\n\n    return handler(left, right, options, context);\n}\n\n/**\n * Validate the given object with JSON Expression Syntax (JES)\n * @param {*} actual - The object to match\n * @param {*} jsv - Expected state in JSON Expression Syntax\n * @param {*} options - Validation options\n * @param {*} context - Validation context\n * @returns {array} - [ {boolean} matched, {string} unmatchedReason ]\n */\nfunction validate(actual, jsv, options, context) {\n    if (jsv == null) {\n        return true;\n    }\n\n    context = initContext(context, actual);\n\n    const type = typeof jsv;\n\n    if (type === 'string') {\n        if (!isOperator(jsv)) {\n            throw new Error(context.config.messages.SYNTAX_INVALID_EXPR(jsv));\n        }\n\n        return validate(actual, { [jsv]: null }, options, context);\n    }\n\n    const { throwError, abortEarly, asPredicate, plainError } = options;\n\n    if (Array.isArray(jsv)) {\n        return validate(actual, { $all: jsv }, options, context);\n    }\n\n    if (type !== 'object') {\n        return validate(actual, { $equal: jsv }, options, context);\n    }\n\n    let { path } = context;\n    const errors = [];\n    const _options = !abortEarly && throwError ? { ...options, throwError: false } : options;\n\n    for (let fieldName in jsv) {\n        let op, left, _context;\n\n        const opValue = jsv[fieldName];\n\n        if (isOperator(fieldName)) {\n            //validator\n            op = context.config.getValidatorTag(fieldName);\n            if (!op) {\n                throw new Error(context.config.messages.UNSUPPORTED_VALIDATION_OP(fieldName, path));\n            }\n\n            left = actual;\n            _context = context;\n        } else {\n            let isComplexKey = fieldName.indexOf('.') !== -1;\n\n            //pick a field and then apply manipulation\n            left = actual != null ? (isComplexKey ? _get(actual, fieldName) : actual[fieldName]) : undefined;\n\n            _context = getChildContext(context, actual, fieldName, left);\n\n            if (opValue != null && typeof opValue === 'object') {\n                op = ops.MATCH;\n            } else {\n                op = ops.EQUAL;\n            }\n        }\n\n        if (test(left, op, opValue, _options, _context) !== true) {\n            if (asPredicate) {\n                return false;\n            }\n\n            const reason = getUnmatchedExplanation(op, left, opValue, _context);\n            if (abortEarly && throwError) {\n                throw new JsvError(reason, left, _context.path);\n            }\n\n            errors.push(plainError ? reason : new JsvError(reason, left, _context.path));\n            if (abortEarly) {\n                break;\n            }\n        }\n    }\n\n    if (errors.length > 0) {\n        if (asPredicate) {\n            return false;\n        }\n\n        if (throwError) {\n            throw new JsvError(errors, actual, path);\n        }\n\n        return errors.length === 1 && plainError ? errors[0] : errors;\n    }\n\n    return true;\n}\n\nexport default validate;\n"],"names":["test","getUnmatchedExplanation","op","leftValue","rightValue","context","ERROR","formatter","config","messages","validationErrors","Error","name","left","right","options","handler","getValidator","INVALID_TEST_HANLDER","validate","actual","jsv","initContext","type","isOperator","SYNTAX_INVALID_EXPR","throwError","abortEarly","asPredicate","plainError","Array","isArray","$all","$equal","path","errors","_options","fieldName","_context","opValue","getValidatorTag","UNSUPPORTED_VALIDATION_OP","isComplexKey","indexOf","_get","undefined","getChildContext","ops","MATCH","EQUAL","reason","JsvError","push","length"],"mappings":"AAAA,yBAAyB;;;;;;;;;;;;IA6IzB,OAAwB;eAAxB;;IA9GgBA,IAAI;eAAJA;;;uBA9BY;iEACP;wBACwB;wBAClB;0EACX;kEACM;;;;;;AAEtB,SAASC,wBAAwBC,EAAE,EAAEC,SAAS,EAAEC,UAAU,EAAEC,OAAO;IAC/D,IAAIA,QAAQC,KAAK,EAAE;QACf,OAAOD,QAAQC,KAAK;IACxB;IAEA,MAAMC,YAAYF,QAAQG,MAAM,CAACC,QAAQ,CAACC,gBAAgB,EAAE,CAACR,GAAG;IAChE,IAAIK,aAAa,MAAM;QACnB,MAAM,IAAII,MAAM,sDAAsDT;IAC1E;IAEA,OAAOK,UAAUF,QAAQO,IAAI,EAAET,WAAWC,YAAYC;AAC1D;AAYO,SAASL,KAAKa,IAAI,EAAEX,EAAE,EAAEY,KAAK,EAAEC,OAAO,EAAEV,OAAO;IAClD,MAAMW,UAAUX,QAAQG,MAAM,CAACS,YAAY,CAACf;IAE5C,IAAI,CAACc,SAAS;QACV,MAAM,IAAIL,MAAMN,QAAQG,MAAM,CAACC,QAAQ,CAACS,oBAAoB,CAAChB;IACjE;IAEA,OAAOc,QAAQH,MAAMC,OAAOC,SAASV;AACzC;AAEA;;;;;;;CAOC,GACD,SAASc,SAASC,MAAM,EAAEC,GAAG,EAAEN,OAAO,EAAEV,OAAO;IAC3C,IAAIgB,OAAO,MAAM;QACb,OAAO;IACX;IAEAhB,UAAUiB,IAAAA,mBAAW,EAACjB,SAASe;IAE/B,MAAMG,OAAO,OAAOF;IAEpB,IAAIE,SAAS,UAAU;QACnB,IAAI,CAACC,IAAAA,kBAAU,EAACH,MAAM;YAClB,MAAM,IAAIV,MAAMN,QAAQG,MAAM,CAACC,QAAQ,CAACgB,mBAAmB,CAACJ;QAChE;QAEA,OAAOF,SAASC,QAAQ;YAAE,CAACC,IAAI,EAAE;QAAK,GAAGN,SAASV;IACtD;IAEA,MAAM,EAAEqB,UAAU,EAAEC,UAAU,EAAEC,WAAW,EAAEC,UAAU,EAAE,GAAGd;IAE5D,IAAIe,MAAMC,OAAO,CAACV,MAAM;QACpB,OAAOF,SAASC,QAAQ;YAAEY,MAAMX;QAAI,GAAGN,SAASV;IACpD;IAEA,IAAIkB,SAAS,UAAU;QACnB,OAAOJ,SAASC,QAAQ;YAAEa,QAAQZ;QAAI,GAAGN,SAASV;IACtD;IAEA,IAAI,EAAE6B,IAAI,EAAE,GAAG7B;IACf,MAAM8B,SAAS,EAAE;IACjB,MAAMC,WAAW,CAACT,cAAcD,aAAa;QAAE,GAAGX,OAAO;QAAEW,YAAY;IAAM,IAAIX;IAEjF,IAAK,IAAIsB,aAAahB,IAAK;QACvB,IAAInB,IAAIW,MAAMyB;QAEd,MAAMC,UAAUlB,GAAG,CAACgB,UAAU;QAE9B,IAAIb,IAAAA,kBAAU,EAACa,YAAY;YACvB,WAAW;YACXnC,KAAKG,QAAQG,MAAM,CAACgC,eAAe,CAACH;YACpC,IAAI,CAACnC,IAAI;gBACL,MAAM,IAAIS,MAAMN,QAAQG,MAAM,CAACC,QAAQ,CAACgC,yBAAyB,CAACJ,WAAWH;YACjF;YAEArB,OAAOO;YACPkB,WAAWjC;QACf,OAAO;YACH,IAAIqC,eAAeL,UAAUM,OAAO,CAAC,SAAS,CAAC;YAE/C,0CAA0C;YAC1C9B,OAAOO,UAAU,OAAQsB,eAAeE,IAAAA,UAAI,EAACxB,QAAQiB,aAAajB,MAAM,CAACiB,UAAU,GAAIQ;YAEvFP,WAAWQ,IAAAA,uBAAe,EAACzC,SAASe,QAAQiB,WAAWxB;YAEvD,IAAI0B,WAAW,QAAQ,OAAOA,YAAY,UAAU;gBAChDrC,KAAK6C,0BAAG,CAACC,KAAK;YAClB,OAAO;gBACH9C,KAAK6C,0BAAG,CAACE,KAAK;YAClB;QACJ;QAEA,IAAIjD,KAAKa,MAAMX,IAAIqC,SAASH,UAAUE,cAAc,MAAM;YACtD,IAAIV,aAAa;gBACb,OAAO;YACX;YAEA,MAAMsB,SAASjD,wBAAwBC,IAAIW,MAAM0B,SAASD;YAC1D,IAAIX,cAAcD,YAAY;gBAC1B,MAAM,IAAIyB,iBAAQ,CAACD,QAAQrC,MAAMyB,SAASJ,IAAI;YAClD;YAEAC,OAAOiB,IAAI,CAACvB,aAAaqB,SAAS,IAAIC,iBAAQ,CAACD,QAAQrC,MAAMyB,SAASJ,IAAI;YAC1E,IAAIP,YAAY;gBACZ;YACJ;QACJ;IACJ;IAEA,IAAIQ,OAAOkB,MAAM,GAAG,GAAG;QACnB,IAAIzB,aAAa;YACb,OAAO;QACX;QAEA,IAAIF,YAAY;YACZ,MAAM,IAAIyB,iBAAQ,CAAChB,QAAQf,QAAQc;QACvC;QAEA,OAAOC,OAAOkB,MAAM,KAAK,KAAKxB,aAAaM,MAAM,CAAC,EAAE,GAAGA;IAC3D;IAEA,OAAO;AACX;MAEA,WAAehB"}