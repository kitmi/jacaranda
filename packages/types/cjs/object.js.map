{"version":3,"sources":["../src/object.js"],"sourcesContent":["import _each from 'lodash/each';\nimport _every from 'lodash/every';\nimport _mapValues from 'lodash/mapValues';\nimport { ValidationError } from './errors';\nimport { makePath } from '@kit/utils/objectPathUtils';\nimport isPlainObject from '@kit/utils/isPlainObject';\nimport batchAsync_ from '@kit/utils/batchAsync_';\nimport findAsync_ from '@kit/utils/findAsync_';\n\nconst jsonStarter = new Set(['\"', '[', '{']);\nconst jsonEnding = {\n    '\"': '\"',\n    '[': ']',\n    '{': '}',\n};\n\nclass T_OBJECT {\n    name = 'object';\n    alias = ['json'];\n    primitive = true;\n    defaultValue = {};\n\n    _sanitizeMember = (value, opts, newValue) => (validationObject, fieldName) => {\n        const fieldValue = value[fieldName];\n        const fieldPath = makePath(opts.path, fieldName);\n\n        let _fieldValue;\n\n        if (Array.isArray(validationObject)) {\n            const errors = [];\n            const foudMatched = validationObject.find((_validationObject) => {\n                try {\n                    _fieldValue = this.system.sanitize(fieldValue, _validationObject, opts.i18n, fieldPath);\n                    return true;\n                } catch (error) {\n                    errors.push(ValidationError.extractFromError(error));\n                    return false;\n                }\n            });\n\n            if (foudMatched == null) {\n                throw new ValidationError('Object member schema validation failed.', {\n                    value: fieldValue,\n                    meta: validationObject,\n                    rawValue: opts.rawValue,\n                    i18n: opts.i18n,\n                    path: fieldPath,\n                    errors,\n                });\n            }\n        } else {\n            _fieldValue = this.system.sanitize(fieldValue, validationObject, opts.i18n, fieldPath);\n        }\n\n        if (_fieldValue != null || fieldName in value) {\n            newValue[fieldName] = _fieldValue;\n        }\n    };\n\n    _sanitizeMember_ = (value, opts, newValue) => async (validationObject, fieldName) => {\n        const fieldValue = value[fieldName];\n        const fieldPath = makePath(opts.path, fieldName);\n\n        let _fieldValue;\n\n        if (Array.isArray(validationObject)) {\n            const errors = [];\n            const foudMatched = await findAsync_(validationObject, async (_validationObject) => {\n                try {\n                    _fieldValue = await this.system.sanitize_(fieldValue, _validationObject, opts.i18n, fieldPath);\n                    return true;\n                } catch (error) {\n                    errors.push(ValidationError.extractFromError(error));\n                    return false;\n                }\n            });\n\n            if (foudMatched == null) {\n                throw new ValidationError('Object member schema validation failed.', {\n                    value: fieldValue,\n                    meta: validationObject,\n                    rawValue: opts.rawValue,\n                    i18n: opts.i18n,\n                    path: fieldPath,\n                    errors,\n                });\n            }\n        } else {\n            _fieldValue = await this.system.sanitize_(fieldValue, validationObject, opts.i18n, fieldPath);\n        }\n\n        if (_fieldValue != null || fieldName in value) {\n            newValue[fieldName] = _fieldValue;\n        }\n    };\n\n    constructor(system) {\n        this.system = system;\n    }\n\n    validate(value) {\n        return isPlainObject(value);\n    }\n\n    _sanitize(value, meta, opts) {\n        const type = typeof value;\n\n        if (type === 'string') {\n            if (value.length > 1 && jsonStarter.has(value[0]) && jsonEnding[value[0]] === value[value.length - 1]) {\n                value = JSON.parse(value);\n            }\n        }\n\n        if (meta.schema) {\n            if (typeof value !== 'object') {\n                throw new ValidationError('Invalid object value.', {\n                    value,\n                    meta,\n                    rawValue: opts.rawValue,\n                    i18n: opts.i18n,\n                    path: opts.path,\n                });\n            }\n\n            let schema = typeof meta.schema === 'function' ? meta.schema() : meta.schema;\n            let newValue;\n\n            if (Array.isArray(schema)) {\n                const errors = [];\n                const pass = schema.find((altSchema) => {\n                    newValue = {};\n                    try {\n                        _each(altSchema, this._sanitizeMember(value, opts, newValue));\n                        return true;\n                    } catch (error) {\n                        errors.push(ValidationError.extractFromError(error));\n                        return false;\n                    }\n                });\n\n                if (pass == null) {\n                    throw new ValidationError('Object schema validation failed.', {\n                        value,\n                        meta,\n                        rawValue: opts.rawValue,\n                        i18n: opts.i18n,\n                        path: opts.path,\n                        errors,\n                    });\n                }\n            } else {\n                newValue = {};\n                _each(schema, this._sanitizeMember(value, opts, newValue));\n            }\n\n            if (meta.keepUnsanitized) {\n                return { ...value, ...newValue };\n            }\n\n            return newValue;\n        }\n\n        const { valueSchema, ..._meta } = meta;\n        if (valueSchema) {\n            const schema = _mapValues(value, () => valueSchema);            \n            return this._sanitize(value, { schema, ..._meta }, opts);\n        }\n\n        return value;\n    }\n\n    async _sanitizeAsync(value, meta, opts) {\n        const type = typeof value;\n\n        if (type === 'string') {\n            if (value.length > 1 && jsonStarter.has(value[0]) && jsonEnding[value[0]] === value[value.length - 1]) {\n                value = JSON.parse(value);\n            }\n        }\n\n        if (meta.schema) {\n            if (typeof value !== 'object') {\n                throw new ValidationError('Invalid object value.', {\n                    value,\n                    meta,\n                    rawValue: opts.rawValue,\n                    i18n: opts.i18n,\n                    path: opts.path,\n                });\n            }\n\n            const schema = typeof meta.schema === 'function' ? meta.schema() : meta.schema;\n            let newValue;\n\n            if (Array.isArray(schema)) {\n                const errors = [];\n                const pass = await findAsync_(schema, async (altSchema) => {\n                    newValue = {};\n                    try {\n                        await batchAsync_(altSchema, this._sanitizeMember_(value, opts, newValue));\n                        return true;\n                    } catch (error) {\n                        errors.push(ValidationError.extractFromError(error));\n                        return false;\n                    }\n                });\n\n                if (pass == null) {\n                    throw new ValidationError('Object schema validation failed.', {\n                        value,\n                        meta,\n                        rawValue: opts.rawValue,\n                        i18n: opts.i18n,\n                        path: opts.path,\n                        errors,\n                    });\n                }\n            } else {\n                newValue = {};\n                await batchAsync_(schema, this._sanitizeMember_(value, opts, newValue));\n            }\n\n            if (meta.keepUnsanitized) {\n                return { ...value, ...newValue };\n            }\n\n            return newValue;\n        }\n\n        const { valueSchema, ..._meta } = meta;\n        if (valueSchema) {\n            const schema = _mapValues(value, () => valueSchema);\n            return this._sanitizeAsync(value, { schema, ..._meta }, opts);\n        }\n\n        return value;\n    }\n\n    serialize(value) {\n        if (value == null) return null;\n        return this.system.safeJsonStringify(value);\n    }\n}\n\nexport default T_OBJECT;\n"],"names":["jsonStarter","Set","jsonEnding","T_OBJECT","validate","value","isPlainObject","_sanitize","meta","opts","type","length","has","JSON","parse","schema","ValidationError","rawValue","i18n","path","newValue","Array","isArray","errors","pass","find","altSchema","_each","_sanitizeMember","error","push","extractFromError","keepUnsanitized","valueSchema","_meta","_mapValues","_sanitizeAsync","findAsync_","batchAsync_","_sanitizeMember_","serialize","system","safeJsonStringify","constructor","name","alias","primitive","defaultValue","validationObject","fieldName","fieldValue","fieldPath","makePath","_fieldValue","foudMatched","_validationObject","sanitize","sanitize_"],"mappings":"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"}