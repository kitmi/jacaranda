{"version":3,"sources":["../../src/starters/queueWorker.js"],"sourcesContent":["import startWorker from './worker';\n\n/**\n * Start a message queue worker.\n * @param {Function} worker\n * @param {*} queueService\n * @param {*} queueName\n * @param {object} options\n */\nasync function startQueueWorker(worker, queueService, queueName, options) {\n    const workerOptions = { workerName: queueName + 'Worker', ...options, dontStop: true };\n\n    return startWorker(async (app) => {\n        let messageQueue = app.getService(queueService);\n\n        app.log('info', `A queue worker is started and waiting for message on queue \"${queueName}\" ...`);\n\n        await messageQueue.workerConsume_(queueName, (channel, msg) => {\n            let info = msg && msg.content;\n\n            try {\n                info = info && JSON.parse(info.toString());\n            } catch (error) {\n                app.log('error', 'The incoming message is not a valid JSON string.');\n                channel.ack(msg);\n                return;\n            }\n\n            if (info && info.$mock) {\n                app.log('info', 'A mock message is received.\\nMessage: ' + raw);\n                channel.ack(msg);\n                return;\n            }\n\n            worker(app, info)\n                .then((shouldAck) => {\n                    if (shouldAck) {\n                        channel.ack(msg);\n                    } else {\n                        channel.nack(msg);\n                    }\n                })\n                .catch((error) => {\n                    app.logError(error);\n\n                    if (error.needRetry) {\n                        channel.nack(msg);\n                    } else {\n                        channel.ack(msg);\n                    }\n                });\n        });\n    }, workerOptions);\n}\n\nexport default startQueueWorker;\n"],"names":["startQueueWorker","worker","queueService","queueName","options","workerOptions","workerName","dontStop","startWorker","app","messageQueue","getService","log","workerConsume_","channel","msg","info","content","JSON","parse","toString","error","ack","$mock","raw","then","shouldAck","nack","catch","logError","needRetry"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";;;;+BAuDA;;;eAAA;;;+DAvDwB;;;;;;AAExB;;;;;;CAMC,GACD,eAAeA,iBAAiBC,MAAM,EAAEC,YAAY,EAAEC,SAAS,EAAEC,OAAO;IACpE,MAAMC,gBAAgB;QAAEC,YAAYH,YAAY;QAAU,GAAGC,OAAO;QAAEG,UAAU;IAAK;IAErF,OAAOC,IAAAA,eAAW,EAAC,OAAOC;QACtB,IAAIC,eAAeD,IAAIE,UAAU,CAACT;QAElCO,IAAIG,GAAG,CAAC,QAAQ,CAAC,4DAA4D,EAAET,UAAU,KAAK,CAAC;QAE/F,MAAMO,aAAaG,cAAc,CAACV,WAAW,CAACW,SAASC;YACnD,IAAIC,OAAOD,OAAOA,IAAIE,OAAO;YAE7B,IAAI;gBACAD,OAAOA,QAAQE,KAAKC,KAAK,CAACH,KAAKI,QAAQ;YAC3C,EAAE,OAAOC,OAAO;gBACZZ,IAAIG,GAAG,CAAC,SAAS;gBACjBE,QAAQQ,GAAG,CAACP;gBACZ;YACJ;YAEA,IAAIC,QAAQA,KAAKO,KAAK,EAAE;gBACpBd,IAAIG,GAAG,CAAC,QAAQ,2CAA2CY;gBAC3DV,QAAQQ,GAAG,CAACP;gBACZ;YACJ;YAEAd,OAAOQ,KAAKO,MACPS,IAAI,CAAC,CAACC;gBACH,IAAIA,WAAW;oBACXZ,QAAQQ,GAAG,CAACP;gBAChB,OAAO;oBACHD,QAAQa,IAAI,CAACZ;gBACjB;YACJ,GACCa,KAAK,CAAC,CAACP;gBACJZ,IAAIoB,QAAQ,CAACR;gBAEb,IAAIA,MAAMS,SAAS,EAAE;oBACjBhB,QAAQa,IAAI,CAACZ;gBACjB,OAAO;oBACHD,QAAQQ,GAAG,CAACP;gBAChB;YACJ;QACR;IACJ,GAAGV;AACP;MAEA,WAAeL"}