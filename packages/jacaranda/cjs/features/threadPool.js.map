{"version":3,"sources":["../../src/features/threadPool.js"],"sourcesContent":["import { Worker } from 'node:worker_threads';\nimport { InvalidConfiguration } from '@kitmi/types';\nimport Feature from '../Feature';\n\nconst recreateWorkerError = (sourceError) => {\n    const error = new Error(sourceError.message);\n\n    for (const [key, value] of Object.entries(sourceError)) {\n        if (key !== 'message') {\n            error[key] = value;\n        }\n    }\n\n    return error;\n};\n\nlet poolIdCounter = 0;\n\nexport class WorkerPool {\n    constructor(app, options) {\n        const Deque = app.tryRequire('collections/deque');\n        const { name, workerFile, lowThreadNum, highThreadNum, workerOptions } = options;\n\n        this.app = app;\n        this.workerFile = workerFile;\n        this.lowThreadNum = lowThreadNum;\n        this.highThreadNum = highThreadNum;\n        this.workerOptions = workerOptions;\n        this.poolId = poolIdCounter++;\n        this.name = name ?? `${this.app.name}_tp${this.poolId}`;\n        this.taskIdCounter = 0;\n        this.tasks = new Map();\n        this.idleWorkers = new Deque();\n        this.busyWorkers = new Map();\n\n        if (lowThreadNum > 0) {\n            for (let i = 0; i < lowThreadNum; i++) {\n                this.createWorker(true);\n            }\n        }\n    }\n\n    createWorker(idle) {\n        const worker = new Worker(this.workerFile, this.workerOptions);\n\n        worker.on('message', (message) => {\n            if (message.id === '$CALLBACK') {\n                const { task, payload } = message;\n                const handler = this.handlers?.[task];\n\n                if (handler == null) {\n                    throw new Error(`Unknown callback task \"${task}\".`);\n                }\n\n                Promise.resolve(handler(payload)).catch(this.app.logError);\n            } else {\n                const task = this.tasks.get(message.id);\n                if (task) {\n                    this.tasks.delete(message.id);\n\n                    const workerContext = this.busyWorkers.get(worker.threadId);\n                    workerContext.ongoing--;\n\n                    if (workerContext.ongoing === 0) {\n                        worker.unref();\n                        this.busyWorkers.delete(worker.threadId);\n\n                        if (this.idleWorkers.length < this.lowThreadNum) {\n                            this.idleWorkers.push(worker);\n                        } else {\n                            worker.terminate();\n                        }\n                    }\n\n                    if (message.error == null) {\n                        task.resolve(message.value);\n                    } else {\n                        task.reject(recreateWorkerError(message.error));\n                    }\n                }\n            }\n        });\n\n        worker.on('error', (error) => {\n            // Any error here is effectively an equivalent of segfault, and have no scope, so we just throw it on callback level\n            throw error;\n        });\n\n        if (idle) {\n            this.idleWorkers.push(worker);\n        }\n\n        return worker;\n    }\n\n    getNextWorker() {\n        // If we have idle workers, just use them\n        if (this.idleWorkers.length > 0) {\n            const worker = this.idleWorkers.shift();\n            this.busyWorkers.set(worker.threadId, { ongoing: 1, worker });\n            return worker;\n        }\n\n        // If we have less than highThreadNum workers, create a new one\n        if (this.busyWorkers.size < this.highThreadNum) {\n            const worker = this.createWorker();\n            this.busyWorkers.set(worker.threadId, { ongoing: 1, worker });\n            return worker;\n        }\n\n        // Otherwise, just use the first worker\n        const [workerThreadId, workerContext] = this.busyWorkers.entries().next().value;\n        workerContext.ongoing++;\n        this.busyWorkers.delete(workerThreadId);\n        this.busyWorkers.set(workerThreadId, workerContext);\n        return workerContext.worker;\n    }\n\n    async runTask_(task, payload, transferList) {\n        return new Promise((resolve, reject) => {\n            const taskId = this.taskIdCounter++;\n            this.tasks.set(taskId, { resolve, reject });\n\n            const worker = this.getNextWorker();\n\n            worker.ref();\n            worker.postMessage({ id: taskId, task, payload }, transferList);\n        });\n    }\n\n    setCallbackHandlers(handlers) {\n        this.handlers = { ...this.handlers, ...handlers };\n    }\n}\n\n/**\n * Thread pool to run tasks in parallel\n * @module Feature_ThreadPool\n */\n\nexport default {\n    /**\n     * This feature is loaded at service stage\n     * @member {string}\n     */\n    stage: Feature.SERVICE,\n\n    groupable: true,\n\n    packages: ['collections'],\n\n    /**\n     * Load the feature\n     * @param {App} app - The app module object\n     * @param {object} [options] - Options for the feature\n     * @returns {Promise.<void>}\n     *\n     */\n    load_: async function (app, options, name) {\n        options = app.featureConfig(\n            options,\n            {\n                schema: {\n                    name: { type: 'text', optional: true },\n                    workerFile: { type: 'text' },\n                    workerOptions: { type: 'object', optional: true },\n                    lowThreadNum: { type: 'integer', default: 0 },\n                    highThreadNum: { type: 'integer', default: 1 },\n                },\n                keepUnsanitized: true,\n            },\n            name\n        );\n\n        const { lowThreadNum, highThreadNum } = options;\n\n        if (highThreadNum < lowThreadNum) {\n            throw new InvalidConfiguration(\n                '\"highThreadNum\" must be greater than or equal to \"lowThreadNum\".',\n                app,\n                `${name}.highThreadNum`\n            );\n        }\n\n        if (highThreadNum === 0) {\n            throw new InvalidConfiguration('\"highThreadNum\" must be greater than 0.', app, `${name}.highThreadNum`);\n        }\n\n        const pool = new WorkerPool(app, options);\n\n        app.on('stopping', async () => {\n            for (const worker of pool.idleWorkers) {\n                worker.terminate();\n            }\n\n            for (const { worker } of pool.busyWorkers.values()) {\n                worker.terminate();\n            }\n        });\n\n        app.registerService(name, pool);\n    },\n};\n"],"names":["WorkerPool","recreateWorkerError","sourceError","error","Error","message","key","value","Object","entries","poolIdCounter","createWorker","idle","worker","Worker","workerFile","workerOptions","on","id","task","payload","handler","handlers","Promise","resolve","catch","app","logError","tasks","get","delete","workerContext","busyWorkers","threadId","ongoing","unref","idleWorkers","length","lowThreadNum","push","terminate","reject","getNextWorker","shift","set","size","highThreadNum","workerThreadId","next","runTask_","transferList","taskId","taskIdCounter","ref","postMessage","setCallbackHandlers","constructor","options","Deque","tryRequire","name","poolId","Map","i","stage","Feature","SERVICE","groupable","packages","load_","featureConfig","schema","type","optional","default","keepUnsanitized","InvalidConfiguration","pool","values","registerService"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}