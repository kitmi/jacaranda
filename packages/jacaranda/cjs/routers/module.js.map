{"version":3,"sources":["../../src/routers/module.js"],"sourcesContent":["import path from 'node:path';\nimport { url as urlUtil, naming, text, esmCheck, eachAsync_, batchAsync_ } from '@kitmi/utils';\nimport { InvalidConfiguration } from '@kitmi/types';\nimport { supportedMethods } from '../helpers';\n\n/**\n * Module router for mounting a specific controller.\n * @module Router_Module\n */\n\n/**\n * Create a module-based router.\n * @param {Routable} app\n * @param {string} baseRoute\n * @param {*} options\n * @example\n *   '<base path>': {\n *       module: {\n *           $controllerPath:\n *           $middlewares:\n *           '/': [ 'controller', ... ]\n *       }\n *   }\n *\n *   '<base path>': {\n *       module: \"controller\"\n *   }\n */\nasync function moduleRouter(app, baseRoute, options) {\n    let controllerPath = path.resolve(app.sourcePath, options.$controllerPath ?? 'controllers');\n\n    if (typeof options === 'string') {\n        // [ 'controllerName' ]\n        options = {\n            '/': [options],\n        };\n    }\n\n    const kebabify = options.$urlDasherize;\n\n    let router = app.router.createRouter(baseRoute);\n\n    if (options.$middlewares) {\n        //module-wide middlewares\n        await app.useMiddlewares_(router, options.$middlewares);\n    }\n\n    await eachAsync_(options, async (controllers, subBaseRoute) => {\n        if (subBaseRoute[0] === '$') {\n            return;\n        }\n\n        if (!Array.isArray(controllers)) {\n            controllers = [controllers];\n        }\n\n        await batchAsync_(controllers, async (moduleController) => {\n            let controllerFile = path.join(controllerPath, moduleController);\n            let controller;\n\n            try {\n                controller = esmCheck(require(controllerFile));\n            } catch (e) {\n                /*\n                if (e.code === 'MODULE_NOT_FOUND') {\n                    throw new InvalidConfiguration(\n                        `Failed to load controller '${moduleController}'. ${e.message}`,\n                        app,\n                        `routing.${baseRoute}.module`\n                    );\n                }*/\n\n                throw e;\n            }\n\n            let isController = false;\n\n            if (typeof controller === 'function') {\n                controller = new controller(app);\n                isController = true;\n            }\n\n            for (let actionName in controller) {\n                let action = controller[actionName];\n                if (typeof action !== 'function' || !action.__metaHttpMethod) continue; // only marked httpMethod should be mounted\n\n                const method = action.__metaHttpMethod;\n                const subRoute = urlUtil.join(subBaseRoute, text.dropIfStartsWith(action.__metaRoute || (kebabify ? naming.kebabCase(actionName) : actionName), '/'));\n\n                let bindAction;\n\n                if (isController) {\n                    bindAction = action.bind(controller);\n                } else {\n                    bindAction = action;\n                }\n\n                if (!supportedMethods.has(method)) {\n                    throw new InvalidConfiguration(\n                        'Unsupported http method: ' + method,\n                        app,\n                        `routing[${baseRoute}].module.subBaseRoute[${moduleController}.${actionName}]`\n                    );\n                }\n\n                await app.addRoute_(\n                    router,\n                    method,\n                    subRoute,\n                    action.__metaMiddlewares ? action.__metaMiddlewares.concat([bindAction]) : bindAction\n                );\n            }\n        });\n    });\n\n    app.addRouter(router);\n}\n\nexport default moduleRouter;\n"],"names":["moduleRouter","app","baseRoute","options","controllerPath","path","resolve","sourcePath","$controllerPath","kebabify","$urlDasherize","router","createRouter","$middlewares","useMiddlewares_","eachAsync_","controllers","subBaseRoute","Array","isArray","batchAsync_","moduleController","controllerFile","join","controller","esmCheck","require","e","isController","actionName","action","__metaHttpMethod","method","subRoute","urlUtil","text","dropIfStartsWith","__metaRoute","naming","kebabCase","bindAction","bind","supportedMethods","has","InvalidConfiguration","addRoute_","__metaMiddlewares","concat","addRouter"],"mappings":";;;;+BAsHA;;;eAAA;;;iEAtHiB;uBAC+D;uBAC3C;yBACJ;;;;;;AAEjC;;;CAGC,GAED;;;;;;;;;;;;;;;;;CAiBC,GACD,eAAeA,aAAaC,GAAG,EAAEC,SAAS,EAAEC,OAAO;IAC/C,IAAIC,iBAAiBC,iBAAI,CAACC,OAAO,CAACL,IAAIM,UAAU,EAAEJ,QAAQK,eAAe,IAAI;IAE7E,IAAI,OAAOL,YAAY,UAAU;QAC7B,uBAAuB;QACvBA,UAAU;YACN,KAAK;gBAACA;aAAQ;QAClB;IACJ;IAEA,MAAMM,WAAWN,QAAQO,aAAa;IAEtC,IAAIC,SAASV,IAAIU,MAAM,CAACC,YAAY,CAACV;IAErC,IAAIC,QAAQU,YAAY,EAAE;QACtB,yBAAyB;QACzB,MAAMZ,IAAIa,eAAe,CAACH,QAAQR,QAAQU,YAAY;IAC1D;IAEA,MAAME,IAAAA,iBAAU,EAACZ,SAAS,OAAOa,aAAaC;QAC1C,IAAIA,YAAY,CAAC,EAAE,KAAK,KAAK;YACzB;QACJ;QAEA,IAAI,CAACC,MAAMC,OAAO,CAACH,cAAc;YAC7BA,cAAc;gBAACA;aAAY;QAC/B;QAEA,MAAMI,IAAAA,kBAAW,EAACJ,aAAa,OAAOK;YAClC,IAAIC,iBAAiBjB,iBAAI,CAACkB,IAAI,CAACnB,gBAAgBiB;YAC/C,IAAIG;YAEJ,IAAI;gBACAA,aAAaC,IAAAA,eAAQ,EAACC,QAAQJ;YAClC,EAAE,OAAOK,GAAG;gBACR;;;;;;;iBAOC,GAED,MAAMA;YACV;YAEA,IAAIC,eAAe;YAEnB,IAAI,OAAOJ,eAAe,YAAY;gBAClCA,aAAa,IAAIA,WAAWvB;gBAC5B2B,eAAe;YACnB;YAEA,IAAK,IAAIC,cAAcL,WAAY;gBAC/B,IAAIM,SAASN,UAAU,CAACK,WAAW;gBACnC,IAAI,OAAOC,WAAW,cAAc,CAACA,OAAOC,gBAAgB,EAAE,UAAU,2CAA2C;gBAEnH,MAAMC,SAASF,OAAOC,gBAAgB;gBACtC,MAAME,WAAWC,UAAO,CAACX,IAAI,CAACN,cAAckB,WAAI,CAACC,gBAAgB,CAACN,OAAOO,WAAW,IAAK5B,CAAAA,WAAW6B,aAAM,CAACC,SAAS,CAACV,cAAcA,UAAS,GAAI;gBAEhJ,IAAIW;gBAEJ,IAAIZ,cAAc;oBACdY,aAAaV,OAAOW,IAAI,CAACjB;gBAC7B,OAAO;oBACHgB,aAAaV;gBACjB;gBAEA,IAAI,CAACY,yBAAgB,CAACC,GAAG,CAACX,SAAS;oBAC/B,MAAM,IAAIY,2BAAoB,CAC1B,8BAA8BZ,QAC9B/B,KACA,CAAC,QAAQ,EAAEC,UAAU,sBAAsB,EAAEmB,iBAAiB,CAAC,EAAEQ,WAAW,CAAC,CAAC;gBAEtF;gBAEA,MAAM5B,IAAI4C,SAAS,CACflC,QACAqB,QACAC,UACAH,OAAOgB,iBAAiB,GAAGhB,OAAOgB,iBAAiB,CAACC,MAAM,CAAC;oBAACP;iBAAW,IAAIA;YAEnF;QACJ;IACJ;IAEAvC,IAAI+C,SAAS,CAACrC;AAClB;MAEA,WAAeX"}