{"version":3,"sources":["../../src/routers/module.js"],"sourcesContent":["import { url as urlUtil, naming, text, eachAsync_, batchAsync_, get as _get } from '@kitmi/utils';\nimport { InvalidConfiguration } from '@kitmi/types';\nimport { supportedMethods } from '../helpers';\n\n/**\n * Module router for mounting a specific controller.\n * @module Router_Module\n */\n\n/**\n * Create a module-based router.\n * @param {Routable} app\n * @param {string} baseRoute\n * @param {*} options\n * @example\n *   '<base path>': {\n *       module: {\n *           $controllerPath:\n *           $middlewares:\n *           $urlDasherize: false\n *           '/': [ 'controller', ... ]\n *       }\n *   }\n *\n *   '<base path>': {\n *       module: \"controller\"\n *   }\n */\nasync function moduleRouter(app, baseRoute, options) {\n    if (typeof options === 'string') {\n        // [ 'controllerName' ]\n        options = {\n            '/': [options],\n        };\n    }\n\n    let controllerPath = options.$controllerPath ?? 'modules';\n\n    const kebabify = options.$urlDasherize;\n\n    let router = app.router.createRouter(baseRoute);\n\n    if (options.$middlewares) {\n        //module-wide middlewares\n        await app.useMiddlewares_(router, options.$middlewares);\n    }\n\n    await eachAsync_(options, async (controllers, subBaseRoute) => {\n        if (subBaseRoute[0] === '$') {\n            return;\n        }\n\n        if (!Array.isArray(controllers)) {\n            controllers = [controllers];\n        }\n\n        await batchAsync_(controllers, async (moduleController) => {\n            let controller = _get(app.registry.controllers, [controllerPath, moduleController]);\n\n            if (controller == null) {\n                throw new InvalidConfiguration(\n                    `Module controller \"${moduleController}\" not found.`,\n                    app,\n                    `routing.${baseRoute}.module[${subBaseRoute}]`\n                );\n            }\n\n            let isController = false;\n\n            if (typeof controller === 'function') {\n                controller = new controller(app);\n                isController = true;\n            }\n\n            for (let actionName in controller) {\n                let action = controller[actionName];\n                if (typeof action !== 'function' || !action.__metaHttpMethod) continue; // only marked httpMethod should be mounted\n\n                const method = action.__metaHttpMethod;\n                const subRoute = urlUtil.join(\n                    subBaseRoute,\n                    text.dropIfStartsWith(\n                        action.__metaRoute || (kebabify ? naming.kebabCase(actionName) : actionName),\n                        '/'\n                    )\n                );\n\n                let bindAction;\n\n                if (isController) {\n                    bindAction = action.bind(controller);\n                } else {\n                    bindAction = action;\n                }\n\n                if (!supportedMethods.has(method)) {\n                    throw new InvalidConfiguration(\n                        'Unsupported http method: ' + method,\n                        app,\n                        `routing[${baseRoute}].module.subBaseRoute[${moduleController}.${actionName}]`\n                    );\n                }\n\n                await app.addRoute_(\n                    router,\n                    method,\n                    subRoute,\n                    action.__metaMiddlewares ? action.__metaMiddlewares.concat([bindAction]) : bindAction\n                );\n            }\n        });\n    });\n\n    app.addRouter(router);\n}\n\nexport default moduleRouter;\n"],"names":["moduleRouter","app","baseRoute","options","controllerPath","$controllerPath","kebabify","$urlDasherize","router","createRouter","$middlewares","useMiddlewares_","eachAsync_","controllers","subBaseRoute","Array","isArray","batchAsync_","moduleController","controller","_get","registry","InvalidConfiguration","isController","actionName","action","__metaHttpMethod","method","subRoute","urlUtil","join","text","dropIfStartsWith","__metaRoute","naming","kebabCase","bindAction","bind","supportedMethods","has","addRoute_","__metaMiddlewares","concat","addRouter"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";;;;+BAoHA;;;eAAA;;;uBApHmF;uBAC9C;yBACJ;AAEjC;;;CAGC,GAED;;;;;;;;;;;;;;;;;;CAkBC,GACD,eAAeA,aAAaC,GAAG,EAAEC,SAAS,EAAEC,OAAO;IAC/C,IAAI,OAAOA,YAAY,UAAU;QAC7B,uBAAuB;QACvBA,UAAU;YACN,KAAK;gBAACA;aAAQ;QAClB;IACJ;IAEA,IAAIC,iBAAiBD,QAAQE,eAAe,IAAI;IAEhD,MAAMC,WAAWH,QAAQI,aAAa;IAEtC,IAAIC,SAASP,IAAIO,MAAM,CAACC,YAAY,CAACP;IAErC,IAAIC,QAAQO,YAAY,EAAE;QACtB,yBAAyB;QACzB,MAAMT,IAAIU,eAAe,CAACH,QAAQL,QAAQO,YAAY;IAC1D;IAEA,MAAME,IAAAA,iBAAU,EAACT,SAAS,OAAOU,aAAaC;QAC1C,IAAIA,YAAY,CAAC,EAAE,KAAK,KAAK;YACzB;QACJ;QAEA,IAAI,CAACC,MAAMC,OAAO,CAACH,cAAc;YAC7BA,cAAc;gBAACA;aAAY;QAC/B;QAEA,MAAMI,IAAAA,kBAAW,EAACJ,aAAa,OAAOK;YAClC,IAAIC,aAAaC,IAAAA,UAAI,EAACnB,IAAIoB,QAAQ,CAACR,WAAW,EAAE;gBAACT;gBAAgBc;aAAiB;YAElF,IAAIC,cAAc,MAAM;gBACpB,MAAM,IAAIG,2BAAoB,CAC1B,CAAC,mBAAmB,EAAEJ,iBAAiB,YAAY,CAAC,EACpDjB,KACA,CAAC,QAAQ,EAAEC,UAAU,QAAQ,EAAEY,aAAa,CAAC,CAAC;YAEtD;YAEA,IAAIS,eAAe;YAEnB,IAAI,OAAOJ,eAAe,YAAY;gBAClCA,aAAa,IAAIA,WAAWlB;gBAC5BsB,eAAe;YACnB;YAEA,IAAK,IAAIC,cAAcL,WAAY;gBAC/B,IAAIM,SAASN,UAAU,CAACK,WAAW;gBACnC,IAAI,OAAOC,WAAW,cAAc,CAACA,OAAOC,gBAAgB,EAAE,UAAU,2CAA2C;gBAEnH,MAAMC,SAASF,OAAOC,gBAAgB;gBACtC,MAAME,WAAWC,UAAO,CAACC,IAAI,CACzBhB,cACAiB,WAAI,CAACC,gBAAgB,CACjBP,OAAOQ,WAAW,IAAK3B,CAAAA,WAAW4B,aAAM,CAACC,SAAS,CAACX,cAAcA,UAAS,GAC1E;gBAIR,IAAIY;gBAEJ,IAAIb,cAAc;oBACda,aAAaX,OAAOY,IAAI,CAAClB;gBAC7B,OAAO;oBACHiB,aAAaX;gBACjB;gBAEA,IAAI,CAACa,yBAAgB,CAACC,GAAG,CAACZ,SAAS;oBAC/B,MAAM,IAAIL,2BAAoB,CAC1B,8BAA8BK,QAC9B1B,KACA,CAAC,QAAQ,EAAEC,UAAU,sBAAsB,EAAEgB,iBAAiB,CAAC,EAAEM,WAAW,CAAC,CAAC;gBAEtF;gBAEA,MAAMvB,IAAIuC,SAAS,CACfhC,QACAmB,QACAC,UACAH,OAAOgB,iBAAiB,GAAGhB,OAAOgB,iBAAiB,CAACC,MAAM,CAAC;oBAACN;iBAAW,IAAIA;YAEnF;QACJ;IACJ;IAEAnC,IAAI0C,SAAS,CAACnC;AAClB;MAEA,WAAeR"}