{"version":3,"sources":["../../src/routers/module.js"],"sourcesContent":["import path from 'node:path';\nimport { _, url as urlUtil, text, esmCheck, eachAsync_, batchAsync_ } from '@kitmi/utils';\nimport { InvalidConfiguration } from '@kitmi/types';\nimport { supportedMethods } from '../helpers';\n\n/**\n * Module router for mounting a specific controller.\n * @module Router_Module\n */\n\n/**\n * Create a module-based router.\n * @param {Routable} app\n * @param {string} baseRoute\n * @param {*} options\n * @example\n *   '<base path>': {\n *       module: {\n *           $controllerPath:\n *           $middlewares:\n *           '/': [ 'controller', ... ]\n *       }\n *   }\n *\n *   '<base path>': {\n *       module: \"controller\"\n *   }\n */\nasync function moduleRouter(app, baseRoute, options) {\n    let controllerPath = options.$controllerPath;\n\n    if (typeof options === 'string') {\n        // [ 'controllerName' ]\n        options = {\n            '/': [options],\n        };\n    }\n\n    let router = app.engine.createRouter(baseRoute);\n\n    if (options.$middlewares) {\n        //module-wide middlewares\n        await app.useMiddlewares_(router, options.$middlewares);\n    }\n\n    await eachAsync_(options, async (controllers, subBaseRoute) => {\n        if (subBaseRoute[0] === '$') {\n            return;\n        }\n\n        if (!Array.isArray(controllers)) {\n            controllers = [controllers];\n        }\n\n        await batchAsync_(controllers, async (moduleController) => {\n            let controllerFile = path.join(controllerPath, moduleController);\n            let controller;\n\n            try {\n                controller = esmCheck(require(controllerFile));\n            } catch (e) {\n                if (e.code === 'MODULE_NOT_FOUND') {\n                    throw new InvalidConfiguration(\n                        `Failed to load controller '${moduleController}'. ${e.message}`,\n                        app,\n                        `routing.${baseRoute}.module`\n                    );\n                }\n\n                throw e;\n            }\n\n            let isController = false;\n\n            if (typeof controller === 'function') {\n                controller = new controller(app);\n                isController = true;\n            }\n\n            for (let actionName in controller) {\n                let action = controller[actionName];\n                if (typeof action !== 'function' || !action.__metaHttpMethod) continue; // only marked httpMethod should be mounted\n\n                const method = action.__metaHttpMethod;\n                const subRoute = urlUtil.join(subBaseRoute, text.dropIfStartsWith(action.__metaRoute || _.kebabCase(actionName), '/'));\n\n                let bindAction;\n\n                if (isController) {\n                    bindAction = action.bind(controller);\n                } else {\n                    bindAction = action;\n                }\n\n                if (!supportedMethods.has(method)) {\n                    throw new InvalidConfiguration(\n                        'Unsupported http method: ' + method,\n                        app,\n                        `routing.${baseRoute}.module.subBaseRoute[${moduleController}.${actionName}]`\n                    );\n                }\n\n                await app.addRoute_(\n                    router,\n                    method,\n                    subRoute,\n                    action.__metaMiddlewares ? action.__metaMiddlewares.concat([bindAction]) : bindAction\n                );\n            }\n        });\n    });\n\n    app.addRouter(router);\n}\n\nexport default moduleRouter;\n"],"names":["moduleRouter","app","baseRoute","options","controllerPath","$controllerPath","router","engine","createRouter","$middlewares","useMiddlewares_","eachAsync_","controllers","subBaseRoute","Array","isArray","batchAsync_","moduleController","controllerFile","path","join","controller","esmCheck","require","e","code","InvalidConfiguration","message","isController","actionName","action","__metaHttpMethod","method","subRoute","urlUtil","text","dropIfStartsWith","__metaRoute","_","kebabCase","bindAction","bind","supportedMethods","has","addRoute_","__metaMiddlewares","concat","addRouter"],"mappings":";;;;+BAmHA;;;eAAA;;;iEAnHiB;uBAC0D;uBACtC;yBACJ;;;;;;AAEjC;;;CAGC,GAED;;;;;;;;;;;;;;;;;CAiBC,GACD,eAAeA,aAAaC,GAAG,EAAEC,SAAS,EAAEC,OAAO;IAC/C,IAAIC,iBAAiBD,QAAQE,eAAe;IAE5C,IAAI,OAAOF,YAAY,UAAU;QAC7B,uBAAuB;QACvBA,UAAU;YACN,KAAK;gBAACA;aAAQ;QAClB;IACJ;IAEA,IAAIG,SAASL,IAAIM,MAAM,CAACC,YAAY,CAACN;IAErC,IAAIC,QAAQM,YAAY,EAAE;QACtB,yBAAyB;QACzB,MAAMR,IAAIS,eAAe,CAACJ,QAAQH,QAAQM,YAAY;IAC1D;IAEA,MAAME,IAAAA,iBAAU,EAACR,SAAS,OAAOS,aAAaC;QAC1C,IAAIA,YAAY,CAAC,EAAE,KAAK,KAAK;YACzB;QACJ;QAEA,IAAI,CAACC,MAAMC,OAAO,CAACH,cAAc;YAC7BA,cAAc;gBAACA;aAAY;QAC/B;QAEA,MAAMI,IAAAA,kBAAW,EAACJ,aAAa,OAAOK;YAClC,IAAIC,iBAAiBC,iBAAI,CAACC,IAAI,CAAChB,gBAAgBa;YAC/C,IAAII;YAEJ,IAAI;gBACAA,aAAaC,IAAAA,eAAQ,EAACC,QAAQL;YAClC,EAAE,OAAOM,GAAG;gBACR,IAAIA,EAAEC,IAAI,KAAK,oBAAoB;oBAC/B,MAAM,IAAIC,2BAAoB,CAC1B,CAAC,2BAA2B,EAAET,iBAAiB,GAAG,EAAEO,EAAEG,OAAO,CAAC,CAAC,EAC/D1B,KACA,CAAC,QAAQ,EAAEC,UAAU,OAAO,CAAC;gBAErC;gBAEA,MAAMsB;YACV;YAEA,IAAII,eAAe;YAEnB,IAAI,OAAOP,eAAe,YAAY;gBAClCA,aAAa,IAAIA,WAAWpB;gBAC5B2B,eAAe;YACnB;YAEA,IAAK,IAAIC,cAAcR,WAAY;gBAC/B,IAAIS,SAAST,UAAU,CAACQ,WAAW;gBACnC,IAAI,OAAOC,WAAW,cAAc,CAACA,OAAOC,gBAAgB,EAAE,UAAU,2CAA2C;gBAEnH,MAAMC,SAASF,OAAOC,gBAAgB;gBACtC,MAAME,WAAWC,UAAO,CAACd,IAAI,CAACP,cAAcsB,WAAI,CAACC,gBAAgB,CAACN,OAAOO,WAAW,IAAIC,QAAC,CAACC,SAAS,CAACV,aAAa;gBAEjH,IAAIW;gBAEJ,IAAIZ,cAAc;oBACdY,aAAaV,OAAOW,IAAI,CAACpB;gBAC7B,OAAO;oBACHmB,aAAaV;gBACjB;gBAEA,IAAI,CAACY,yBAAgB,CAACC,GAAG,CAACX,SAAS;oBAC/B,MAAM,IAAIN,2BAAoB,CAC1B,8BAA8BM,QAC9B/B,KACA,CAAC,QAAQ,EAAEC,UAAU,qBAAqB,EAAEe,iBAAiB,CAAC,EAAEY,WAAW,CAAC,CAAC;gBAErF;gBAEA,MAAM5B,IAAI2C,SAAS,CACftC,QACA0B,QACAC,UACAH,OAAOe,iBAAiB,GAAGf,OAAOe,iBAAiB,CAACC,MAAM,CAAC;oBAACN;iBAAW,IAAIA;YAEnF;QACJ;IACJ;IAEAvC,IAAI8C,SAAS,CAACzC;AAClB;MAEA,WAAeN"}