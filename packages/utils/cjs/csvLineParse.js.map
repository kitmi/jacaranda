{"version":3,"sources":["../src/csvLineParse.js"],"sourcesContent":["import replaceAll from './replaceAll';\n\n/**\n * Parse csv string into array, simple implementation especially for one-line parsing.\n * 23x faster than csv-parse for single line parsing\n * 10x faster than csv-parse/sync for single line parsing\n *\n * split + simpleCsvParser, however split('\\n') is not good for massive data, should use stream reader instead\n * 5x faster than csv-parse/sync for multiple lines parsing\n *\n * @param {string} str\n * @param {object} [options]\n * @property {string} [options.delimiter=',']\n * @property {boolean} [options.emptyAsNull=false]\n * @returns {array}\n */\nconst simpleCsvParser = (str, options) => {\n    const { delimiter, emptyAsNull } = { delimiter: ',', emptyAsNull: false, ...options };\n\n    let inQuote = null;\n    let start = 0;\n    let result = [];\n    let lastWord = null;\n    let hasEscaped = false;\n\n    const l = str.length;\n\n    for (let i = 0; i < l; i++) {\n        const ch = str[i];\n\n        if (inQuote) {\n            if (ch === inQuote) {\n                if (str[i - 1] === '\\\\') {\n                    hasEscaped = true;\n                } else {\n                    // not escaped\n                    lastWord = str.substring(start, i);\n                    if (lastWord && hasEscaped) {\n                        lastWord = replaceAll(lastWord, '\\\\' + inQuote, inQuote);\n                    }\n                    inQuote = null;\n                    hasEscaped = false;\n                }\n            }\n        } else if (ch === delimiter) {\n            if (lastWord == null && i > start) {\n                lastWord = str.substring(start, i);\n            }\n            result.push(lastWord ? lastWord.trim() : emptyAsNull ? null : '');\n            lastWord = null;\n            hasEscaped = false;\n            start = i + 1;\n        } else if (ch === '\"' || ch === \"'\") {\n            if (lastWord == null) {\n                inQuote = ch;\n                start = i + 1;\n            }\n        }\n    }\n\n    if (lastWord == null) {\n        lastWord = str.substring(start);\n    }\n    result.push(lastWord ? lastWord.trim() : emptyAsNull ? null : '');\n\n    return result;\n};\n\nexport default simpleCsvParser;\n"],"names":["simpleCsvParser","str","options","delimiter","emptyAsNull","inQuote","start","result","lastWord","hasEscaped","l","length","i","ch","substring","replaceAll","push","trim"],"mappings":";;;;+BAoEA;;;eAAA;;;mEApEuB;;;;;;AAEvB;;;;;;;;;;;;;CAaC,GACD,MAAMA,kBAAkB,CAACC,KAAKC;IAC1B,MAAM,EAAEC,SAAS,EAAEC,WAAW,EAAE,GAAG;QAAED,WAAW;QAAKC,aAAa;QAAO,GAAGF,OAAO;IAAC;IAEpF,IAAIG,UAAU;IACd,IAAIC,QAAQ;IACZ,IAAIC,SAAS,EAAE;IACf,IAAIC,WAAW;IACf,IAAIC,aAAa;IAEjB,MAAMC,IAAIT,IAAIU,MAAM;IAEpB,IAAK,IAAIC,IAAI,GAAGA,IAAIF,GAAGE,IAAK;QACxB,MAAMC,KAAKZ,GAAG,CAACW,EAAE;QAEjB,IAAIP,SAAS;YACT,IAAIQ,OAAOR,SAAS;gBAChB,IAAIJ,GAAG,CAACW,IAAI,EAAE,KAAK,MAAM;oBACrBH,aAAa;gBACjB,OAAO;oBACH,cAAc;oBACdD,WAAWP,IAAIa,SAAS,CAACR,OAAOM;oBAChC,IAAIJ,YAAYC,YAAY;wBACxBD,WAAWO,IAAAA,mBAAU,EAACP,UAAU,OAAOH,SAASA;oBACpD;oBACAA,UAAU;oBACVI,aAAa;gBACjB;YACJ;QACJ,OAAO,IAAII,OAAOV,WAAW;YACzB,IAAIK,YAAY,QAAQI,IAAIN,OAAO;gBAC/BE,WAAWP,IAAIa,SAAS,CAACR,OAAOM;YACpC;YACAL,OAAOS,IAAI,CAACR,WAAWA,SAASS,IAAI,KAAKb,cAAc,OAAO;YAC9DI,WAAW;YACXC,aAAa;YACbH,QAAQM,IAAI;QAChB,OAAO,IAAIC,OAAO,OAAOA,OAAO,KAAK;YACjC,IAAIL,YAAY,MAAM;gBAClBH,UAAUQ;gBACVP,QAAQM,IAAI;YAChB;QACJ;IACJ;IAEA,IAAIJ,YAAY,MAAM;QAClBA,WAAWP,IAAIa,SAAS,CAACR;IAC7B;IACAC,OAAOS,IAAI,CAACR,WAAWA,SAASS,IAAI,KAAKb,cAAc,OAAO;IAE9D,OAAOG;AACX;MAEA,WAAeP"}