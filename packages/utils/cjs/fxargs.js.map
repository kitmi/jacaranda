{"version":3,"sources":["../src/fxargs.js"],"sourcesContent":["import { typeOf } from '@kitmi/types';\n\n/**\n * Function arguments extractor.\n * @param {Array} args - Array of function arguments\n * @param {Array} types - Array of types, with suffix `?` as optional\n * @example\n *  function withClient(...args) {\n *      const [server, authenticator, testToRun, options] = fxargs(args, ['string?', 'string?', 'function', 'object?']);\n *      // ...\n *  }\n *\n *  1. withClient('http://localhost:3000', 'admin', (app) => {});\n *      - server: 'http://localhost:3000'\n *      - authenticator: 'admin'\n *      - testToRun: (app) => {}\n *      - options: undefined\n *\n *  2. withClient('http://localhost:3000', (app) => {});\n *      - server: 'http://localhost:3000'\n *      - authenticator: undefined\n *      - testToRun: (app) => {}\n *      - options: undefined\n *\n *  3. withClient((app) => {});\n *      - server: undefined\n *      - authenticator: undefined\n *      - testToRun: (app) => {}\n *      - options: undefined\n */\nfunction fxargs(args, types) {\n    const result = new Array(types.length).fill(undefined);\n    let argIndex = 0,\n        lt = types.length,\n        la = args.length;\n    const optionalSpots = [];\n\n    for (let i = 0; i < lt; i++) {\n        const type = types[i];\n        const isOptional = type.endsWith('?');\n        const typeOptions = isOptional ? type.slice(0, -1).split('|') : type.split('|');\n\n        let matched = false;\n\n        // Iterate over remaining args to find a match\n        while (argIndex < la && !matched) {\n            const value = args[argIndex];\n            if (typeOptions.some((typeOption) => typeOf(value) === typeOption)) {\n                // Assign the value and increment the argument index\n                result[i] = value;\n                argIndex++;\n                matched = true;                \n\n                if (isOptional) {\n                    optionalSpots.push(i);\n                } else {\n                    optionalSpots.length = 0;\n                }\n            } else if (isOptional) {\n                // If the type is optional and no match found, break to allow for undefined\n                break;\n            } else {\n                // Try pop up an optional value\n                if (optionalSpots.length > 0 && lt - i >= la - argIndex + 1) {\n                    const optionalIndex = optionalSpots.pop();\n                    result[optionalIndex] = undefined;\n                    argIndex--;                    \n                    continue;\n                }\n\n                // No match found for a required type\n                throw new Error(`Missing or invalid argument at index ${i}, expected \"${type}\".`);\n            }\n        }\n\n        if (!matched && !isOptional) {\n            // Try pop up an optional value\n            if (optionalSpots.length > 0 && lt - i >= la - argIndex + 1) {\n                const optionalIndex = optionalSpots.pop();\n                result[optionalIndex] = undefined;\n                argIndex--;                    \n                i--;\n            } else {\n                throw new Error(`Missing argument at index ${i}, expected \"${type}\".`);\n            }\n        }\n    }\n\n    return result;\n}\n\nexport default fxargs;\n"],"names":["fxargs","args","types","result","Array","length","fill","undefined","argIndex","lt","la","optionalSpots","i","type","isOptional","endsWith","typeOptions","slice","split","matched","value","some","typeOption","typeOf","push","optionalIndex","pop","Error"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";;;;+BA2FA;;;eAAA;;;uBA3FuB;AAEvB;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2BC,GACD,SAASA,OAAOC,IAAI,EAAEC,KAAK;IACvB,MAAMC,SAAS,IAAIC,MAAMF,MAAMG,MAAM,EAAEC,IAAI,CAACC;IAC5C,IAAIC,WAAW,GACXC,KAAKP,MAAMG,MAAM,EACjBK,KAAKT,KAAKI,MAAM;IACpB,MAAMM,gBAAgB,EAAE;IAExB,IAAK,IAAIC,IAAI,GAAGA,IAAIH,IAAIG,IAAK;QACzB,MAAMC,OAAOX,KAAK,CAACU,EAAE;QACrB,MAAME,aAAaD,KAAKE,QAAQ,CAAC;QACjC,MAAMC,cAAcF,aAAaD,KAAKI,KAAK,CAAC,GAAG,CAAC,GAAGC,KAAK,CAAC,OAAOL,KAAKK,KAAK,CAAC;QAE3E,IAAIC,UAAU;QAEd,8CAA8C;QAC9C,MAAOX,WAAWE,MAAM,CAACS,QAAS;YAC9B,MAAMC,QAAQnB,IAAI,CAACO,SAAS;YAC5B,IAAIQ,YAAYK,IAAI,CAAC,CAACC,aAAeC,IAAAA,aAAM,EAACH,WAAWE,aAAa;gBAChE,oDAAoD;gBACpDnB,MAAM,CAACS,EAAE,GAAGQ;gBACZZ;gBACAW,UAAU;gBAEV,IAAIL,YAAY;oBACZH,cAAca,IAAI,CAACZ;gBACvB,OAAO;oBACHD,cAAcN,MAAM,GAAG;gBAC3B;YACJ,OAAO,IAAIS,YAAY;gBAEnB;YACJ,OAAO;gBACH,+BAA+B;gBAC/B,IAAIH,cAAcN,MAAM,GAAG,KAAKI,KAAKG,KAAKF,KAAKF,WAAW,GAAG;oBACzD,MAAMiB,gBAAgBd,cAAce,GAAG;oBACvCvB,MAAM,CAACsB,cAAc,GAAGlB;oBACxBC;oBACA;gBACJ;gBAEA,qCAAqC;gBACrC,MAAM,IAAImB,MAAM,CAAC,qCAAqC,EAAEf,EAAE,YAAY,EAAEC,KAAK,EAAE,CAAC;YACpF;QACJ;QAEA,IAAI,CAACM,WAAW,CAACL,YAAY;YACzB,+BAA+B;YAC/B,IAAIH,cAAcN,MAAM,GAAG,KAAKI,KAAKG,KAAKF,KAAKF,WAAW,GAAG;gBACzD,MAAMiB,gBAAgBd,cAAce,GAAG;gBACvCvB,MAAM,CAACsB,cAAc,GAAGlB;gBACxBC;gBACAI;YACJ,OAAO;gBACH,MAAM,IAAIe,MAAM,CAAC,0BAA0B,EAAEf,EAAE,YAAY,EAAEC,KAAK,EAAE,CAAC;YACzE;QACJ;IACJ;IAEA,OAAOV;AACX;MAEA,WAAeH"}