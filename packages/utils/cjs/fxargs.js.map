{"version":3,"sources":["../src/fxargs.js"],"sourcesContent":["import { typeOf } from '@kitmi/types';\n\n/**\n * Function arguments extractor.\n * @param {Array} args - Array of function arguments\n * @param {Array} types - Array of types, with suffix `?` as optional\n * @example\n *  function withClient(...args) {\n *      const [server, authenticator, testToRun, options] = fxargs(args, ['string?', 'string?', 'function', 'object?']);\n *      // ...  \n *  }\n * \n *  1. withClient('http://localhost:3000', 'admin', (app) => {});\n *      - server: 'http://localhost:3000'\n *      - authenticator: 'admin'\n *      - testToRun: (app) => {}\n *      - options: undefined \n * \n *  2. withClient('http://localhost:3000', (app) => {});\n *      - server: 'http://localhost:3000'\n *      - authenticator: undefined\n *      - testToRun: (app) => {}\n *      - options: undefined\n * \n *  3. withClient((app) => {});\n *      - server: undefined\n *      - authenticator: undefined\n *      - testToRun: (app) => {}\n *      - options: undefined\n */\nfunction fxargs(args, types) {\n    const result = new Array(types.length).fill(undefined);\n    let argIndex = 0;\n\n    for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        const isOptional = type.endsWith('?');\n        const typeName = isOptional ? type.slice(0, -1) : type;\n        const value = args[argIndex];\n\n        // If there's a type mismatch and the type is optional, skip filling the result for this type\n        if (value === undefined) {\n            if (!isOptional) {\n                throw new Error(`Missing argument at index ${i}`);\n            }\n\n            continue;\n        }       \n\n        if (typeOf(value) !== typeName) {\n            if (!isOptional) {\n                if (typeName !== 'any') {\n                    throw new Error(`Invalid argument at index ${i}: expected type \"${typeName}\", got \"undefined\"`);\n                }\n            }\n\n            continue;\n        }        \n\n        // Assign the value and increment the argument index\n        result[i] = value;\n        argIndex++;\n    }\n\n    return result;\n}\n\nexport default fxargs;"],"names":["fxargs","args","types","result","Array","length","fill","undefined","argIndex","i","type","isOptional","endsWith","typeName","slice","value","Error","typeOf"],"mappings":";;;;+BAmEA;;;eAAA;;;uBAnEuB;AAEvB;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2BC,GACD,SAASA,OAAOC,IAAI,EAAEC,KAAK;IACvB,MAAMC,SAAS,IAAIC,MAAMF,MAAMG,MAAM,EAAEC,IAAI,CAACC;IAC5C,IAAIC,WAAW;IAEf,IAAK,IAAIC,IAAI,GAAGA,IAAIP,MAAMG,MAAM,EAAEI,IAAK;QACnC,MAAMC,OAAOR,KAAK,CAACO,EAAE;QACrB,MAAME,aAAaD,KAAKE,QAAQ,CAAC;QACjC,MAAMC,WAAWF,aAAaD,KAAKI,KAAK,CAAC,GAAG,CAAC,KAAKJ;QAClD,MAAMK,QAAQd,IAAI,CAACO,SAAS;QAE5B,6FAA6F;QAC7F,IAAIO,UAAUR,WAAW;YACrB,IAAI,CAACI,YAAY;gBACb,MAAM,IAAIK,MAAM,CAAC,0BAA0B,EAAEP,EAAE,CAAC;YACpD;YAEA;QACJ;QAEA,IAAIQ,IAAAA,aAAM,EAACF,WAAWF,UAAU;YAC5B,IAAI,CAACF,YAAY;gBACb,IAAIE,aAAa,OAAO;oBACpB,MAAM,IAAIG,MAAM,CAAC,0BAA0B,EAAEP,EAAE,iBAAiB,EAAEI,SAAS,kBAAkB,CAAC;gBAClG;YACJ;YAEA;QACJ;QAEA,oDAAoD;QACpDV,MAAM,CAACM,EAAE,GAAGM;QACZP;IACJ;IAEA,OAAOL;AACX;MAEA,WAAeH"}