{"version":3,"sources":["../src/fxargs.js"],"sourcesContent":["import { typeOf } from '@kitmi/types';\n\n/**\n * Function arguments extractor.\n * @param {Array} args - Array of function arguments\n * @param {Array} types - Array of types, with suffix `?` as optional\n * @example\n *  function withClient(...args) {\n *      const [server, authenticator, testToRun, options] = fxargs(args, ['string?', 'string?', 'function', 'object?']);\n *      // ...\n *  }\n *\n *  1. withClient('http://localhost:3000', 'admin', (app) => {});\n *      - server: 'http://localhost:3000'\n *      - authenticator: 'admin'\n *      - testToRun: (app) => {}\n *      - options: undefined\n *\n *  2. withClient('http://localhost:3000', (app) => {});\n *      - server: 'http://localhost:3000'\n *      - authenticator: undefined\n *      - testToRun: (app) => {}\n *      - options: undefined\n *\n *  3. withClient((app) => {});\n *      - server: undefined\n *      - authenticator: undefined\n *      - testToRun: (app) => {}\n *      - options: undefined\n */\nfunction fxargs(args, types) {\n    const result = new Array(types.length).fill(undefined);\n    let argIndex = 0, lt = types.length, la = args.length;\n\n    for (let i = 0; i < lt; i++) {\n        const type = types[i];\n        const isOptional = type.endsWith('?');\n        const typeOptions = isOptional ? type.slice(0, -1).split('|') : type.split('|');\n\n        let matched = false;\n\n        // Iterate over remaining args to find a match\n        while (argIndex < la && !matched) {\n            const value = args[argIndex];\n            if (typeOptions.some((typeOption) => typeOf(value) === typeOption)) {\n                // Assign the value and increment the argument index\n                result[i] = value;\n                argIndex++;\n                matched = true;\n            } else if (isOptional) {\n                // If the type is optional and no match found, break to allow for undefined\n                break;\n            } else {\n                // No match found for a required type\n                throw new Error(`Missing or invalid argument at index ${i}, expected \"${type}\".`);\n            }\n        }\n\n        if (!matched && !isOptional) {\n            throw new Error(`Missing argument at index ${i}, expected \"${type}\".`);\n        }\n    }\n\n    return result;\n}\n\nexport default fxargs;\n"],"names":["fxargs","args","types","result","Array","length","fill","undefined","argIndex","lt","la","i","type","isOptional","endsWith","typeOptions","slice","split","matched","value","some","typeOption","typeOf","Error"],"mappings":";;;;+BAkEA;;;eAAA;;;uBAlEuB;AAEvB;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2BC,GACD,SAASA,OAAOC,IAAI,EAAEC,KAAK;IACvB,MAAMC,SAAS,IAAIC,MAAMF,MAAMG,MAAM,EAAEC,IAAI,CAACC;IAC5C,IAAIC,WAAW,GAAGC,KAAKP,MAAMG,MAAM,EAAEK,KAAKT,KAAKI,MAAM;IAErD,IAAK,IAAIM,IAAI,GAAGA,IAAIF,IAAIE,IAAK;QACzB,MAAMC,OAAOV,KAAK,CAACS,EAAE;QACrB,MAAME,aAAaD,KAAKE,QAAQ,CAAC;QACjC,MAAMC,cAAcF,aAAaD,KAAKI,KAAK,CAAC,GAAG,CAAC,GAAGC,KAAK,CAAC,OAAOL,KAAKK,KAAK,CAAC;QAE3E,IAAIC,UAAU;QAEd,8CAA8C;QAC9C,MAAOV,WAAWE,MAAM,CAACQ,QAAS;YAC9B,MAAMC,QAAQlB,IAAI,CAACO,SAAS;YAC5B,IAAIO,YAAYK,IAAI,CAAC,CAACC,aAAeC,IAAAA,aAAM,EAACH,WAAWE,aAAa;gBAChE,oDAAoD;gBACpDlB,MAAM,CAACQ,EAAE,GAAGQ;gBACZX;gBACAU,UAAU;YACd,OAAO,IAAIL,YAAY;gBAEnB;YACJ,OAAO;gBACH,qCAAqC;gBACrC,MAAM,IAAIU,MAAM,CAAC,qCAAqC,EAAEZ,EAAE,YAAY,EAAEC,KAAK,EAAE,CAAC;YACpF;QACJ;QAEA,IAAI,CAACM,WAAW,CAACL,YAAY;YACzB,MAAM,IAAIU,MAAM,CAAC,0BAA0B,EAAEZ,EAAE,YAAY,EAAEC,KAAK,EAAE,CAAC;QACzE;IACJ;IAEA,OAAOT;AACX;MAEA,WAAeH"}