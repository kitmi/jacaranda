{"version":3,"sources":["../src/set.js"],"sourcesContent":["import isPlainObject from './isPlainObject';\nimport _each from 'lodash/each';\nimport isInteger, { RANGE_INDEX } from './isInteger';\n\n// attention: since mobx will wrap the object in a Proxy, the source value will be different from the wrapped one\n// Here must return the obj[index] of obj[key], otherwise the child node will not be mounted to the root object\n\nexport const addEntry = (obj, key, value, numberAsArrayIndex) => {\n    if (numberAsArrayIndex && isInteger(key, { range: RANGE_INDEX })) {\n        if (Array.isArray(obj)) {\n            const index = parseInt(key, 10);\n\n            if (obj.length <= index) {\n                const numToFill = index - obj.length;\n                if (numToFill > 0) {\n                    for (let i = 0; i < numToFill; i++) {\n                        obj.push(undefined);\n                    }\n                }\n\n                obj.push(value);\n            } else {\n                obj[index] = value;\n            }\n\n            return obj[index];\n        }\n    }\n\n    obj[key] = value;\n    return obj[key];\n};\n\n/**\n * Set a value by dot-separated path or key array into a collection\n * Does not support '[i]', e.g. 'a[0].b.c' style accessor, use [ 'a',  0, 'b', 'c' ] instead, different from lodash/set\n * @alias  object.set\n * @param {Object} collection - The collection\n * @param {string} keyPath - A dot-separated path (dsp) or a key array, e.g. settings.xxx.yyy, or ['setting', 'xxx', 'yyy']\n * @param {Object} value - The default value if the path does not exist\n * @returns {*}\n */\nconst _set = (collection, keyPath, value, options) => {\n    options = { numberAsArrayIndex: true, keyPathSeparator: '.', ...options };\n\n    if (collection == null || typeof collection !== 'object') {\n        return collection;\n    }\n\n    if (keyPath == null) {\n        return collection;\n    }\n\n    if (isPlainObject(keyPath) && typeof value === 'undefined') {\n        // extract all key value pair and set\n        _each(keyPath, (v, k) => _set(collection, k, v, options));\n        return collection;\n    }\n\n    // break the path into nodes array\n    let nodes = Array.isArray(keyPath) ? keyPath.concat() : keyPath.split(options.keyPathSeparator);\n    const length = nodes.length;\n\n    if (length > 0) {\n        const lastIndex = length - 1;\n\n        let index = 0;\n        let nested = collection;\n\n        while (nested != null && index < lastIndex) {\n            const key = nodes[index++];\n\n            let next = nested[key];\n            if (next == null || typeof next !== 'object') {\n                // peek next node, see if it is integer\n                const nextKey = nodes[index];\n\n                if (options.numberAsArrayIndex && isInteger(nextKey, { range: RANGE_INDEX })) {\n                    next = addEntry(nested, key, [], options.numberAsArrayIndex);\n                } else {\n                    next = addEntry(nested, key, {}, options.numberAsArrayIndex);\n                }\n            }\n\n            nested = next;\n        }\n\n        const lastKey = nodes[lastIndex];\n        addEntry(nested, lastKey, value, options.numberAsArrayIndex);\n    }\n\n    return collection;\n};\n\nexport default _set;\n"],"names":["addEntry","obj","key","value","numberAsArrayIndex","isInteger","range","RANGE_INDEX","Array","isArray","index","parseInt","length","numToFill","i","push","undefined","_set","collection","keyPath","options","keyPathSeparator","isPlainObject","_each","v","k","nodes","concat","split","lastIndex","nested","next","nextKey","lastKey"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";;;;;;;;;;;IAOaA,QAAQ;eAARA;;IAuFb,OAAoB;eAApB;;;sEA9F0B;6DACR;mEACqB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKhC,MAAMA,WAAW,CAACC,KAAKC,KAAKC,OAAOC;IACtC,IAAIA,sBAAsBC,IAAAA,kBAAS,EAACH,KAAK;QAAEI,OAAOC,sBAAW;IAAC,IAAI;QAC9D,IAAIC,MAAMC,OAAO,CAACR,MAAM;YACpB,MAAMS,QAAQC,SAAST,KAAK;YAE5B,IAAID,IAAIW,MAAM,IAAIF,OAAO;gBACrB,MAAMG,YAAYH,QAAQT,IAAIW,MAAM;gBACpC,IAAIC,YAAY,GAAG;oBACf,IAAK,IAAIC,IAAI,GAAGA,IAAID,WAAWC,IAAK;wBAChCb,IAAIc,IAAI,CAACC;oBACb;gBACJ;gBAEAf,IAAIc,IAAI,CAACZ;YACb,OAAO;gBACHF,GAAG,CAACS,MAAM,GAAGP;YACjB;YAEA,OAAOF,GAAG,CAACS,MAAM;QACrB;IACJ;IAEAT,GAAG,CAACC,IAAI,GAAGC;IACX,OAAOF,GAAG,CAACC,IAAI;AACnB;AAEA;;;;;;;;CAQC,GACD,MAAMe,OAAO,CAACC,YAAYC,SAAShB,OAAOiB;IACtCA,UAAU;QAAEhB,oBAAoB;QAAMiB,kBAAkB;QAAK,GAAGD,OAAO;IAAC;IAExE,IAAIF,cAAc,QAAQ,OAAOA,eAAe,UAAU;QACtD,OAAOA;IACX;IAEA,IAAIC,WAAW,MAAM;QACjB,OAAOD;IACX;IAEA,IAAII,IAAAA,sBAAa,EAACH,YAAY,OAAOhB,UAAU,aAAa;QACxD,qCAAqC;QACrCoB,IAAAA,aAAK,EAACJ,SAAS,CAACK,GAAGC,IAAMR,KAAKC,YAAYO,GAAGD,GAAGJ;QAChD,OAAOF;IACX;IAEA,kCAAkC;IAClC,IAAIQ,QAAQlB,MAAMC,OAAO,CAACU,WAAWA,QAAQQ,MAAM,KAAKR,QAAQS,KAAK,CAACR,QAAQC,gBAAgB;IAC9F,MAAMT,SAASc,MAAMd,MAAM;IAE3B,IAAIA,SAAS,GAAG;QACZ,MAAMiB,YAAYjB,SAAS;QAE3B,IAAIF,QAAQ;QACZ,IAAIoB,SAASZ;QAEb,MAAOY,UAAU,QAAQpB,QAAQmB,UAAW;YACxC,MAAM3B,MAAMwB,KAAK,CAAChB,QAAQ;YAE1B,IAAIqB,OAAOD,MAAM,CAAC5B,IAAI;YACtB,IAAI6B,QAAQ,QAAQ,OAAOA,SAAS,UAAU;gBAC1C,uCAAuC;gBACvC,MAAMC,UAAUN,KAAK,CAAChB,MAAM;gBAE5B,IAAIU,QAAQhB,kBAAkB,IAAIC,IAAAA,kBAAS,EAAC2B,SAAS;oBAAE1B,OAAOC,sBAAW;gBAAC,IAAI;oBAC1EwB,OAAO/B,SAAS8B,QAAQ5B,KAAK,EAAE,EAAEkB,QAAQhB,kBAAkB;gBAC/D,OAAO;oBACH2B,OAAO/B,SAAS8B,QAAQ5B,KAAK,CAAC,GAAGkB,QAAQhB,kBAAkB;gBAC/D;YACJ;YAEA0B,SAASC;QACb;QAEA,MAAME,UAAUP,KAAK,CAACG,UAAU;QAChC7B,SAAS8B,QAAQG,SAAS9B,OAAOiB,QAAQhB,kBAAkB;IAC/D;IAEA,OAAOc;AACX;MAEA,WAAeD"}