{"version":3,"sources":["../../../src/drivers/postgres/EntityModel.js"],"sourcesContent":["const { _, eachAsync_ } = require('@genx/july');\nconst EntityModel = require('../../EntityModel');\nconst {\n    ApplicationError,\n    ReferencedNotExistError,\n    DuplicateError,\n    ValidationError,\n    InvalidArgument,\n} = require('../../utils/Errors');\nconst Types = require('../../types');\nconst { getValueFrom, mapFilter } = require('../../utils/lang');\n\nconst defaultNestedKeyGetter = (anchor) => ':' + anchor;\n\n/**\n * MySQL entity model class.\n */\nclass MySQLEntityModel extends EntityModel {\n    /**\n     * [specific] Check if this entity has auto increment feature.\n     */\n    static get hasAutoIncrement() {\n        const autoId = this.meta.features.autoId;\n        return autoId && this.meta.fields[autoId.field].autoIncrementId;\n    }\n\n    /**\n     * [override]\n     * @param {*} entityObj\n     * @param {*} keyPath\n     */\n    static getNestedObject(entityObj, keyPath) {\n        return _.get(\n            entityObj,\n            keyPath\n                .split('.')\n                .map((p) => ':' + p)\n                .join('.')\n        );\n    }\n\n    /**\n     * [override] Serialize value into database acceptable format.\n     * @param {object} name - Name of the symbol token\n     */\n    static _translateSymbolToken(name) {\n        if (name === 'NOW') {\n            return this.db.connector.raw('NOW()');\n        }\n\n        throw new Error('not support: ' + name);\n    }\n\n    /**\n     * [override]\n     * @param {*} value\n     * @param {*} info\n     */\n    static _serializeByTypeInfo(value, info) {\n        if (info.type === 'boolean') {\n            return value ? 1 : 0;\n        }\n\n        if (info.type === 'datetime') {\n            return Types.DATETIME.serialize(value);\n        }\n\n        if (info.type === 'array' && Array.isArray(value)) {\n            if (info.csv) {\n                return Types.ARRAY.toCsv(value);\n            } else {\n                return Types.ARRAY.serialize(value);\n            }\n        }\n\n        if (info.type === 'object') {\n            return Types.OBJECT.serialize(value);\n        }\n\n        return value;\n    }\n\n    static async create_(...args) {\n        try {\n            return await super.create_(...args);\n        } catch (error) {\n            const errorCode = error.code;\n\n            if (errorCode === 'ER_NO_REFERENCED_ROW_2') {\n                throw new ReferencedNotExistError(\n                    'The new entity is referencing to an unexisting entity. Detail: ' +\n                        error.message,\n                    error.info\n                );\n            } else if (errorCode === 'ER_DUP_ENTRY') {\n                throw new DuplicateError(\n                    error.message +\n                        ` while creating a new \"${this.meta.name}\".`,\n                    error.info\n                );\n            }\n\n            throw error;\n        }\n    }\n\n    static async updateOne_(...args) {\n        try {\n            return await super.updateOne_(...args);\n        } catch (error) {\n            const errorCode = error.code;\n\n            if (errorCode === 'ER_NO_REFERENCED_ROW_2') {\n                throw new ReferencedNotExistError(\n                    'The entity to be updated is referencing to an unexisting entity. Detail: ' +\n                        error.message,\n                    error.info\n                );\n            } else if (errorCode === 'ER_DUP_ENTRY') {\n                throw new DuplicateError(\n                    error.message +\n                        ` while updating an existing \"${this.meta.name}\".`,\n                    error.info\n                );\n            }\n\n            throw error;\n        }\n    }\n\n    static async _doReplaceOne_(context) {\n        await this.ensureTransaction_(context);\n\n        const entity = await this.findOne_(\n            { $query: context.options.$query },\n            context.connOptions\n        );\n\n        let ret, options;\n\n        if (entity) {\n            if (context.options.$retrieveExisting) {\n                context.rawOptions.$existing = entity;\n            }\n\n            options = {\n                ...context.options,\n                $query: { [this.meta.keyField]: super.valueOfKey(entity) },\n                $existing: entity,\n            };\n\n            ret = await this.updateOne_(\n                context.raw,\n                options,\n                context.connOptions\n            );\n        } else {\n            options = {\n                ..._.omit(context.options, [\n                    '$retrieveUpdated',\n                    '$bypassEnsureUnique',\n                ]),\n                $retrieveCreated: context.options.$retrieveUpdated,\n            };\n\n            ret = await this.create_(context.raw, options, context.connOptions);\n        }\n\n        if (options.$existing) {\n            context.rawOptions.$existing = options.$existing;\n        }\n\n        if (options.$result) {\n            context.rawOptions.$result = options.$result;\n        }\n\n        return ret;\n    }\n\n    static _internalBeforeCreate_(context) {\n        return true;\n    }\n\n    static _fillResult(context) {\n        if (this.hasAutoIncrement && context.result.affectedRows > 0) {\n            const { insertId } = context.result;\n            if (insertId > 0) {\n                context.latest = {\n                    ...context.latest,\n                    [this.meta.features.autoId.field]: insertId,\n                };\n            } else if (context.result.upsert) {\n                // the key is not correct \n                delete context.latest[this.meta.features.autoId.field];\n            }\n        } else if (context.result.upsert) {\n            // the key is not used \n            delete context.latest[this.meta.keyField];\n        }\n\n        context.return = context.latest;\n    }\n\n    /**\n     * Post create processing.\n     * @param {*} context\n     * @property {object} [context.options] - Create options\n     * @property {bool} [options.$retrieveCreated] - Retrieve the newly created record from db.\n     */\n    static async _internalAfterCreate_(context) {\n        if (context.options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result;\n        }\n\n        if (context.options.$retrieveCreated) {\n            if (this.hasAutoIncrement) {\n                if (context.result.affectedRows === 0) {\n                    // insert ignored\n                    context.queryKey = this.getUniqueKeyValuePairsFrom(\n                        context.latest\n                    );\n\n                    if (_.isEmpty(context.queryKey)) {\n                        throw new ApplicationError(\n                            'Cannot extract unique keys from input data.',\n                            {\n                                entity: this.meta.name,\n                            }\n                        );\n                    }\n                } else {\n                    const { insertId } = context.result;\n                    context.queryKey = {\n                        [this.meta.features.autoId.field]: insertId,\n                    };\n                }\n            } else {\n                context.queryKey = this.getUniqueKeyValuePairsFrom(\n                    context.latest\n                );\n\n                if (_.isEmpty(context.queryKey)) {\n                    throw new ApplicationError(\n                        'Cannot extract unique keys from input data.',\n                        {\n                            entity: this.meta.name,\n                        }\n                    );\n                }\n            }\n\n            const retrieveOptions = _.isPlainObject(\n                context.options.$retrieveCreated\n            )\n                ? context.options.$retrieveCreated\n                : {};\n            context.return = await this.findOne_(\n                { ...retrieveOptions, $query: context.queryKey },\n                context.connOptions\n            );\n        } else {\n            if (this.hasAutoIncrement) {\n                if (context.result.affectedRows === 0) {\n                    context.queryKey = this.getUniqueKeyValuePairsFrom(\n                        context.latest\n                    );\n                } else {\n                    const { insertId } = context.result;\n                    context.queryKey = {\n                        [this.meta.features.autoId.field]: insertId,\n                    };\n                }\n            }\n        }\n    }\n\n    static _internalBeforeUpdate_(context) {\n        return true;\n    }\n\n    static _internalBeforeUpdateMany_(context) {\n        return true;\n    }\n\n    /**\n     * Post update processing.\n     * @param {*} context\n     * @property {object} [context.options] - Update options\n     * @property {bool} [context.options.$retrieveUpdated] - Retrieve the newly updated record from db.\n     */\n    static async _internalAfterUpdate_(context) {\n        const options = context.options;\n\n        if (options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result || {\n                affectedRows: 0,\n                changedRows: 0,\n            };\n        }\n\n        let retrieveUpdated = options.$retrieveUpdated;\n\n        if (!retrieveUpdated) {\n            if (\n                options.$retrieveActualUpdated &&\n                context.result.affectedRows > 0\n            ) {\n                retrieveUpdated = options.$retrieveActualUpdated;\n            } else if (\n                options.$retrieveNotUpdate &&\n                context.result.affectedRows === 0\n            ) {\n                retrieveUpdated = options.$retrieveNotUpdate;\n            }\n        }\n\n        if (retrieveUpdated) {\n            const condition = {\n                $query: this.getUniqueKeyValuePairsFrom(options.$query),\n            };\n            if (options.$bypassEnsureUnique) {\n                condition.$bypassEnsureUnique = options.$bypassEnsureUnique;\n            }\n\n            let retrieveOptions = {};\n\n            if (_.isPlainObject(retrieveUpdated)) {\n                retrieveOptions = retrieveUpdated;\n            } else if (options.$relationships) {\n                retrieveOptions.$relationships = options.$relationships;\n            }\n\n            context.return = await this.findOne_(\n                {\n                    ...condition,\n                    $includeDeleted: options.$retrieveDeleted,\n                    ...retrieveOptions,\n                },\n                context.connOptions\n            );\n\n            if (context.return) {\n                context.queryKey = this.getUniqueKeyValuePairsFrom(\n                    context.return\n                );\n            } else {\n                context.queryKey = condition.$query;\n            }\n        }\n    }\n\n    /**\n     * Post update processing.\n     * @param {*} context\n     * @param {object} [options] - Update options\n     * @property {bool} [options.$retrieveUpdated] - Retrieve the newly updated record from db.\n     */\n    static async _internalAfterUpdateMany_(context) {\n        const options = context.options;\n\n        if (options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result || {\n                affectedRows: 0,\n                changedRows: 0,\n            };\n\n            /**\n             * afterUpdateMany ResultSetHeader {\n             * fieldCount: 0,\n             * affectedRows: 1,\n             * insertId: 0,\n             * info: 'Rows matched: 1  Changed: 1  Warnings: 0',\n             * serverStatus: 3,\n             * warningStatus: 0,\n             * changedRows: 1 }\n             */\n        }\n\n        if (options.$retrieveUpdated) {\n            let retrieveOptions = {};\n\n            if (_.isPlainObject(options.$retrieveUpdated)) {\n                retrieveOptions = options.$retrieveUpdated;\n            } else if (options.$relationships) {\n                retrieveOptions.$relationships = options.$relationships;\n            }\n\n            context.return = await this.findAll_(\n                {\n                    $query: options.$query,\n                    $includeDeleted: options.$retrieveDeleted,\n                    ...retrieveOptions,\n                },\n                context.connOptions\n            );\n        }\n\n        context.queryKey = options.$query;\n    }\n\n    /**\n     * Before deleting an entity.\n     * @param {*} context\n     * @property {object} [context.options] - Delete options\n     * @property {bool} [context.options.$retrieveDeleted] - Retrieve the recently deleted record from db.\n     */\n    static async _internalBeforeDelete_(context) {\n        if (context.options.$retrieveDeleted) {\n            await this.ensureTransaction_(context);\n\n            const retrieveOptions = _.isPlainObject(\n                context.options.$retrieveDeleted\n            )\n                ? {\n                      ...context.options.$retrieveDeleted,\n                      $query: context.options.$query,\n                  }\n                : { $query: context.options.$query };\n\n            if (context.options.$physicalDeletion) {\n                retrieveOptions.$includeDeleted = true;\n            }\n\n            context.return = context.existing = await this.findOne_(\n                retrieveOptions,\n                context.connOptions\n            );\n        }\n\n        return true;\n    }\n\n    static async _internalBeforeDeleteMany_(context) {\n        if (context.options.$retrieveDeleted) {\n            await this.ensureTransaction_(context);\n\n            const retrieveOptions = _.isPlainObject(\n                context.options.$retrieveDeleted\n            )\n                ? {\n                      ...context.options.$retrieveDeleted,\n                      $query: context.options.$query,\n                  }\n                : { $query: context.options.$query };\n\n            if (context.options.$physicalDeletion) {\n                retrieveOptions.$includeDeleted = true;\n            }\n\n            context.return = context.existing = await this.findAll_(\n                retrieveOptions,\n                context.connOptions\n            );\n        }\n\n        return true;\n    }\n\n    /**\n     * Post delete processing.\n     * @param {*} context\n     */\n    static _internalAfterDelete_(context) {\n        if (context.options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result;\n        }\n    }\n\n    /**\n     * Post delete processing.\n     * @param {*} context\n     */\n    static _internalAfterDeleteMany_(context) {\n        if (context.options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result;\n        }\n    }\n\n    /**\n     *\n     * @param {*} findOptions\n     */\n    static _prepareAssociations(findOptions) {\n        const [normalAssocs, customAssocs] = _.partition(\n            findOptions.$association,\n            (assoc) => typeof assoc === 'string'\n        );\n\n        const associations = _.uniq(normalAssocs).sort().concat(customAssocs);\n        const assocTable = {};\n            let counter = 0;\n            const cache = {};\n\n        associations.forEach((assoc) => {\n            if (_.isPlainObject(assoc)) {\n                assoc = this._translateSchemaNameToDb(assoc);\n\n                let alias = assoc.alias;\n                if (!assoc.alias) {\n                    alias = ':join' + ++counter;\n                }\n\n                assocTable[alias] = {\n                    entity: assoc.entity,\n                    joinType: assoc.type,\n                    output: assoc.output,\n                    key: assoc.key,\n                    alias,\n                    on: assoc.on,\n                    ...(assoc.dataset\n                        ? this.db.connector.buildQuery(\n                              assoc.entity,\n                              assoc.model._prepareQueries({\n                                  ...assoc.dataset,\n                                  $variables: findOptions.$variables,\n                              })\n                          )\n                        : {}),\n                };\n            } else {\n                this._loadAssocIntoTable(assocTable, cache, assoc);\n            }\n        });\n\n        return assocTable;\n    }\n\n    /**\n     *\n     * @param {*} assocTable - Hierarchy with subAssocs\n     * @param {*} cache - Dotted path as key\n     * @param {*} assoc - Dotted path\n     */\n    static _loadAssocIntoTable(assocTable, cache, assoc) {\n        if (cache[assoc]) return cache[assoc];\n\n        const lastPos = assoc.lastIndexOf('.');\n        let result;\n\n        if (lastPos === -1) {\n            // direct association\n            const assocInfo = { ...this.meta.associations[assoc] };\n            if (_.isEmpty(assocInfo)) {\n                throw new InvalidArgument(\n                    `Entity \"${this.meta.name}\" does not have the association \"${assoc}\".`\n                );\n            }\n\n            result =\n                cache[assoc] =\n                assocTable[assoc] =\n                    { ...this._translateSchemaNameToDb(assocInfo) };\n        } else {\n            const base = assoc.substr(0, lastPos);\n            const last = assoc.substr(lastPos + 1);\n\n            let baseNode = cache[base];\n            if (!baseNode) {\n                baseNode = this._loadAssocIntoTable(assocTable, cache, base);\n            }\n\n            const entity = baseNode.model || this.db.model(baseNode.entity);\n            const assocInfo = { ...entity.meta.associations[last] };\n            if (_.isEmpty(assocInfo)) {\n                throw new InvalidArgument(\n                    `Entity \"${entity.meta.name}\" does not have the association \"${assoc}\".`\n                );\n            }\n\n            result = { ...entity._translateSchemaNameToDb(assocInfo, this.db) };\n\n            if (!baseNode.subAssocs) {\n                baseNode.subAssocs = {};\n            }\n\n            cache[assoc] = baseNode.subAssocs[last] = result;\n        }\n\n        if (result.assoc) {\n            this._loadAssocIntoTable(\n                assocTable,\n                cache,\n                assoc + '.' + result.assoc\n            );\n        }\n\n        return result;\n    }\n\n    static _translateSchemaNameToDb(assoc, currentDb) {\n        if (!assoc.entity) {\n            throw new ApplicationError('\"entity\" is required in the association object.');\n        }\n\n        if (assoc.entity.indexOf('.') > 0) {\n            const [schemaName, entityName] = assoc.entity.split('.', 2);\n\n            const app = this.db.app;\n\n            const refDb = app.db(schemaName);\n            if (!refDb) {\n                throw new ApplicationError(\n                    `The referenced schema \"${schemaName}\" does not have db model in the same application.`\n                );\n            }\n\n            assoc.entity = refDb.connector.database + '.' + entityName;\n            assoc.model = refDb.model(entityName);\n\n            if (!assoc.model) {\n                throw new ApplicationError(\n                    `Failed load the entity model \"${schemaName}.${entityName}\".`\n                );\n            }\n        } else {\n            assoc.model = this.db.model(assoc.entity);\n\n            if (currentDb && currentDb !== this.db) {\n                assoc.entity = this.db.connector.database + '.' + assoc.entity;\n            }\n        }\n\n        if (!assoc.key) {\n            assoc.key = assoc.model.meta.keyField;\n        }\n\n        return assoc;\n    }\n\n    static _mapRecordsToObjects(\n        [rows, columns, aliasMap],\n        hierarchy,\n        nestedKeyGetter\n    ) {\n        nestedKeyGetter == null && (nestedKeyGetter = defaultNestedKeyGetter);\n        aliasMap = _.mapValues(aliasMap, (chain) =>\n            chain.map((anchor) => nestedKeyGetter(anchor))\n        );\n\n        const mainIndex = {};\n        const self = this;\n\n        // map mysql column result into array of { table <table alias>, name: <column name> }\n        columns = columns.map((col) => {\n            if (col.table === '') {\n                const pos = col.name.indexOf('$');\n                if (pos > 0) {\n                    return {\n                        table: col.name.substr(0, pos),\n                        name: col.name.substr(pos + 1),\n                    };\n                }\n\n                return {\n                    table: 'A',\n                    name: col.name,\n                };\n            }\n\n            return {\n                table: col.table,\n                name: col.name,\n            };\n        });\n\n        // map flat record into hierachy\n        function mergeRecord(existingRow, rowObject, associations, nodePath) {\n            return _.each(\n                associations,\n                ({ sql, key, list, subAssocs }, anchor) => {\n                    if (sql) return;\n\n                    const currentPath = nodePath.concat();\n                    currentPath.push(anchor);\n\n                    const objKey = nestedKeyGetter(anchor);\n                    const subObj = rowObject[objKey];\n\n                    if (!subObj) {\n                        // associated entity not in result set, probably when custom projection is used\n                        return;\n                    }\n\n                    const subIndexes = existingRow.subIndexes[objKey];\n\n                    // joined an empty record\n                    const rowKeyValue = subObj[key];\n                    if (_.isNil(rowKeyValue)) {\n                        if (list && rowKeyValue == null) {\n                            if (existingRow.rowObject[objKey]) {\n                                existingRow.rowObject[objKey].push(subObj);\n                            } else {\n                                existingRow.rowObject[objKey] = [subObj];\n                            }\n                        }\n\n                        return;\n                    }\n\n                    const existingSubRow = subIndexes && subIndexes[rowKeyValue];\n                    if (existingSubRow) {\n                        if (subAssocs) {\n                            return mergeRecord(\n                                existingSubRow,\n                                subObj,\n                                subAssocs,\n                                currentPath\n                            );\n                        }\n                    } else {\n                        if (!list) {\n                            throw new ApplicationError(\n                                `The structure of association \"${currentPath.join(\n                                    '.'\n                                )}\" with [key=${key}] of entity \"${\n                                    self.meta.name\n                                }\" should be a list.`,\n                                { existingRow, rowObject }\n                            );\n                        }\n\n                        if (existingRow.rowObject[objKey]) {\n                            existingRow.rowObject[objKey].push(subObj);\n                        } else {\n                            existingRow.rowObject[objKey] = [subObj];\n                        }\n\n                        const subIndex = {\n                            rowObject: subObj,\n                        };\n\n                        if (subAssocs) {\n                            subIndex.subIndexes = buildSubIndexes(\n                                subObj,\n                                subAssocs\n                            );\n                        }\n\n                        if (!subIndexes) {\n                            throw new ApplicationError(\n                                `The subIndexes of association \"${currentPath.join(\n                                    '.'\n                                )}\" with [key=${key}] of entity \"${\n                                    self.meta.name\n                                }\" does not exist.`,\n                                { existingRow, rowObject }\n                            );\n                        }\n\n                        subIndexes[rowKeyValue] = subIndex;\n                    }\n                }\n            );\n        }\n\n        // build sub index for list member\n        function buildSubIndexes(rowObject, associations) {\n            const indexes = {};\n\n            _.each(associations, ({ sql, key, list, subAssocs }, anchor) => {\n                if (sql) {\n                    return;\n                }\n\n                const objKey = nestedKeyGetter(anchor);\n                let subObject = rowObject[objKey];\n                const subIndex = {\n                    rowObject: subObject,\n                };\n\n                if (list) {\n                    if (!subObject) {\n                        // associated entity not in result set, probably when custom projection is used\n                        rowObject[objKey] = [];\n                        return;\n                    }\n\n                    rowObject[objKey] = [subObject];\n\n                    // many to *\n                    if (_.isNil(subObject[key])) {\n                        // when custom projection is used\n                        subObject = null;\n                    }\n                }\n\n                if (subObject) {\n                    if (subAssocs) {\n                        subIndex.subIndexes = buildSubIndexes(\n                            subObject,\n                            subAssocs\n                        );\n                    }\n\n                    indexes[objKey] = subObject[key]\n                        ? {\n                              [subObject[key]]: subIndex,\n                          }\n                        : {};\n                }\n            });\n\n            return indexes;\n        }\n\n        const arrayOfObjs = [];\n\n        // build the result object skeleton\n        const tableTemplate = columns.reduce((result, col) => {\n            if (col.table !== 'A') {\n                const bucket = result[col.table];\n                if (bucket) {\n                    bucket[col.name] = null;\n                } else {\n                    result[col.table] = { [col.name]: null };\n                }\n            }\n\n            return result;\n        }, {});\n\n        // process each row\n        rows.forEach((row) => {\n            const tableCache = {}; // from alias to child prop of rowObject\n\n            // hash-style data row\n            const rowObject = row.reduce((result, value, colIdx) => {\n                const col = columns[colIdx];\n\n                if (col.table === 'A') {\n                    result[col.name] = value;\n                } else if (value != null) {\n                    // avoid a object with all null value exists\n                    const bucket = tableCache[col.table];\n                    if (bucket) {\n                        // already nested inside\n                        bucket[col.name] = value;\n                    } else {\n                        tableCache[col.table] = {\n                            ...tableTemplate[col.table],\n                            [col.name]: value,\n                        };\n                    }\n                }\n\n                return result;\n            }, {});\n\n            _.forOwn(tableCache, (obj, table) => {\n                const nodePath = aliasMap[table];\n                _.set(rowObject, nodePath, obj);\n            });\n\n            const rowKey = rowObject[self.meta.keyField];\n            const existingRow = mainIndex[rowKey];\n            if (existingRow) {\n                return mergeRecord(existingRow, rowObject, hierarchy, []);\n            }\n\n            arrayOfObjs.push(rowObject);\n            mainIndex[rowKey] = {\n                rowObject,\n                subIndexes: buildSubIndexes(rowObject, hierarchy),\n            };\n        });\n\n        return arrayOfObjs;\n    }\n\n    /**\n     * Pre-process assoicated db operation\n     * @param {*} data\n     * @param {*} isNew - New record flag, true for creating, false for updating\n     * @returns {Array} [raw, assocs, refs];\n     */\n    static _extractAssociations(data, isNew) {\n        const raw = {};\n            const assocs = {};\n            const refs = {};\n        const meta = this.meta.associations;\n\n        _.forOwn(data, (v, k) => {\n            if (k[0] === ':') {\n                // cascade update\n                const anchor = k.substr(1);\n                const assocMeta = meta[anchor];\n                if (!assocMeta) {\n                    throw new ValidationError(\n                        `Unknown association \"${anchor}\" of entity \"${this.meta.name}\".`\n                    );\n                }\n\n                if (\n                    isNew &&\n                    (assocMeta.type === 'refersTo' ||\n                        assocMeta.type === 'belongsTo') &&\n                    anchor in data\n                ) {\n                    throw new ValidationError(\n                        `Association data \":${anchor}\" of entity \"${this.meta.name}\" conflicts with input value of field \"${anchor}\".`\n                    );\n                }\n\n                assocs[anchor] = v;\n            } else if (k[0] === '@') {\n                // update by reference\n                const anchor = k.substr(1);\n                const assocMeta = meta[anchor];\n                if (!assocMeta) {\n                    throw new ValidationError(\n                        `Unknown association \"${anchor}\" of entity \"${this.meta.name}\".`\n                    );\n                }\n\n                if (\n                    assocMeta.type !== 'refersTo' &&\n                    assocMeta.type !== 'belongsTo'\n                ) {\n                    throw new ValidationError(\n                        `Association type \"${assocMeta.type}\" cannot be used for update by reference.`,\n                        {\n                            entity: this.meta.name,\n                            data,\n                        }\n                    );\n                }\n\n                if (isNew && anchor in data) {\n                    throw new ValidationError(\n                        `Association reference \"@${anchor}\" of entity \"${this.meta.name}\" conflicts with input value of field \"${anchor}\".`\n                    );\n                }\n\n                const assocAnchor = ':' + anchor;\n                if (assocAnchor in data) {\n                    throw new ValidationError(\n                        `Association reference \"@${anchor}\" of entity \"${this.meta.name}\" conflicts with association data \"${assocAnchor}\".`\n                    );\n                }\n\n                if (v == null) {\n                    raw[anchor] = null;\n                } else {\n                    refs[anchor] = v;\n                }\n            } else {\n                raw[k] = v;\n            }\n        });\n\n        return [raw, assocs, refs];\n    }\n\n    static async _populateReferences_(context, references) {\n        const meta = this.meta.associations;\n\n        await eachAsync_(references, async (refQuery, anchor) => {\n            const assocMeta = meta[anchor];\n            const ReferencedEntity = this.db.model(assocMeta.entity);\n\n            const created = await ReferencedEntity.findOne_(\n                refQuery,\n                context.connOptions\n            );\n\n            if (!created) {\n                throw new ReferencedNotExistError(\n                    `Referenced entity \"${\n                        ReferencedEntity.meta.name\n                    }\" with ${JSON.stringify(refQuery)} not exist.`\n                );\n            }\n\n            context.raw[anchor] = created[assocMeta.field];\n        });\n    }\n\n    static async _createAssocs_(context, assocs, beforeEntityCreate) {\n        const meta = this.meta.associations;\n        let keyValue;\n\n        if (!beforeEntityCreate) {\n            keyValue = context.return[this.meta.keyField];\n\n            if (_.isNil(keyValue)) {\n                if (context.result.affectedRows === 0) {\n                    // insert ignored\n\n                    const query = this.getUniqueKeyValuePairsFrom(\n                        context.return\n                    );\n                    context.return = await this.findOne_(\n                        { $query: query },\n                        context.connOptions\n                    );\n                    if (!context.return) {\n                        throw new ApplicationError(\n                            'The parent entity is duplicated on unique keys different from the pair of keys used to query',\n                            {\n                                query,\n                                data: context.return,\n                                associations: assocs,\n                            }\n                        );\n                    }\n                }\n\n                keyValue = context.return[this.meta.keyField];\n\n                if (_.isNil(keyValue)) {\n                    throw new ApplicationError(\n                        'Missing required primary key field value. Entity: ' +\n                            this.meta.name,\n                        {\n                            data: context.return,\n                            associations: assocs,\n                        }\n                    );\n                }\n            }\n        }\n\n        const pendingAssocs = {};\n        const finished = {};\n\n        // todo: double check to ensure including all required options\n        const passOnOptions = _.pick(context.options, [\n            '$skipModifiers',\n            '$migration',\n            '$variables',\n            '$upsert',\n            '$dryRun'\n        ]);\n\n        await eachAsync_(assocs, async (data, anchor) => {\n            const assocMeta = meta[anchor];\n\n            if (\n                beforeEntityCreate &&\n                assocMeta.type !== 'refersTo' &&\n                assocMeta.type !== 'belongsTo'\n            ) {\n                pendingAssocs[anchor] = data;\n                return;\n            }\n\n            const assocModel = this.db.model(assocMeta.entity);\n\n            if (assocMeta.list) {\n                data = _.castArray(data);\n\n                if (!assocMeta.field) {\n                    throw new ApplicationError(\n                        `Missing \"field\" property in the metadata of association \"${anchor}\" of entity \"${this.meta.name}\".`\n                    );\n                }\n\n                return eachAsync_(data, (item) =>\n                    assocModel.create_(\n                        { ...item, [assocMeta.field]: keyValue },\n                        passOnOptions,\n                        context.connOptions\n                    )\n                );\n            } else if (!_.isPlainObject(data)) {\n                if (Array.isArray(data)) {\n                    throw new ApplicationError(\n                        `Invalid type of associated entity (${assocMeta.entity}) data triggered from \"${this.meta.name}\" entity. Singular value expected (${anchor}), but an array is given instead.`\n                    );\n                }\n\n                if (!assocMeta.assoc) {\n                    throw new ApplicationError(\n                        `The associated field of relation \"${anchor}\" does not exist in the entity meta data.`\n                    );\n                }\n\n                data = { [assocMeta.assoc]: data };\n            }\n\n            if (!beforeEntityCreate && assocMeta.field) {\n                // hasMany or hasOne\n                data = { ...data, [assocMeta.field]: keyValue };\n            }\n\n            passOnOptions.$retrieveDbResult = true;\n            let created = await assocModel.create_(\n                data,\n                passOnOptions,\n                context.connOptions\n            );\n\n            if (\n                passOnOptions.$result.affectedRows === 0 ||\n                (assocModel.hasAutoIncrement &&\n                    passOnOptions.$result.insertId === 0)\n            ) {\n                // insert ignored or upserted\n\n                const assocQuery = assocModel.getUniqueKeyValuePairsFrom(data);\n\n                created = await assocModel.findOne_(\n                    { $query: assocQuery },\n                    context.connOptions\n                );\n                if (!created) {\n                    throw new ApplicationError(\n                        'The assoicated entity is duplicated on unique keys different from the pair of keys used to query',\n                        {\n                            query: assocQuery,\n                            data,\n                        }\n                    );\n                }\n            }\n\n            finished[anchor] = beforeEntityCreate\n                ? created[assocMeta.field]\n                : created[assocMeta.key];\n        });\n\n        if (beforeEntityCreate) {\n            _.forOwn(finished, (refFieldValue, localField) => {\n                context.raw[localField] = refFieldValue;\n            });\n        }\n\n        return pendingAssocs;\n    }\n\n    static async _updateAssocs_(\n        context,\n        assocs,\n        beforeEntityUpdate,\n        forSingleRecord\n    ) {\n        const meta = this.meta.associations;\n\n        let currentKeyValue;\n\n        if (!beforeEntityUpdate) {\n            currentKeyValue = getValueFrom(\n                [context.options.$query, context.return],\n                this.meta.keyField\n            );\n            if (_.isNil(currentKeyValue)) {\n                // should have in updating\n                throw new ApplicationError(\n                    'Missing required primary key field value. Entity: ' +\n                        this.meta.name\n                );\n            }\n        }\n\n        const pendingAssocs = {};\n\n        // todo: double check to ensure including all required options\n        const passOnOptions = _.pick(context.options, [\n            '$skipModifiers',\n            '$migration',\n            '$variables',\n            '$upsert',\n        ]);\n\n        await eachAsync_(assocs, async (data, anchor) => {\n            const assocMeta = meta[anchor];\n\n            if (\n                beforeEntityUpdate &&\n                assocMeta.type !== 'refersTo' &&\n                assocMeta.type !== 'belongsTo'\n            ) {\n                pendingAssocs[anchor] = data;\n                return;\n            }\n\n            const assocModel = this.db.model(assocMeta.entity);\n\n            if (assocMeta.list) {\n                data = _.castArray(data);\n\n                if (!assocMeta.field) {\n                    throw new ApplicationError(\n                        `Missing \"field\" property in the metadata of association \"${anchor}\" of entity \"${this.meta.name}\".`\n                    );\n                }\n\n                const assocKeys = mapFilter(\n                    data,\n                    (record) => record[assocMeta.key] != null,\n                    (record) => record[assocMeta.key]\n                );\n                const assocRecordsToRemove = {\n                    [assocMeta.field]: currentKeyValue,\n                };\n                if (assocKeys.length > 0) {\n                    assocRecordsToRemove[assocMeta.key] = { $notIn: assocKeys };\n                }\n\n                await assocModel.deleteMany_(\n                    assocRecordsToRemove,\n                    context.connOptions\n                );\n\n                return eachAsync_(data, (item) =>\n                    item[assocMeta.key] != null\n                        ? assocModel.updateOne_(\n                              {\n                                  ..._.omit(item, [assocMeta.key]),\n                                  [assocMeta.field]: currentKeyValue,\n                              },\n                              {\n                                  $query: {\n                                      [assocMeta.key]: item[assocMeta.key],\n                                  },\n                                  ...passOnOptions,\n                              },\n                              context.connOptions\n                          )\n                        : assocModel.create_(\n                              { ...item, [assocMeta.field]: currentKeyValue },\n                              passOnOptions,\n                              context.connOptions\n                          )\n                );\n            } else if (!_.isPlainObject(data)) {\n                if (Array.isArray(data)) {\n                    throw new ApplicationError(\n                        `Invalid type of associated entity (${assocMeta.entity}) data triggered from \"${this.meta.name}\" entity. Singular value expected (${anchor}), but an array is given instead.`\n                    );\n                }\n\n                if (!assocMeta.assoc) {\n                    throw new ApplicationError(\n                        `The associated field of relation \"${anchor}\" does not exist in the entity meta data.`\n                    );\n                }\n\n                // connected by\n                data = { [assocMeta.assoc]: data };\n            }\n\n            if (beforeEntityUpdate) {\n                if (_.isEmpty(data)) return;\n\n                // refersTo or belongsTo\n                let destEntityId = getValueFrom(\n                    [context.existing, context.options.$query, context.raw],\n                    anchor\n                );\n\n                if (destEntityId == null) {\n                    if (_.isEmpty(context.existing)) {\n                        context.existing = await this.findOne_(\n                            context.options.$query,\n                            context.connOptions\n                        );\n                        if (!context.existing) {\n                            throw new ValidationError(\n                                `Specified \"${this.meta.name}\" not found.`,\n                                {\n                                    query: context.options.$query,\n                                }\n                            );\n                        }\n                        destEntityId = context.existing[anchor];\n                    }\n\n                    if (destEntityId == null) {\n                        if (!(anchor in context.existing)) {\n                            throw new ApplicationError(\n                                'Existing entity record does not contain the referenced entity id.',\n                                {\n                                    anchor,\n                                    data,\n                                    existing: context.existing,\n                                    query: context.options.$query,\n                                    raw: context.raw,\n                                }\n                            );\n                        }\n\n                        // to create the associated, existing is null\n\n                        passOnOptions.$retrieveDbResult = true;\n                        let created = await assocModel.create_(\n                            data,\n                            passOnOptions,\n                            context.connOptions\n                        );\n\n                        if (passOnOptions.$result.affectedRows === 0) {\n                            // insert ignored\n\n                            const assocQuery =\n                                assocModel.getUniqueKeyValuePairsFrom(data);\n                            created = await assocModel.findOne_(\n                                { $query: assocQuery },\n                                context.connOptions\n                            );\n                            if (!created) {\n                                throw new ApplicationError(\n                                    'The assoicated entity is duplicated on unique keys different from the pair of keys used to query',\n                                    {\n                                        query: assocQuery,\n                                        data,\n                                    }\n                                );\n                            }\n                        }\n\n                        context.raw[anchor] = created[assocMeta.field];\n                        return;\n                    }\n                }\n\n                if (destEntityId) {\n                    return assocModel.updateOne_(\n                        data,\n                        { [assocMeta.field]: destEntityId, ...passOnOptions },\n                        context.connOptions\n                    );\n                }\n\n                // nothing to do for null dest entity id\n                return;\n            }\n\n            await assocModel.deleteMany_(\n                { [assocMeta.field]: currentKeyValue },\n                context.connOptions\n            );\n\n            if (forSingleRecord) {\n                return assocModel.create_(\n                    { ...data, [assocMeta.field]: currentKeyValue },\n                    passOnOptions,\n                    context.connOptions\n                );\n            }\n\n            throw new Error(\n                'update associated data for multiple records not implemented'\n            );\n\n            // return assocModel.replaceOne_({ ...data, ...(assocMeta.field ? { [assocMeta.field]: keyValue } : {}) }, null, context.connOptions);\n        });\n\n        return pendingAssocs;\n    }\n}\n\nconst sugar = require('./mixin/sugar');\nfor (const key of Object.keys(sugar)) {\n    MySQLEntityModel[key] = sugar[key];\n}\n\nmodule.exports = MySQLEntityModel;\n"],"names":["_","eachAsync_","require","EntityModel","ApplicationError","ReferencedNotExistError","DuplicateError","ValidationError","InvalidArgument","Types","getValueFrom","mapFilter","defaultNestedKeyGetter","anchor","MySQLEntityModel","hasAutoIncrement","autoId","meta","features","fields","field","autoIncrementId","getNestedObject","entityObj","keyPath","get","split","map","p","join","_translateSymbolToken","name","db","connector","raw","Error","_serializeByTypeInfo","value","info","type","DATETIME","serialize","Array","isArray","csv","ARRAY","toCsv","OBJECT","create_","args","error","errorCode","code","message","updateOne_","_doReplaceOne_","context","ensureTransaction_","entity","findOne_","$query","options","connOptions","ret","$retrieveExisting","rawOptions","$existing","keyField","valueOfKey","omit","$retrieveCreated","$retrieveUpdated","$result","_internalBeforeCreate_","_fillResult","result","affectedRows","insertId","latest","upsert","return","_internalAfterCreate_","$retrieveDbResult","queryKey","getUniqueKeyValuePairsFrom","isEmpty","retrieveOptions","isPlainObject","_internalBeforeUpdate_","_internalBeforeUpdateMany_","_internalAfterUpdate_","changedRows","retrieveUpdated","$retrieveActualUpdated","$retrieveNotUpdate","condition","$bypassEnsureUnique","$relationships","$includeDeleted","$retrieveDeleted","_internalAfterUpdateMany_","findAll_","_internalBeforeDelete_","$physicalDeletion","existing","_internalBeforeDeleteMany_","_internalAfterDelete_","_internalAfterDeleteMany_","_prepareAssociations","findOptions","normalAssocs","customAssocs","partition","$association","assoc","associations","uniq","sort","concat","assocTable","counter","cache","forEach","_translateSchemaNameToDb","alias","joinType","output","key","on","dataset","buildQuery","model","_prepareQueries","$variables","_loadAssocIntoTable","lastPos","lastIndexOf","assocInfo","base","substr","last","baseNode","subAssocs","currentDb","indexOf","schemaName","entityName","app","refDb","database","_mapRecordsToObjects","rows","columns","aliasMap","hierarchy","nestedKeyGetter","mapValues","chain","mainIndex","self","col","table","pos","mergeRecord","existingRow","rowObject","nodePath","each","sql","list","currentPath","push","objKey","subObj","subIndexes","rowKeyValue","isNil","existingSubRow","subIndex","buildSubIndexes","indexes","subObject","arrayOfObjs","tableTemplate","reduce","bucket","row","tableCache","colIdx","forOwn","obj","set","rowKey","_extractAssociations","data","isNew","assocs","refs","v","k","assocMeta","assocAnchor","_populateReferences_","references","refQuery","ReferencedEntity","created","JSON","stringify","_createAssocs_","beforeEntityCreate","keyValue","query","pendingAssocs","finished","passOnOptions","pick","assocModel","castArray","item","assocQuery","refFieldValue","localField","_updateAssocs_","beforeEntityUpdate","forSingleRecord","currentKeyValue","assocKeys","record","assocRecordsToRemove","length","$notIn","deleteMany_","destEntityId","sugar","Object","keys","module","exports"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}