{"version":3,"sources":["../../../src/drivers/postgres/EntityModel.js"],"sourcesContent":["import { _, eachAsync_ } from '@kitmi/july';\nimport EntityModel from '../relational/EntityModel';\nimport {\n    ApplicationError,\n    ReferencedNotExistError,\n    DuplicateError,\n    ValidationError,\n    InvalidArgument,\n} from '@kitmi/types';\nimport { Types } from '@kitmi/validators/allSync';\n\nconst defaultNestedKeyGetter = (anchor) => ':' + anchor;\n\n/**\n * PostgresEntityModel entity model class.\n */\nclass PostgresEntityModel extends EntityModel {\n    /**\n     * [specific] Check if this entity has auto increment feature.\n     */\n    static get hasAutoIncrement() {\n        const autoId = this.meta.features.autoId;\n        return autoId && this.meta.fields[autoId.field].autoIncrementId;\n    }\n\n    /**\n     * [override]\n     * @param {*} entityObj\n     * @param {*} keyPath\n     */\n    static getNestedObject(entityObj, keyPath) {\n        return _.get(\n            entityObj,\n            keyPath\n                .split('.')\n                .map((p) => ':' + p)\n                .join('.')\n        );\n    }\n\n    /**\n     * [override] Serialize value into database acceptable format.\n     * @param {object} name - Name of the symbol token\n     */\n    _translateSymbolToken(name) {\n        if (name === 'NOW') {\n            return this.db.connector.raw('NOW()');\n        }\n\n        throw new Error('not support: ' + name);\n    }\n\n    /**\n     * [override]\n     * @param {*} value\n     * @param {*} info\n     */\n    static _serializeByTypeInfo(value, info) {\n        if (info.type === 'boolean') {\n            return value ? 1 : 0;\n        }\n\n        if (info.type === 'datetime') {\n            return Types.DATETIME.serialize(value);\n        }\n\n        if (info.type === 'array' && Array.isArray(value)) {\n            if (info.csv) {\n                return Types.ARRAY.toCsv(value);\n            } else {\n                return Types.ARRAY.serialize(value);\n            }\n        }\n\n        if (info.type === 'object') {\n            return Types.OBJECT.serialize(value);\n        }\n\n        return value;\n    }\n\n    static async create_(...args) {\n        try {\n            return await super.create_(...args);\n        } catch (error) {\n            const errorCode = error.code;\n\n            if (errorCode === 'ER_NO_REFERENCED_ROW_2') {\n                throw new ReferencedNotExistError(\n                    'The new entity is referencing to an unexisting entity. Detail: ' +\n                        error.message,\n                    error.info\n                );\n            } else if (errorCode === 'ER_DUP_ENTRY') {\n                throw new DuplicateError(\n                    error.message +\n                        ` while creating a new \"${this.meta.name}\".`,\n                    error.info\n                );\n            }\n\n            throw error;\n        }\n    }\n\n    static async updateOne_(...args) {\n        try {\n            return await super.updateOne_(...args);\n        } catch (error) {\n            const errorCode = error.code;\n\n            if (errorCode === 'ER_NO_REFERENCED_ROW_2') {\n                throw new ReferencedNotExistError(\n                    'The entity to be updated is referencing to an unexisting entity. Detail: ' +\n                        error.message,\n                    error.info\n                );\n            } else if (errorCode === 'ER_DUP_ENTRY') {\n                throw new DuplicateError(\n                    error.message +\n                        ` while updating an existing \"${this.meta.name}\".`,\n                    error.info\n                );\n            }\n\n            throw error;\n        }\n    }\n\n    static async _doReplaceOne_(context) {\n        await this.ensureTransaction_(context);\n\n        const entity = await this.findOne_(\n            { $query: context.options.$query },\n            context.connOptions\n        );\n\n        let ret, options;\n\n        if (entity) {\n            if (context.options.$retrieveExisting) {\n                context.rawOptions.$existing = entity;\n            }\n\n            options = {\n                ...context.options,\n                $query: { [this.meta.keyField]: super.valueOfKey(entity) },\n                $existing: entity,\n            };\n\n            ret = await this.updateOne_(\n                context.raw,\n                options,\n                context.connOptions\n            );\n        } else {\n            options = {\n                ..._.omit(context.options, [\n                    '$retrieveUpdated',\n                    '$skipUniqueCheck',\n                ]),\n                $retrieveCreated: context.options.$retrieveUpdated,\n            };\n\n            ret = await this.create_(context.raw, options, context.connOptions);\n        }\n\n        if (options.$existing) {\n            context.rawOptions.$existing = options.$existing;\n        }\n\n        if (options.$result) {\n            context.rawOptions.$result = options.$result;\n        }\n\n        return ret;\n    }\n\n    static _internalBeforeCreate_(context) {\n        return true;\n    }\n\n    static _fillResult(context) {\n        if (this.hasAutoIncrement && context.result.affectedRows > 0) {\n            const { insertId } = context.result;\n            if (insertId > 0) {\n                context.latest = {\n                    ...context.latest,\n                    [this.meta.features.autoId.field]: insertId,\n                };\n            } else if (context.result.upsert) {\n                // the key is not correct \n                delete context.latest[this.meta.features.autoId.field];\n            }\n        } else if (context.result.upsert) {\n            // the key is not used \n            delete context.latest[this.meta.keyField];\n        }\n\n        context.return = context.latest;\n    }\n\n    /**\n     * Post create processing.\n     * @param {*} context\n     * @property {object} [context.options] - Create options\n     * @property {bool} [options.$retrieveCreated] - Retrieve the newly created record from db.\n     */\n    static async _internalAfterCreate_(context) {\n        if (context.options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result;\n        }\n\n        if (context.options.$retrieveCreated) {\n            if (this.hasAutoIncrement) {\n                if (context.result.affectedRows === 0) {\n                    // insert ignored\n                    context.queryKey = this.getUniqueKeyValuePairsFrom(\n                        context.latest\n                    );\n\n                    if (_.isEmpty(context.queryKey)) {\n                        throw new ApplicationError(\n                            'Cannot extract unique keys from input data.',\n                            {\n                                entity: this.meta.name,\n                            }\n                        );\n                    }\n                } else {\n                    const { insertId } = context.result;\n                    context.queryKey = {\n                        [this.meta.features.autoId.field]: insertId,\n                    };\n                }\n            } else {\n                context.queryKey = this.getUniqueKeyValuePairsFrom(\n                    context.latest\n                );\n\n                if (_.isEmpty(context.queryKey)) {\n                    throw new ApplicationError(\n                        'Cannot extract unique keys from input data.',\n                        {\n                            entity: this.meta.name,\n                        }\n                    );\n                }\n            }\n\n            const retrieveOptions = _.isPlainObject(\n                context.options.$retrieveCreated\n            )\n                ? context.options.$retrieveCreated\n                : {};\n            context.return = await this.findOne_(\n                { ...retrieveOptions, $query: context.queryKey },\n                context.connOptions\n            );\n        } else {\n            if (this.hasAutoIncrement) {\n                if (context.result.affectedRows === 0) {\n                    context.queryKey = this.getUniqueKeyValuePairsFrom(\n                        context.latest\n                    );\n                } else {\n                    const { insertId } = context.result;\n                    context.queryKey = {\n                        [this.meta.features.autoId.field]: insertId,\n                    };\n                }\n            }\n        }\n    }\n\n    static _internalBeforeUpdate_(context) {\n        return true;\n    }\n\n    static _internalBeforeUpdateMany_(context) {\n        return true;\n    }\n\n    /**\n     * Post update processing.\n     * @param {*} context\n     * @property {object} [context.options] - Update options\n     * @property {bool} [context.options.$retrieveUpdated] - Retrieve the newly updated record from db.\n     */\n    static async _internalAfterUpdate_(context) {\n        const options = context.options;\n\n        if (options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result || {\n                affectedRows: 0,\n                changedRows: 0,\n            };\n        }\n\n        let retrieveUpdated = options.$retrieveUpdated;\n\n        if (!retrieveUpdated) {\n            if (\n                options.$retrieveActualUpdated &&\n                context.result.affectedRows > 0\n            ) {\n                retrieveUpdated = options.$retrieveActualUpdated;\n            } else if (\n                options.$retrieveNotUpdate &&\n                context.result.affectedRows === 0\n            ) {\n                retrieveUpdated = options.$retrieveNotUpdate;\n            }\n        }\n\n        if (retrieveUpdated) {\n            const condition = {\n                $query: this.getUniqueKeyValuePairsFrom(options.$query),\n            };\n            if (options.$skipUniqueCheck) {\n                condition.$skipUniqueCheck = options.$skipUniqueCheck;\n            }\n\n            let retrieveOptions = {};\n\n            if (_.isPlainObject(retrieveUpdated)) {\n                retrieveOptions = retrieveUpdated;\n            } else if (options.$relationships) {\n                retrieveOptions.$relationships = options.$relationships;\n            }\n\n            context.return = await this.findOne_(\n                {\n                    ...condition,\n                    $includeDeleted: options.$retrieveDeleted,\n                    ...retrieveOptions,\n                },\n                context.connOptions\n            );\n\n            if (context.return) {\n                context.queryKey = this.getUniqueKeyValuePairsFrom(\n                    context.return\n                );\n            } else {\n                context.queryKey = condition.$query;\n            }\n        }\n    }\n\n    /**\n     * Post update processing.\n     * @param {*} context\n     * @param {object} [options] - Update options\n     * @property {bool} [options.$retrieveUpdated] - Retrieve the newly updated record from db.\n     */\n    static async _internalAfterUpdateMany_(context) {\n        const options = context.options;\n\n        if (options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result || {\n                affectedRows: 0,\n                changedRows: 0,\n            };\n\n            /**\n             * afterUpdateMany ResultSetHeader {\n             * fieldCount: 0,\n             * affectedRows: 1,\n             * insertId: 0,\n             * info: 'Rows matched: 1  Changed: 1  Warnings: 0',\n             * serverStatus: 3,\n             * warningStatus: 0,\n             * changedRows: 1 }\n             */\n        }\n\n        if (options.$retrieveUpdated) {\n            let retrieveOptions = {};\n\n            if (_.isPlainObject(options.$retrieveUpdated)) {\n                retrieveOptions = options.$retrieveUpdated;\n            } else if (options.$relationships) {\n                retrieveOptions.$relationships = options.$relationships;\n            }\n\n            context.return = await this.findAll_(\n                {\n                    $query: options.$query,\n                    $includeDeleted: options.$retrieveDeleted,\n                    ...retrieveOptions,\n                },\n                context.connOptions\n            );\n        }\n\n        context.queryKey = options.$query;\n    }\n\n    /**\n     * Before deleting an entity.\n     * @param {*} context\n     * @property {object} [context.options] - Delete options\n     * @property {bool} [context.options.$retrieveDeleted] - Retrieve the recently deleted record from db.\n     */\n    static async _internalBeforeDelete_(context) {\n        if (context.options.$retrieveDeleted) {\n            await this.ensureTransaction_(context);\n\n            const retrieveOptions = _.isPlainObject(\n                context.options.$retrieveDeleted\n            )\n                ? {\n                      ...context.options.$retrieveDeleted,\n                      $query: context.options.$query,\n                  }\n                : { $query: context.options.$query };\n\n            if (context.options.$physicalDeletion) {\n                retrieveOptions.$includeDeleted = true;\n            }\n\n            context.return = context.existing = await this.findOne_(\n                retrieveOptions,\n                context.connOptions\n            );\n        }\n\n        return true;\n    }\n\n    static async _internalBeforeDeleteMany_(context) {\n        if (context.options.$retrieveDeleted) {\n            await this.ensureTransaction_(context);\n\n            const retrieveOptions = _.isPlainObject(\n                context.options.$retrieveDeleted\n            )\n                ? {\n                      ...context.options.$retrieveDeleted,\n                      $query: context.options.$query,\n                  }\n                : { $query: context.options.$query };\n\n            if (context.options.$physicalDeletion) {\n                retrieveOptions.$includeDeleted = true;\n            }\n\n            context.return = context.existing = await this.findAll_(\n                retrieveOptions,\n                context.connOptions\n            );\n        }\n\n        return true;\n    }\n\n    /**\n     * Post delete processing.\n     * @param {*} context\n     */\n    static _internalAfterDelete_(context) {\n        if (context.options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result;\n        }\n    }\n\n    /**\n     * Post delete processing.\n     * @param {*} context\n     */\n    static _internalAfterDeleteMany_(context) {\n        if (context.options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result;\n        }\n    }\n\n    /**\n     *\n     * @param {*} findOptions\n     */\n    static _prepareAssociations(findOptions) {\n        const [normalAssocs, customAssocs] = _.partition(\n            findOptions.$association,\n            (assoc) => typeof assoc === 'string'\n        );\n\n        const associations = _.uniq(normalAssocs).sort().concat(customAssocs);\n        const assocTable = {};\n            let counter = 0;\n            const cache = {};\n\n        associations.forEach((assoc) => {\n            if (_.isPlainObject(assoc)) {\n                assoc = this._translateSchemaNameToDb(assoc);\n\n                let alias = assoc.alias;\n                if (!assoc.alias) {\n                    alias = ':join' + ++counter;\n                }\n\n                assocTable[alias] = {\n                    entity: assoc.entity,\n                    joinType: assoc.type,\n                    output: assoc.output,\n                    key: assoc.key,\n                    alias,\n                    on: assoc.on,\n                    ...(assoc.dataset\n                        ? this.db.connector.buildQuery(\n                              assoc.entity,\n                              assoc.model._prepareQueries({\n                                  ...assoc.dataset,\n                                  $variables: findOptions.$variables,\n                              })\n                          )\n                        : {}),\n                };\n            } else {\n                this._loadAssocIntoTable(assocTable, cache, assoc);\n            }\n        });\n\n        return assocTable;\n    }\n\n    /**\n     *\n     * @param {*} assocTable - Hierarchy with subAssocs\n     * @param {*} cache - Dotted path as key\n     * @param {*} assoc - Dotted path\n     */\n    static _loadAssocIntoTable(assocTable, cache, assoc) {\n        if (cache[assoc]) return cache[assoc];\n\n        const lastPos = assoc.lastIndexOf('.');\n        let result;\n\n        if (lastPos === -1) {\n            // direct association\n            const assocInfo = { ...this.meta.associations[assoc] };\n            if (_.isEmpty(assocInfo)) {\n                throw new InvalidArgument(\n                    `Entity \"${this.meta.name}\" does not have the association \"${assoc}\".`\n                );\n            }\n\n            result =\n                cache[assoc] =\n                assocTable[assoc] =\n                    { ...this._translateSchemaNameToDb(assocInfo) };\n        } else {\n            const base = assoc.substr(0, lastPos);\n            const last = assoc.substr(lastPos + 1);\n\n            let baseNode = cache[base];\n            if (!baseNode) {\n                baseNode = this._loadAssocIntoTable(assocTable, cache, base);\n            }\n\n            const entity = baseNode.model || this.db.model(baseNode.entity);\n            const assocInfo = { ...entity.meta.associations[last] };\n            if (_.isEmpty(assocInfo)) {\n                throw new InvalidArgument(\n                    `Entity \"${entity.meta.name}\" does not have the association \"${assoc}\".`\n                );\n            }\n\n            result = { ...entity._translateSchemaNameToDb(assocInfo, this.db) };\n\n            if (!baseNode.subAssocs) {\n                baseNode.subAssocs = {};\n            }\n\n            cache[assoc] = baseNode.subAssocs[last] = result;\n        }\n\n        if (result.assoc) {\n            this._loadAssocIntoTable(\n                assocTable,\n                cache,\n                assoc + '.' + result.assoc\n            );\n        }\n\n        return result;\n    }\n\n    static _translateSchemaNameToDb(assoc, currentDb) {\n        if (!assoc.entity) {\n            throw new ApplicationError('\"entity\" is required in the association object.');\n        }\n\n        if (assoc.entity.indexOf('.') > 0) {\n            const [schemaName, entityName] = assoc.entity.split('.', 2);\n\n            const app = this.db.app;\n\n            const refDb = app.db(schemaName);\n            if (!refDb) {\n                throw new ApplicationError(\n                    `The referenced schema \"${schemaName}\" does not have db model in the same application.`\n                );\n            }\n\n            assoc.entity = refDb.connector.database + '.' + entityName;\n            assoc.model = refDb.model(entityName);\n\n            if (!assoc.model) {\n                throw new ApplicationError(\n                    `Failed load the entity model \"${schemaName}.${entityName}\".`\n                );\n            }\n        } else {\n            assoc.model = this.db.model(assoc.entity);\n\n            if (currentDb && currentDb !== this.db) {\n                assoc.entity = this.db.connector.database + '.' + assoc.entity;\n            }\n        }\n\n        if (!assoc.key) {\n            assoc.key = assoc.model.meta.keyField;\n        }\n\n        return assoc;\n    }\n\n    static _mapRecordsToObjects(\n        [rows, columns, aliasMap],\n        hierarchy,\n        nestedKeyGetter\n    ) {\n        nestedKeyGetter == null && (nestedKeyGetter = defaultNestedKeyGetter);\n        aliasMap = _.mapValues(aliasMap, (chain) =>\n            chain.map((anchor) => nestedKeyGetter(anchor))\n        );\n\n        const mainIndex = {};\n        const self = this;\n\n        // map mysql column result into array of { table <table alias>, name: <column name> }\n        columns = columns.map((col) => {\n            if (col.table === '') {\n                const pos = col.name.indexOf('$');\n                if (pos > 0) {\n                    return {\n                        table: col.name.substr(0, pos),\n                        name: col.name.substr(pos + 1),\n                    };\n                }\n\n                return {\n                    table: 'A',\n                    name: col.name,\n                };\n            }\n\n            return {\n                table: col.table,\n                name: col.name,\n            };\n        });\n\n        // map flat record into hierachy\n        function mergeRecord(existingRow, rowObject, associations, nodePath) {\n            return _.each(\n                associations,\n                ({ sql, key, list, subAssocs }, anchor) => {\n                    if (sql) return;\n\n                    const currentPath = nodePath.concat();\n                    currentPath.push(anchor);\n\n                    const objKey = nestedKeyGetter(anchor);\n                    const subObj = rowObject[objKey];\n\n                    if (!subObj) {\n                        // associated entity not in result set, probably when custom projection is used\n                        return;\n                    }\n\n                    const subIndexes = existingRow.subIndexes[objKey];\n\n                    // joined an empty record\n                    const rowKeyValue = subObj[key];\n                    if (_.isNil(rowKeyValue)) {\n                        if (list && rowKeyValue == null) {\n                            if (existingRow.rowObject[objKey]) {\n                                existingRow.rowObject[objKey].push(subObj);\n                            } else {\n                                existingRow.rowObject[objKey] = [subObj];\n                            }\n                        }\n\n                        return;\n                    }\n\n                    const existingSubRow = subIndexes && subIndexes[rowKeyValue];\n                    if (existingSubRow) {\n                        if (subAssocs) {\n                            return mergeRecord(\n                                existingSubRow,\n                                subObj,\n                                subAssocs,\n                                currentPath\n                            );\n                        }\n                    } else {\n                        if (!list) {\n                            throw new ApplicationError(\n                                `The structure of association \"${currentPath.join(\n                                    '.'\n                                )}\" with [key=${key}] of entity \"${\n                                    self.meta.name\n                                }\" should be a list.`,\n                                { existingRow, rowObject }\n                            );\n                        }\n\n                        if (existingRow.rowObject[objKey]) {\n                            existingRow.rowObject[objKey].push(subObj);\n                        } else {\n                            existingRow.rowObject[objKey] = [subObj];\n                        }\n\n                        const subIndex = {\n                            rowObject: subObj,\n                        };\n\n                        if (subAssocs) {\n                            subIndex.subIndexes = buildSubIndexes(\n                                subObj,\n                                subAssocs\n                            );\n                        }\n\n                        if (!subIndexes) {\n                            throw new ApplicationError(\n                                `The subIndexes of association \"${currentPath.join(\n                                    '.'\n                                )}\" with [key=${key}] of entity \"${\n                                    self.meta.name\n                                }\" does not exist.`,\n                                { existingRow, rowObject }\n                            );\n                        }\n\n                        subIndexes[rowKeyValue] = subIndex;\n                    }\n                }\n            );\n        }\n\n        // build sub index for list member\n        function buildSubIndexes(rowObject, associations) {\n            const indexes = {};\n\n            _.each(associations, ({ sql, key, list, subAssocs }, anchor) => {\n                if (sql) {\n                    return;\n                }\n\n                const objKey = nestedKeyGetter(anchor);\n                let subObject = rowObject[objKey];\n                const subIndex = {\n                    rowObject: subObject,\n                };\n\n                if (list) {\n                    if (!subObject) {\n                        // associated entity not in result set, probably when custom projection is used\n                        rowObject[objKey] = [];\n                        return;\n                    }\n\n                    rowObject[objKey] = [subObject];\n\n                    // many to *\n                    if (_.isNil(subObject[key])) {\n                        // when custom projection is used\n                        subObject = null;\n                    }\n                }\n\n                if (subObject) {\n                    if (subAssocs) {\n                        subIndex.subIndexes = buildSubIndexes(\n                            subObject,\n                            subAssocs\n                        );\n                    }\n\n                    indexes[objKey] = subObject[key]\n                        ? {\n                              [subObject[key]]: subIndex,\n                          }\n                        : {};\n                }\n            });\n\n            return indexes;\n        }\n\n        const arrayOfObjs = [];\n\n        // build the result object skeleton\n        const tableTemplate = columns.reduce((result, col) => {\n            if (col.table !== 'A') {\n                const bucket = result[col.table];\n                if (bucket) {\n                    bucket[col.name] = null;\n                } else {\n                    result[col.table] = { [col.name]: null };\n                }\n            }\n\n            return result;\n        }, {});\n\n        // process each row\n        rows.forEach((row) => {\n            const tableCache = {}; // from alias to child prop of rowObject\n\n            // hash-style data row\n            const rowObject = row.reduce((result, value, colIdx) => {\n                const col = columns[colIdx];\n\n                if (col.table === 'A') {\n                    result[col.name] = value;\n                } else if (value != null) {\n                    // avoid a object with all null value exists\n                    const bucket = tableCache[col.table];\n                    if (bucket) {\n                        // already nested inside\n                        bucket[col.name] = value;\n                    } else {\n                        tableCache[col.table] = {\n                            ...tableTemplate[col.table],\n                            [col.name]: value,\n                        };\n                    }\n                }\n\n                return result;\n            }, {});\n\n            _.forOwn(tableCache, (obj, table) => {\n                const nodePath = aliasMap[table];\n                _.set(rowObject, nodePath, obj);\n            });\n\n            const rowKey = rowObject[self.meta.keyField];\n            const existingRow = mainIndex[rowKey];\n            if (existingRow) {\n                return mergeRecord(existingRow, rowObject, hierarchy, []);\n            }\n\n            arrayOfObjs.push(rowObject);\n            mainIndex[rowKey] = {\n                rowObject,\n                subIndexes: buildSubIndexes(rowObject, hierarchy),\n            };\n        });\n\n        return arrayOfObjs;\n    }\n\n    /**\n     * Pre-process assoicated db operation\n     * @param {*} data\n     * @param {*} isNew - New record flag, true for creating, false for updating\n     * @returns {Array} [raw, assocs, refs];\n     */\n    static _extractAssociations(data, isNew) {\n        const raw = {};\n            const assocs = {};\n            const refs = {};\n        const meta = this.meta.associations;\n\n        _.forOwn(data, (v, k) => {\n            if (k[0] === ':') {\n                // cascade update\n                const anchor = k.substr(1);\n                const assocMeta = meta[anchor];\n                if (!assocMeta) {\n                    throw new ValidationError(\n                        `Unknown association \"${anchor}\" of entity \"${this.meta.name}\".`\n                    );\n                }\n\n                if (\n                    isNew &&\n                    (assocMeta.type === 'refersTo' ||\n                        assocMeta.type === 'belongsTo') &&\n                    anchor in data\n                ) {\n                    throw new ValidationError(\n                        `Association data \":${anchor}\" of entity \"${this.meta.name}\" conflicts with input value of field \"${anchor}\".`\n                    );\n                }\n\n                assocs[anchor] = v;\n            } else if (k[0] === '@') {\n                // update by reference\n                const anchor = k.substr(1);\n                const assocMeta = meta[anchor];\n                if (!assocMeta) {\n                    throw new ValidationError(\n                        `Unknown association \"${anchor}\" of entity \"${this.meta.name}\".`\n                    );\n                }\n\n                if (\n                    assocMeta.type !== 'refersTo' &&\n                    assocMeta.type !== 'belongsTo'\n                ) {\n                    throw new ValidationError(\n                        `Association type \"${assocMeta.type}\" cannot be used for update by reference.`,\n                        {\n                            entity: this.meta.name,\n                            data,\n                        }\n                    );\n                }\n\n                if (isNew && anchor in data) {\n                    throw new ValidationError(\n                        `Association reference \"@${anchor}\" of entity \"${this.meta.name}\" conflicts with input value of field \"${anchor}\".`\n                    );\n                }\n\n                const assocAnchor = ':' + anchor;\n                if (assocAnchor in data) {\n                    throw new ValidationError(\n                        `Association reference \"@${anchor}\" of entity \"${this.meta.name}\" conflicts with association data \"${assocAnchor}\".`\n                    );\n                }\n\n                if (v == null) {\n                    raw[anchor] = null;\n                } else {\n                    refs[anchor] = v;\n                }\n            } else {\n                raw[k] = v;\n            }\n        });\n\n        return [raw, assocs, refs];\n    }\n\n    static async _populateReferences_(context, references) {\n        const meta = this.meta.associations;\n\n        await eachAsync_(references, async (refQuery, anchor) => {\n            const assocMeta = meta[anchor];\n            const ReferencedEntity = this.db.model(assocMeta.entity);\n\n            const created = await ReferencedEntity.findOne_(\n                refQuery,\n                context.connOptions\n            );\n\n            if (!created) {\n                throw new ReferencedNotExistError(\n                    `Referenced entity \"${\n                        ReferencedEntity.meta.name\n                    }\" with ${JSON.stringify(refQuery)} not exist.`\n                );\n            }\n\n            context.raw[anchor] = created[assocMeta.field];\n        });\n    }\n\n    static async _createAssocs_(context, assocs, beforeEntityCreate) {\n        const meta = this.meta.associations;\n        let keyValue;\n\n        if (!beforeEntityCreate) {\n            keyValue = context.return[this.meta.keyField];\n\n            if (_.isNil(keyValue)) {\n                if (context.result.affectedRows === 0) {\n                    // insert ignored\n\n                    const query = this.getUniqueKeyValuePairsFrom(\n                        context.return\n                    );\n                    context.return = await this.findOne_(\n                        { $query: query },\n                        context.connOptions\n                    );\n                    if (!context.return) {\n                        throw new ApplicationError(\n                            'The parent entity is duplicated on unique keys different from the pair of keys used to query',\n                            {\n                                query,\n                                data: context.return,\n                                associations: assocs,\n                            }\n                        );\n                    }\n                }\n\n                keyValue = context.return[this.meta.keyField];\n\n                if (_.isNil(keyValue)) {\n                    throw new ApplicationError(\n                        'Missing required primary key field value. Entity: ' +\n                            this.meta.name,\n                        {\n                            data: context.return,\n                            associations: assocs,\n                        }\n                    );\n                }\n            }\n        }\n\n        const pendingAssocs = {};\n        const finished = {};\n\n        // todo: double check to ensure including all required options\n        const passOnOptions = _.pick(context.options, [\n            '$skipModifiers',\n            '$migration',\n            '$variables',\n            '$upsert',\n            '$dryRun'\n        ]);\n\n        await eachAsync_(assocs, async (data, anchor) => {\n            const assocMeta = meta[anchor];\n\n            if (\n                beforeEntityCreate &&\n                assocMeta.type !== 'refersTo' &&\n                assocMeta.type !== 'belongsTo'\n            ) {\n                pendingAssocs[anchor] = data;\n                return;\n            }\n\n            const assocModel = this.db.model(assocMeta.entity);\n\n            if (assocMeta.list) {\n                data = _.castArray(data);\n\n                if (!assocMeta.field) {\n                    throw new ApplicationError(\n                        `Missing \"field\" property in the metadata of association \"${anchor}\" of entity \"${this.meta.name}\".`\n                    );\n                }\n\n                return eachAsync_(data, (item) =>\n                    assocModel.create_(\n                        { ...item, [assocMeta.field]: keyValue },\n                        passOnOptions,\n                        context.connOptions\n                    )\n                );\n            } else if (!_.isPlainObject(data)) {\n                if (Array.isArray(data)) {\n                    throw new ApplicationError(\n                        `Invalid type of associated entity (${assocMeta.entity}) data triggered from \"${this.meta.name}\" entity. Singular value expected (${anchor}), but an array is given instead.`\n                    );\n                }\n\n                if (!assocMeta.assoc) {\n                    throw new ApplicationError(\n                        `The associated field of relation \"${anchor}\" does not exist in the entity meta data.`\n                    );\n                }\n\n                data = { [assocMeta.assoc]: data };\n            }\n\n            if (!beforeEntityCreate && assocMeta.field) {\n                // hasMany or hasOne\n                data = { ...data, [assocMeta.field]: keyValue };\n            }\n\n            passOnOptions.$retrieveDbResult = true;\n            let created = await assocModel.create_(\n                data,\n                passOnOptions,\n                context.connOptions\n            );\n\n            if (\n                passOnOptions.$result.affectedRows === 0 ||\n                (assocModel.hasAutoIncrement &&\n                    passOnOptions.$result.insertId === 0)\n            ) {\n                // insert ignored or upserted\n\n                const assocQuery = assocModel.getUniqueKeyValuePairsFrom(data);\n\n                created = await assocModel.findOne_(\n                    { $query: assocQuery },\n                    context.connOptions\n                );\n                if (!created) {\n                    throw new ApplicationError(\n                        'The assoicated entity is duplicated on unique keys different from the pair of keys used to query',\n                        {\n                            query: assocQuery,\n                            data,\n                        }\n                    );\n                }\n            }\n\n            finished[anchor] = beforeEntityCreate\n                ? created[assocMeta.field]\n                : created[assocMeta.key];\n        });\n\n        if (beforeEntityCreate) {\n            _.forOwn(finished, (refFieldValue, localField) => {\n                context.raw[localField] = refFieldValue;\n            });\n        }\n\n        return pendingAssocs;\n    }\n\n    static async _updateAssocs_(\n        context,\n        assocs,\n        beforeEntityUpdate,\n        forSingleRecord\n    ) {\n        const meta = this.meta.associations;\n\n        let currentKeyValue;\n\n        if (!beforeEntityUpdate) {\n            currentKeyValue = getValueFrom(\n                [context.options.$query, context.return],\n                this.meta.keyField\n            );\n            if (_.isNil(currentKeyValue)) {\n                // should have in updating\n                throw new ApplicationError(\n                    'Missing required primary key field value. Entity: ' +\n                        this.meta.name\n                );\n            }\n        }\n\n        const pendingAssocs = {};\n\n        // todo: double check to ensure including all required options\n        const passOnOptions = _.pick(context.options, [\n            '$skipModifiers',\n            '$migration',\n            '$variables',\n            '$upsert',\n        ]);\n\n        await eachAsync_(assocs, async (data, anchor) => {\n            const assocMeta = meta[anchor];\n\n            if (\n                beforeEntityUpdate &&\n                assocMeta.type !== 'refersTo' &&\n                assocMeta.type !== 'belongsTo'\n            ) {\n                pendingAssocs[anchor] = data;\n                return;\n            }\n\n            const assocModel = this.db.model(assocMeta.entity);\n\n            if (assocMeta.list) {\n                data = _.castArray(data);\n\n                if (!assocMeta.field) {\n                    throw new ApplicationError(\n                        `Missing \"field\" property in the metadata of association \"${anchor}\" of entity \"${this.meta.name}\".`\n                    );\n                }\n\n                const assocKeys = mapFilter(\n                    data,\n                    (record) => record[assocMeta.key] != null,\n                    (record) => record[assocMeta.key]\n                );\n                const assocRecordsToRemove = {\n                    [assocMeta.field]: currentKeyValue,\n                };\n                if (assocKeys.length > 0) {\n                    assocRecordsToRemove[assocMeta.key] = { $notIn: assocKeys };\n                }\n\n                await assocModel.deleteMany_(\n                    assocRecordsToRemove,\n                    context.connOptions\n                );\n\n                return eachAsync_(data, (item) =>\n                    item[assocMeta.key] != null\n                        ? assocModel.updateOne_(\n                              {\n                                  ..._.omit(item, [assocMeta.key]),\n                                  [assocMeta.field]: currentKeyValue,\n                              },\n                              {\n                                  $query: {\n                                      [assocMeta.key]: item[assocMeta.key],\n                                  },\n                                  ...passOnOptions,\n                              },\n                              context.connOptions\n                          )\n                        : assocModel.create_(\n                              { ...item, [assocMeta.field]: currentKeyValue },\n                              passOnOptions,\n                              context.connOptions\n                          )\n                );\n            } else if (!_.isPlainObject(data)) {\n                if (Array.isArray(data)) {\n                    throw new ApplicationError(\n                        `Invalid type of associated entity (${assocMeta.entity}) data triggered from \"${this.meta.name}\" entity. Singular value expected (${anchor}), but an array is given instead.`\n                    );\n                }\n\n                if (!assocMeta.assoc) {\n                    throw new ApplicationError(\n                        `The associated field of relation \"${anchor}\" does not exist in the entity meta data.`\n                    );\n                }\n\n                // connected by\n                data = { [assocMeta.assoc]: data };\n            }\n\n            if (beforeEntityUpdate) {\n                if (_.isEmpty(data)) return;\n\n                // refersTo or belongsTo\n                let destEntityId = getValueFrom(\n                    [context.existing, context.options.$query, context.raw],\n                    anchor\n                );\n\n                if (destEntityId == null) {\n                    if (_.isEmpty(context.existing)) {\n                        context.existing = await this.findOne_(\n                            context.options.$query,\n                            context.connOptions\n                        );\n                        if (!context.existing) {\n                            throw new ValidationError(\n                                `Specified \"${this.meta.name}\" not found.`,\n                                {\n                                    query: context.options.$query,\n                                }\n                            );\n                        }\n                        destEntityId = context.existing[anchor];\n                    }\n\n                    if (destEntityId == null) {\n                        if (!(anchor in context.existing)) {\n                            throw new ApplicationError(\n                                'Existing entity record does not contain the referenced entity id.',\n                                {\n                                    anchor,\n                                    data,\n                                    existing: context.existing,\n                                    query: context.options.$query,\n                                    raw: context.raw,\n                                }\n                            );\n                        }\n\n                        // to create the associated, existing is null\n\n                        passOnOptions.$retrieveDbResult = true;\n                        let created = await assocModel.create_(\n                            data,\n                            passOnOptions,\n                            context.connOptions\n                        );\n\n                        if (passOnOptions.$result.affectedRows === 0) {\n                            // insert ignored\n\n                            const assocQuery =\n                                assocModel.getUniqueKeyValuePairsFrom(data);\n                            created = await assocModel.findOne_(\n                                { $query: assocQuery },\n                                context.connOptions\n                            );\n                            if (!created) {\n                                throw new ApplicationError(\n                                    'The assoicated entity is duplicated on unique keys different from the pair of keys used to query',\n                                    {\n                                        query: assocQuery,\n                                        data,\n                                    }\n                                );\n                            }\n                        }\n\n                        context.raw[anchor] = created[assocMeta.field];\n                        return;\n                    }\n                }\n\n                if (destEntityId) {\n                    return assocModel.updateOne_(\n                        data,\n                        { [assocMeta.field]: destEntityId, ...passOnOptions },\n                        context.connOptions\n                    );\n                }\n\n                // nothing to do for null dest entity id\n                return;\n            }\n\n            await assocModel.deleteMany_(\n                { [assocMeta.field]: currentKeyValue },\n                context.connOptions\n            );\n\n            if (forSingleRecord) {\n                return assocModel.create_(\n                    { ...data, [assocMeta.field]: currentKeyValue },\n                    passOnOptions,\n                    context.connOptions\n                );\n            }\n\n            throw new Error(\n                'update associated data for multiple records not implemented'\n            );\n\n            // return assocModel.replaceOne_({ ...data, ...(assocMeta.field ? { [assocMeta.field]: keyValue } : {}) }, null, context.connOptions);\n        });\n\n        return pendingAssocs;\n    }\n}\n\nexport default PostgresEntityModel;\n"],"names":["defaultNestedKeyGetter","anchor","PostgresEntityModel","EntityModel","hasAutoIncrement","autoId","meta","features","fields","field","autoIncrementId","getNestedObject","entityObj","keyPath","_","get","split","map","p","join","_translateSymbolToken","name","db","connector","raw","Error","_serializeByTypeInfo","value","info","type","Types","DATETIME","serialize","Array","isArray","csv","ARRAY","toCsv","OBJECT","create_","args","error","errorCode","code","ReferencedNotExistError","message","DuplicateError","updateOne_","_doReplaceOne_","context","ensureTransaction_","entity","findOne_","$query","options","connOptions","ret","$retrieveExisting","rawOptions","$existing","keyField","valueOfKey","omit","$retrieveCreated","$retrieveUpdated","$result","_internalBeforeCreate_","_fillResult","result","affectedRows","insertId","latest","upsert","return","_internalAfterCreate_","$retrieveDbResult","queryKey","getUniqueKeyValuePairsFrom","isEmpty","ApplicationError","retrieveOptions","isPlainObject","_internalBeforeUpdate_","_internalBeforeUpdateMany_","_internalAfterUpdate_","changedRows","retrieveUpdated","$retrieveActualUpdated","$retrieveNotUpdate","condition","$skipUniqueCheck","$relationships","$includeDeleted","$retrieveDeleted","_internalAfterUpdateMany_","findAll_","_internalBeforeDelete_","$physicalDeletion","existing","_internalBeforeDeleteMany_","_internalAfterDelete_","_internalAfterDeleteMany_","_prepareAssociations","findOptions","normalAssocs","customAssocs","partition","$association","assoc","associations","uniq","sort","concat","assocTable","counter","cache","forEach","_translateSchemaNameToDb","alias","joinType","output","key","on","dataset","buildQuery","model","_prepareQueries","$variables","_loadAssocIntoTable","lastPos","lastIndexOf","assocInfo","InvalidArgument","base","substr","last","baseNode","subAssocs","currentDb","indexOf","schemaName","entityName","app","refDb","database","_mapRecordsToObjects","rows","columns","aliasMap","hierarchy","nestedKeyGetter","mapValues","chain","mainIndex","self","col","table","pos","mergeRecord","existingRow","rowObject","nodePath","each","sql","list","currentPath","push","objKey","subObj","subIndexes","rowKeyValue","isNil","existingSubRow","subIndex","buildSubIndexes","indexes","subObject","arrayOfObjs","tableTemplate","reduce","bucket","row","tableCache","colIdx","forOwn","obj","set","rowKey","_extractAssociations","data","isNew","assocs","refs","v","k","assocMeta","ValidationError","assocAnchor","_populateReferences_","references","eachAsync_","refQuery","ReferencedEntity","created","JSON","stringify","_createAssocs_","beforeEntityCreate","keyValue","query","pendingAssocs","finished","passOnOptions","pick","assocModel","castArray","item","assocQuery","refFieldValue","localField","_updateAssocs_","beforeEntityUpdate","forSingleRecord","currentKeyValue","getValueFrom","assocKeys","mapFilter","record","assocRecordsToRemove","length","$notIn","deleteMany_","destEntityId"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";;;;+BAu0CA;;;eAAA;;;sBAv0C8B;oEACN;uBAOjB;yBACe;;;;;;AAEtB,MAAMA,yBAAyB,CAACC,SAAW,MAAMA;AAEjD;;CAEC,GACD,MAAMC,4BAA4BC,oBAAW;IACzC;;KAEC,GACD,WAAWC,mBAAmB;QAC1B,MAAMC,SAAS,IAAI,CAACC,IAAI,CAACC,QAAQ,CAACF,MAAM;QACxC,OAAOA,UAAU,IAAI,CAACC,IAAI,CAACE,MAAM,CAACH,OAAOI,KAAK,CAAC,CAACC,eAAe;IACnE;IAEA;;;;KAIC,GACD,OAAOC,gBAAgBC,SAAS,EAAEC,OAAO,EAAE;QACvC,OAAOC,OAAC,CAACC,GAAG,CACRH,WACAC,QACKG,KAAK,CAAC,KACNC,GAAG,CAAC,CAACC,IAAM,MAAMA,GACjBC,IAAI,CAAC;IAElB;IAEA;;;KAGC,GACDC,sBAAsBC,IAAI,EAAE;QACxB,IAAIA,SAAS,OAAO;YAChB,OAAO,IAAI,CAACC,EAAE,CAACC,SAAS,CAACC,GAAG,CAAC;QACjC;QAEA,MAAM,IAAIC,MAAM,kBAAkBJ;IACtC;IAEA;;;;KAIC,GACD,OAAOK,qBAAqBC,KAAK,EAAEC,IAAI,EAAE;QACrC,IAAIA,KAAKC,IAAI,KAAK,WAAW;YACzB,OAAOF,QAAQ,IAAI;QACvB;QAEA,IAAIC,KAAKC,IAAI,KAAK,YAAY;YAC1B,OAAOC,cAAK,CAACC,QAAQ,CAACC,SAAS,CAACL;QACpC;QAEA,IAAIC,KAAKC,IAAI,KAAK,WAAWI,MAAMC,OAAO,CAACP,QAAQ;YAC/C,IAAIC,KAAKO,GAAG,EAAE;gBACV,OAAOL,cAAK,CAACM,KAAK,CAACC,KAAK,CAACV;YAC7B,OAAO;gBACH,OAAOG,cAAK,CAACM,KAAK,CAACJ,SAAS,CAACL;YACjC;QACJ;QAEA,IAAIC,KAAKC,IAAI,KAAK,UAAU;YACxB,OAAOC,cAAK,CAACQ,MAAM,CAACN,SAAS,CAACL;QAClC;QAEA,OAAOA;IACX;IAEA,aAAaY,QAAQ,GAAGC,IAAI,EAAE;QAC1B,IAAI;YACA,OAAO,MAAM,KAAK,CAACD,WAAWC;QAClC,EAAE,OAAOC,OAAO;YACZ,MAAMC,YAAYD,MAAME,IAAI;YAE5B,IAAID,cAAc,0BAA0B;gBACxC,MAAM,IAAIE,8BAAuB,CAC7B,oEACIH,MAAMI,OAAO,EACjBJ,MAAMb,IAAI;YAElB,OAAO,IAAIc,cAAc,gBAAgB;gBACrC,MAAM,IAAII,qBAAc,CACpBL,MAAMI,OAAO,GACT,CAAC,uBAAuB,EAAE,IAAI,CAACvC,IAAI,CAACe,IAAI,CAAC,EAAE,CAAC,EAChDoB,MAAMb,IAAI;YAElB;YAEA,MAAMa;QACV;IACJ;IAEA,aAAaM,WAAW,GAAGP,IAAI,EAAE;QAC7B,IAAI;YACA,OAAO,MAAM,KAAK,CAACO,cAAcP;QACrC,EAAE,OAAOC,OAAO;YACZ,MAAMC,YAAYD,MAAME,IAAI;YAE5B,IAAID,cAAc,0BAA0B;gBACxC,MAAM,IAAIE,8BAAuB,CAC7B,8EACIH,MAAMI,OAAO,EACjBJ,MAAMb,IAAI;YAElB,OAAO,IAAIc,cAAc,gBAAgB;gBACrC,MAAM,IAAII,qBAAc,CACpBL,MAAMI,OAAO,GACT,CAAC,6BAA6B,EAAE,IAAI,CAACvC,IAAI,CAACe,IAAI,CAAC,EAAE,CAAC,EACtDoB,MAAMb,IAAI;YAElB;YAEA,MAAMa;QACV;IACJ;IAEA,aAAaO,eAAeC,OAAO,EAAE;QACjC,MAAM,IAAI,CAACC,kBAAkB,CAACD;QAE9B,MAAME,SAAS,MAAM,IAAI,CAACC,QAAQ,CAC9B;YAAEC,QAAQJ,QAAQK,OAAO,CAACD,MAAM;QAAC,GACjCJ,QAAQM,WAAW;QAGvB,IAAIC,KAAKF;QAET,IAAIH,QAAQ;YACR,IAAIF,QAAQK,OAAO,CAACG,iBAAiB,EAAE;gBACnCR,QAAQS,UAAU,CAACC,SAAS,GAAGR;YACnC;YAEAG,UAAU;gBACN,GAAGL,QAAQK,OAAO;gBAClBD,QAAQ;oBAAE,CAAC,IAAI,CAAC/C,IAAI,CAACsD,QAAQ,CAAC,EAAE,KAAK,CAACC,WAAWV;gBAAQ;gBACzDQ,WAAWR;YACf;YAEAK,MAAM,MAAM,IAAI,CAACT,UAAU,CACvBE,QAAQzB,GAAG,EACX8B,SACAL,QAAQM,WAAW;QAE3B,OAAO;YACHD,UAAU;gBACN,GAAGxC,OAAC,CAACgD,IAAI,CAACb,QAAQK,OAAO,EAAE;oBACvB;oBACA;iBACH,CAAC;gBACFS,kBAAkBd,QAAQK,OAAO,CAACU,gBAAgB;YACtD;YAEAR,MAAM,MAAM,IAAI,CAACjB,OAAO,CAACU,QAAQzB,GAAG,EAAE8B,SAASL,QAAQM,WAAW;QACtE;QAEA,IAAID,QAAQK,SAAS,EAAE;YACnBV,QAAQS,UAAU,CAACC,SAAS,GAAGL,QAAQK,SAAS;QACpD;QAEA,IAAIL,QAAQW,OAAO,EAAE;YACjBhB,QAAQS,UAAU,CAACO,OAAO,GAAGX,QAAQW,OAAO;QAChD;QAEA,OAAOT;IACX;IAEA,OAAOU,uBAAuBjB,OAAO,EAAE;QACnC,OAAO;IACX;IAEA,OAAOkB,YAAYlB,OAAO,EAAE;QACxB,IAAI,IAAI,CAAC7C,gBAAgB,IAAI6C,QAAQmB,MAAM,CAACC,YAAY,GAAG,GAAG;YAC1D,MAAM,EAAEC,QAAQ,EAAE,GAAGrB,QAAQmB,MAAM;YACnC,IAAIE,WAAW,GAAG;gBACdrB,QAAQsB,MAAM,GAAG;oBACb,GAAGtB,QAAQsB,MAAM;oBACjB,CAAC,IAAI,CAACjE,IAAI,CAACC,QAAQ,CAACF,MAAM,CAACI,KAAK,CAAC,EAAE6D;gBACvC;YACJ,OAAO,IAAIrB,QAAQmB,MAAM,CAACI,MAAM,EAAE;gBAC9B,0BAA0B;gBAC1B,OAAOvB,QAAQsB,MAAM,CAAC,IAAI,CAACjE,IAAI,CAACC,QAAQ,CAACF,MAAM,CAACI,KAAK,CAAC;YAC1D;QACJ,OAAO,IAAIwC,QAAQmB,MAAM,CAACI,MAAM,EAAE;YAC9B,uBAAuB;YACvB,OAAOvB,QAAQsB,MAAM,CAAC,IAAI,CAACjE,IAAI,CAACsD,QAAQ,CAAC;QAC7C;QAEAX,QAAQwB,MAAM,GAAGxB,QAAQsB,MAAM;IACnC;IAEA;;;;;KAKC,GACD,aAAaG,sBAAsBzB,OAAO,EAAE;QACxC,IAAIA,QAAQK,OAAO,CAACqB,iBAAiB,EAAE;YACnC1B,QAAQS,UAAU,CAACO,OAAO,GAAGhB,QAAQmB,MAAM;QAC/C;QAEA,IAAInB,QAAQK,OAAO,CAACS,gBAAgB,EAAE;YAClC,IAAI,IAAI,CAAC3D,gBAAgB,EAAE;gBACvB,IAAI6C,QAAQmB,MAAM,CAACC,YAAY,KAAK,GAAG;oBACnC,iBAAiB;oBACjBpB,QAAQ2B,QAAQ,GAAG,IAAI,CAACC,0BAA0B,CAC9C5B,QAAQsB,MAAM;oBAGlB,IAAIzD,OAAC,CAACgE,OAAO,CAAC7B,QAAQ2B,QAAQ,GAAG;wBAC7B,MAAM,IAAIG,uBAAgB,CACtB,+CACA;4BACI5B,QAAQ,IAAI,CAAC7C,IAAI,CAACe,IAAI;wBAC1B;oBAER;gBACJ,OAAO;oBACH,MAAM,EAAEiD,QAAQ,EAAE,GAAGrB,QAAQmB,MAAM;oBACnCnB,QAAQ2B,QAAQ,GAAG;wBACf,CAAC,IAAI,CAACtE,IAAI,CAACC,QAAQ,CAACF,MAAM,CAACI,KAAK,CAAC,EAAE6D;oBACvC;gBACJ;YACJ,OAAO;gBACHrB,QAAQ2B,QAAQ,GAAG,IAAI,CAACC,0BAA0B,CAC9C5B,QAAQsB,MAAM;gBAGlB,IAAIzD,OAAC,CAACgE,OAAO,CAAC7B,QAAQ2B,QAAQ,GAAG;oBAC7B,MAAM,IAAIG,uBAAgB,CACtB,+CACA;wBACI5B,QAAQ,IAAI,CAAC7C,IAAI,CAACe,IAAI;oBAC1B;gBAER;YACJ;YAEA,MAAM2D,kBAAkBlE,OAAC,CAACmE,aAAa,CACnChC,QAAQK,OAAO,CAACS,gBAAgB,IAE9Bd,QAAQK,OAAO,CAACS,gBAAgB,GAChC,CAAC;YACPd,QAAQwB,MAAM,GAAG,MAAM,IAAI,CAACrB,QAAQ,CAChC;gBAAE,GAAG4B,eAAe;gBAAE3B,QAAQJ,QAAQ2B,QAAQ;YAAC,GAC/C3B,QAAQM,WAAW;QAE3B,OAAO;YACH,IAAI,IAAI,CAACnD,gBAAgB,EAAE;gBACvB,IAAI6C,QAAQmB,MAAM,CAACC,YAAY,KAAK,GAAG;oBACnCpB,QAAQ2B,QAAQ,GAAG,IAAI,CAACC,0BAA0B,CAC9C5B,QAAQsB,MAAM;gBAEtB,OAAO;oBACH,MAAM,EAAED,QAAQ,EAAE,GAAGrB,QAAQmB,MAAM;oBACnCnB,QAAQ2B,QAAQ,GAAG;wBACf,CAAC,IAAI,CAACtE,IAAI,CAACC,QAAQ,CAACF,MAAM,CAACI,KAAK,CAAC,EAAE6D;oBACvC;gBACJ;YACJ;QACJ;IACJ;IAEA,OAAOY,uBAAuBjC,OAAO,EAAE;QACnC,OAAO;IACX;IAEA,OAAOkC,2BAA2BlC,OAAO,EAAE;QACvC,OAAO;IACX;IAEA;;;;;KAKC,GACD,aAAamC,sBAAsBnC,OAAO,EAAE;QACxC,MAAMK,UAAUL,QAAQK,OAAO;QAE/B,IAAIA,QAAQqB,iBAAiB,EAAE;YAC3B1B,QAAQS,UAAU,CAACO,OAAO,GAAGhB,QAAQmB,MAAM,IAAI;gBAC3CC,cAAc;gBACdgB,aAAa;YACjB;QACJ;QAEA,IAAIC,kBAAkBhC,QAAQU,gBAAgB;QAE9C,IAAI,CAACsB,iBAAiB;YAClB,IACIhC,QAAQiC,sBAAsB,IAC9BtC,QAAQmB,MAAM,CAACC,YAAY,GAAG,GAChC;gBACEiB,kBAAkBhC,QAAQiC,sBAAsB;YACpD,OAAO,IACHjC,QAAQkC,kBAAkB,IAC1BvC,QAAQmB,MAAM,CAACC,YAAY,KAAK,GAClC;gBACEiB,kBAAkBhC,QAAQkC,kBAAkB;YAChD;QACJ;QAEA,IAAIF,iBAAiB;YACjB,MAAMG,YAAY;gBACdpC,QAAQ,IAAI,CAACwB,0BAA0B,CAACvB,QAAQD,MAAM;YAC1D;YACA,IAAIC,QAAQoC,gBAAgB,EAAE;gBAC1BD,UAAUC,gBAAgB,GAAGpC,QAAQoC,gBAAgB;YACzD;YAEA,IAAIV,kBAAkB,CAAC;YAEvB,IAAIlE,OAAC,CAACmE,aAAa,CAACK,kBAAkB;gBAClCN,kBAAkBM;YACtB,OAAO,IAAIhC,QAAQqC,cAAc,EAAE;gBAC/BX,gBAAgBW,cAAc,GAAGrC,QAAQqC,cAAc;YAC3D;YAEA1C,QAAQwB,MAAM,GAAG,MAAM,IAAI,CAACrB,QAAQ,CAChC;gBACI,GAAGqC,SAAS;gBACZG,iBAAiBtC,QAAQuC,gBAAgB;gBACzC,GAAGb,eAAe;YACtB,GACA/B,QAAQM,WAAW;YAGvB,IAAIN,QAAQwB,MAAM,EAAE;gBAChBxB,QAAQ2B,QAAQ,GAAG,IAAI,CAACC,0BAA0B,CAC9C5B,QAAQwB,MAAM;YAEtB,OAAO;gBACHxB,QAAQ2B,QAAQ,GAAGa,UAAUpC,MAAM;YACvC;QACJ;IACJ;IAEA;;;;;KAKC,GACD,aAAayC,0BAA0B7C,OAAO,EAAE;QAC5C,MAAMK,UAAUL,QAAQK,OAAO;QAE/B,IAAIA,QAAQqB,iBAAiB,EAAE;YAC3B1B,QAAQS,UAAU,CAACO,OAAO,GAAGhB,QAAQmB,MAAM,IAAI;gBAC3CC,cAAc;gBACdgB,aAAa;YACjB;QAEA;;;;;;;;;aASC,GACL;QAEA,IAAI/B,QAAQU,gBAAgB,EAAE;YAC1B,IAAIgB,kBAAkB,CAAC;YAEvB,IAAIlE,OAAC,CAACmE,aAAa,CAAC3B,QAAQU,gBAAgB,GAAG;gBAC3CgB,kBAAkB1B,QAAQU,gBAAgB;YAC9C,OAAO,IAAIV,QAAQqC,cAAc,EAAE;gBAC/BX,gBAAgBW,cAAc,GAAGrC,QAAQqC,cAAc;YAC3D;YAEA1C,QAAQwB,MAAM,GAAG,MAAM,IAAI,CAACsB,QAAQ,CAChC;gBACI1C,QAAQC,QAAQD,MAAM;gBACtBuC,iBAAiBtC,QAAQuC,gBAAgB;gBACzC,GAAGb,eAAe;YACtB,GACA/B,QAAQM,WAAW;QAE3B;QAEAN,QAAQ2B,QAAQ,GAAGtB,QAAQD,MAAM;IACrC;IAEA;;;;;KAKC,GACD,aAAa2C,uBAAuB/C,OAAO,EAAE;QACzC,IAAIA,QAAQK,OAAO,CAACuC,gBAAgB,EAAE;YAClC,MAAM,IAAI,CAAC3C,kBAAkB,CAACD;YAE9B,MAAM+B,kBAAkBlE,OAAC,CAACmE,aAAa,CACnChC,QAAQK,OAAO,CAACuC,gBAAgB,IAE9B;gBACI,GAAG5C,QAAQK,OAAO,CAACuC,gBAAgB;gBACnCxC,QAAQJ,QAAQK,OAAO,CAACD,MAAM;YAClC,IACA;gBAAEA,QAAQJ,QAAQK,OAAO,CAACD,MAAM;YAAC;YAEvC,IAAIJ,QAAQK,OAAO,CAAC2C,iBAAiB,EAAE;gBACnCjB,gBAAgBY,eAAe,GAAG;YACtC;YAEA3C,QAAQwB,MAAM,GAAGxB,QAAQiD,QAAQ,GAAG,MAAM,IAAI,CAAC9C,QAAQ,CACnD4B,iBACA/B,QAAQM,WAAW;QAE3B;QAEA,OAAO;IACX;IAEA,aAAa4C,2BAA2BlD,OAAO,EAAE;QAC7C,IAAIA,QAAQK,OAAO,CAACuC,gBAAgB,EAAE;YAClC,MAAM,IAAI,CAAC3C,kBAAkB,CAACD;YAE9B,MAAM+B,kBAAkBlE,OAAC,CAACmE,aAAa,CACnChC,QAAQK,OAAO,CAACuC,gBAAgB,IAE9B;gBACI,GAAG5C,QAAQK,OAAO,CAACuC,gBAAgB;gBACnCxC,QAAQJ,QAAQK,OAAO,CAACD,MAAM;YAClC,IACA;gBAAEA,QAAQJ,QAAQK,OAAO,CAACD,MAAM;YAAC;YAEvC,IAAIJ,QAAQK,OAAO,CAAC2C,iBAAiB,EAAE;gBACnCjB,gBAAgBY,eAAe,GAAG;YACtC;YAEA3C,QAAQwB,MAAM,GAAGxB,QAAQiD,QAAQ,GAAG,MAAM,IAAI,CAACH,QAAQ,CACnDf,iBACA/B,QAAQM,WAAW;QAE3B;QAEA,OAAO;IACX;IAEA;;;KAGC,GACD,OAAO6C,sBAAsBnD,OAAO,EAAE;QAClC,IAAIA,QAAQK,OAAO,CAACqB,iBAAiB,EAAE;YACnC1B,QAAQS,UAAU,CAACO,OAAO,GAAGhB,QAAQmB,MAAM;QAC/C;IACJ;IAEA;;;KAGC,GACD,OAAOiC,0BAA0BpD,OAAO,EAAE;QACtC,IAAIA,QAAQK,OAAO,CAACqB,iBAAiB,EAAE;YACnC1B,QAAQS,UAAU,CAACO,OAAO,GAAGhB,QAAQmB,MAAM;QAC/C;IACJ;IAEA;;;KAGC,GACD,OAAOkC,qBAAqBC,WAAW,EAAE;QACrC,MAAM,CAACC,cAAcC,aAAa,GAAG3F,OAAC,CAAC4F,SAAS,CAC5CH,YAAYI,YAAY,EACxB,CAACC,QAAU,OAAOA,UAAU;QAGhC,MAAMC,eAAe/F,OAAC,CAACgG,IAAI,CAACN,cAAcO,IAAI,GAAGC,MAAM,CAACP;QACxD,MAAMQ,aAAa,CAAC;QAChB,IAAIC,UAAU;QACd,MAAMC,QAAQ,CAAC;QAEnBN,aAAaO,OAAO,CAAC,CAACR;YAClB,IAAI9F,OAAC,CAACmE,aAAa,CAAC2B,QAAQ;gBACxBA,QAAQ,IAAI,CAACS,wBAAwB,CAACT;gBAEtC,IAAIU,QAAQV,MAAMU,KAAK;gBACvB,IAAI,CAACV,MAAMU,KAAK,EAAE;oBACdA,QAAQ,UAAU,EAAEJ;gBACxB;gBAEAD,UAAU,CAACK,MAAM,GAAG;oBAChBnE,QAAQyD,MAAMzD,MAAM;oBACpBoE,UAAUX,MAAM/E,IAAI;oBACpB2F,QAAQZ,MAAMY,MAAM;oBACpBC,KAAKb,MAAMa,GAAG;oBACdH;oBACAI,IAAId,MAAMc,EAAE;oBACZ,GAAId,MAAMe,OAAO,GACX,IAAI,CAACrG,EAAE,CAACC,SAAS,CAACqG,UAAU,CACxBhB,MAAMzD,MAAM,EACZyD,MAAMiB,KAAK,CAACC,eAAe,CAAC;wBACxB,GAAGlB,MAAMe,OAAO;wBAChBI,YAAYxB,YAAYwB,UAAU;oBACtC,MAEJ,CAAC,CAAC;gBACZ;YACJ,OAAO;gBACH,IAAI,CAACC,mBAAmB,CAACf,YAAYE,OAAOP;YAChD;QACJ;QAEA,OAAOK;IACX;IAEA;;;;;KAKC,GACD,OAAOe,oBAAoBf,UAAU,EAAEE,KAAK,EAAEP,KAAK,EAAE;QACjD,IAAIO,KAAK,CAACP,MAAM,EAAE,OAAOO,KAAK,CAACP,MAAM;QAErC,MAAMqB,UAAUrB,MAAMsB,WAAW,CAAC;QAClC,IAAI9D;QAEJ,IAAI6D,YAAY,CAAC,GAAG;YAChB,qBAAqB;YACrB,MAAME,YAAY;gBAAE,GAAG,IAAI,CAAC7H,IAAI,CAACuG,YAAY,CAACD,MAAM;YAAC;YACrD,IAAI9F,OAAC,CAACgE,OAAO,CAACqD,YAAY;gBACtB,MAAM,IAAIC,sBAAe,CACrB,CAAC,QAAQ,EAAE,IAAI,CAAC9H,IAAI,CAACe,IAAI,CAAC,iCAAiC,EAAEuF,MAAM,EAAE,CAAC;YAE9E;YAEAxC,SACI+C,KAAK,CAACP,MAAM,GACZK,UAAU,CAACL,MAAM,GACb;gBAAE,GAAG,IAAI,CAACS,wBAAwB,CAACc,UAAU;YAAC;QAC1D,OAAO;YACH,MAAME,OAAOzB,MAAM0B,MAAM,CAAC,GAAGL;YAC7B,MAAMM,OAAO3B,MAAM0B,MAAM,CAACL,UAAU;YAEpC,IAAIO,WAAWrB,KAAK,CAACkB,KAAK;YAC1B,IAAI,CAACG,UAAU;gBACXA,WAAW,IAAI,CAACR,mBAAmB,CAACf,YAAYE,OAAOkB;YAC3D;YAEA,MAAMlF,SAASqF,SAASX,KAAK,IAAI,IAAI,CAACvG,EAAE,CAACuG,KAAK,CAACW,SAASrF,MAAM;YAC9D,MAAMgF,YAAY;gBAAE,GAAGhF,OAAO7C,IAAI,CAACuG,YAAY,CAAC0B,KAAK;YAAC;YACtD,IAAIzH,OAAC,CAACgE,OAAO,CAACqD,YAAY;gBACtB,MAAM,IAAIC,sBAAe,CACrB,CAAC,QAAQ,EAAEjF,OAAO7C,IAAI,CAACe,IAAI,CAAC,iCAAiC,EAAEuF,MAAM,EAAE,CAAC;YAEhF;YAEAxC,SAAS;gBAAE,GAAGjB,OAAOkE,wBAAwB,CAACc,WAAW,IAAI,CAAC7G,EAAE,CAAC;YAAC;YAElE,IAAI,CAACkH,SAASC,SAAS,EAAE;gBACrBD,SAASC,SAAS,GAAG,CAAC;YAC1B;YAEAtB,KAAK,CAACP,MAAM,GAAG4B,SAASC,SAAS,CAACF,KAAK,GAAGnE;QAC9C;QAEA,IAAIA,OAAOwC,KAAK,EAAE;YACd,IAAI,CAACoB,mBAAmB,CACpBf,YACAE,OACAP,QAAQ,MAAMxC,OAAOwC,KAAK;QAElC;QAEA,OAAOxC;IACX;IAEA,OAAOiD,yBAAyBT,KAAK,EAAE8B,SAAS,EAAE;QAC9C,IAAI,CAAC9B,MAAMzD,MAAM,EAAE;YACf,MAAM,IAAI4B,uBAAgB,CAAC;QAC/B;QAEA,IAAI6B,MAAMzD,MAAM,CAACwF,OAAO,CAAC,OAAO,GAAG;YAC/B,MAAM,CAACC,YAAYC,WAAW,GAAGjC,MAAMzD,MAAM,CAACnC,KAAK,CAAC,KAAK;YAEzD,MAAM8H,MAAM,IAAI,CAACxH,EAAE,CAACwH,GAAG;YAEvB,MAAMC,QAAQD,IAAIxH,EAAE,CAACsH;YACrB,IAAI,CAACG,OAAO;gBACR,MAAM,IAAIhE,uBAAgB,CACtB,CAAC,uBAAuB,EAAE6D,WAAW,iDAAiD,CAAC;YAE/F;YAEAhC,MAAMzD,MAAM,GAAG4F,MAAMxH,SAAS,CAACyH,QAAQ,GAAG,MAAMH;YAChDjC,MAAMiB,KAAK,GAAGkB,MAAMlB,KAAK,CAACgB;YAE1B,IAAI,CAACjC,MAAMiB,KAAK,EAAE;gBACd,MAAM,IAAI9C,uBAAgB,CACtB,CAAC,8BAA8B,EAAE6D,WAAW,CAAC,EAAEC,WAAW,EAAE,CAAC;YAErE;QACJ,OAAO;YACHjC,MAAMiB,KAAK,GAAG,IAAI,CAACvG,EAAE,CAACuG,KAAK,CAACjB,MAAMzD,MAAM;YAExC,IAAIuF,aAAaA,cAAc,IAAI,CAACpH,EAAE,EAAE;gBACpCsF,MAAMzD,MAAM,GAAG,IAAI,CAAC7B,EAAE,CAACC,SAAS,CAACyH,QAAQ,GAAG,MAAMpC,MAAMzD,MAAM;YAClE;QACJ;QAEA,IAAI,CAACyD,MAAMa,GAAG,EAAE;YACZb,MAAMa,GAAG,GAAGb,MAAMiB,KAAK,CAACvH,IAAI,CAACsD,QAAQ;QACzC;QAEA,OAAOgD;IACX;IAEA,OAAOqC,qBACH,CAACC,MAAMC,SAASC,SAAS,EACzBC,SAAS,EACTC,eAAe,EACjB;QACEA,mBAAmB,QAASA,CAAAA,kBAAkBtJ,sBAAqB;QACnEoJ,WAAWtI,OAAC,CAACyI,SAAS,CAACH,UAAU,CAACI,QAC9BA,MAAMvI,GAAG,CAAC,CAAChB,SAAWqJ,gBAAgBrJ;QAG1C,MAAMwJ,YAAY,CAAC;QACnB,MAAMC,OAAO,IAAI;QAEjB,qFAAqF;QACrFP,UAAUA,QAAQlI,GAAG,CAAC,CAAC0I;YACnB,IAAIA,IAAIC,KAAK,KAAK,IAAI;gBAClB,MAAMC,MAAMF,IAAItI,IAAI,CAACsH,OAAO,CAAC;gBAC7B,IAAIkB,MAAM,GAAG;oBACT,OAAO;wBACHD,OAAOD,IAAItI,IAAI,CAACiH,MAAM,CAAC,GAAGuB;wBAC1BxI,MAAMsI,IAAItI,IAAI,CAACiH,MAAM,CAACuB,MAAM;oBAChC;gBACJ;gBAEA,OAAO;oBACHD,OAAO;oBACPvI,MAAMsI,IAAItI,IAAI;gBAClB;YACJ;YAEA,OAAO;gBACHuI,OAAOD,IAAIC,KAAK;gBAChBvI,MAAMsI,IAAItI,IAAI;YAClB;QACJ;QAEA,gCAAgC;QAChC,SAASyI,YAAYC,WAAW,EAAEC,SAAS,EAAEnD,YAAY,EAAEoD,QAAQ;YAC/D,OAAOnJ,OAAC,CAACoJ,IAAI,CACTrD,cACA,CAAC,EAAEsD,GAAG,EAAE1C,GAAG,EAAE2C,IAAI,EAAE3B,SAAS,EAAE,EAAExI;gBAC5B,IAAIkK,KAAK;gBAET,MAAME,cAAcJ,SAASjD,MAAM;gBACnCqD,YAAYC,IAAI,CAACrK;gBAEjB,MAAMsK,SAASjB,gBAAgBrJ;gBAC/B,MAAMuK,SAASR,SAAS,CAACO,OAAO;gBAEhC,IAAI,CAACC,QAAQ;oBACT,+EAA+E;oBAC/E;gBACJ;gBAEA,MAAMC,aAAaV,YAAYU,UAAU,CAACF,OAAO;gBAEjD,yBAAyB;gBACzB,MAAMG,cAAcF,MAAM,CAAC/C,IAAI;gBAC/B,IAAI3G,OAAC,CAAC6J,KAAK,CAACD,cAAc;oBACtB,IAAIN,QAAQM,eAAe,MAAM;wBAC7B,IAAIX,YAAYC,SAAS,CAACO,OAAO,EAAE;4BAC/BR,YAAYC,SAAS,CAACO,OAAO,CAACD,IAAI,CAACE;wBACvC,OAAO;4BACHT,YAAYC,SAAS,CAACO,OAAO,GAAG;gCAACC;6BAAO;wBAC5C;oBACJ;oBAEA;gBACJ;gBAEA,MAAMI,iBAAiBH,cAAcA,UAAU,CAACC,YAAY;gBAC5D,IAAIE,gBAAgB;oBAChB,IAAInC,WAAW;wBACX,OAAOqB,YACHc,gBACAJ,QACA/B,WACA4B;oBAER;gBACJ,OAAO;oBACH,IAAI,CAACD,MAAM;wBACP,MAAM,IAAIrF,uBAAgB,CACtB,CAAC,8BAA8B,EAAEsF,YAAYlJ,IAAI,CAC7C,KACF,YAAY,EAAEsG,IAAI,aAAa,EAC7BiC,KAAKpJ,IAAI,CAACe,IAAI,CACjB,mBAAmB,CAAC,EACrB;4BAAE0I;4BAAaC;wBAAU;oBAEjC;oBAEA,IAAID,YAAYC,SAAS,CAACO,OAAO,EAAE;wBAC/BR,YAAYC,SAAS,CAACO,OAAO,CAACD,IAAI,CAACE;oBACvC,OAAO;wBACHT,YAAYC,SAAS,CAACO,OAAO,GAAG;4BAACC;yBAAO;oBAC5C;oBAEA,MAAMK,WAAW;wBACbb,WAAWQ;oBACf;oBAEA,IAAI/B,WAAW;wBACXoC,SAASJ,UAAU,GAAGK,gBAClBN,QACA/B;oBAER;oBAEA,IAAI,CAACgC,YAAY;wBACb,MAAM,IAAI1F,uBAAgB,CACtB,CAAC,+BAA+B,EAAEsF,YAAYlJ,IAAI,CAC9C,KACF,YAAY,EAAEsG,IAAI,aAAa,EAC7BiC,KAAKpJ,IAAI,CAACe,IAAI,CACjB,iBAAiB,CAAC,EACnB;4BAAE0I;4BAAaC;wBAAU;oBAEjC;oBAEAS,UAAU,CAACC,YAAY,GAAGG;gBAC9B;YACJ;QAER;QAEA,kCAAkC;QAClC,SAASC,gBAAgBd,SAAS,EAAEnD,YAAY;YAC5C,MAAMkE,UAAU,CAAC;YAEjBjK,OAAC,CAACoJ,IAAI,CAACrD,cAAc,CAAC,EAAEsD,GAAG,EAAE1C,GAAG,EAAE2C,IAAI,EAAE3B,SAAS,EAAE,EAAExI;gBACjD,IAAIkK,KAAK;oBACL;gBACJ;gBAEA,MAAMI,SAASjB,gBAAgBrJ;gBAC/B,IAAI+K,YAAYhB,SAAS,CAACO,OAAO;gBACjC,MAAMM,WAAW;oBACbb,WAAWgB;gBACf;gBAEA,IAAIZ,MAAM;oBACN,IAAI,CAACY,WAAW;wBACZ,+EAA+E;wBAC/EhB,SAAS,CAACO,OAAO,GAAG,EAAE;wBACtB;oBACJ;oBAEAP,SAAS,CAACO,OAAO,GAAG;wBAACS;qBAAU;oBAE/B,YAAY;oBACZ,IAAIlK,OAAC,CAAC6J,KAAK,CAACK,SAAS,CAACvD,IAAI,GAAG;wBACzB,iCAAiC;wBACjCuD,YAAY;oBAChB;gBACJ;gBAEA,IAAIA,WAAW;oBACX,IAAIvC,WAAW;wBACXoC,SAASJ,UAAU,GAAGK,gBAClBE,WACAvC;oBAER;oBAEAsC,OAAO,CAACR,OAAO,GAAGS,SAAS,CAACvD,IAAI,GAC1B;wBACI,CAACuD,SAAS,CAACvD,IAAI,CAAC,EAAEoD;oBACtB,IACA,CAAC;gBACX;YACJ;YAEA,OAAOE;QACX;QAEA,MAAME,cAAc,EAAE;QAEtB,mCAAmC;QACnC,MAAMC,gBAAgB/B,QAAQgC,MAAM,CAAC,CAAC/G,QAAQuF;YAC1C,IAAIA,IAAIC,KAAK,KAAK,KAAK;gBACnB,MAAMwB,SAAShH,MAAM,CAACuF,IAAIC,KAAK,CAAC;gBAChC,IAAIwB,QAAQ;oBACRA,MAAM,CAACzB,IAAItI,IAAI,CAAC,GAAG;gBACvB,OAAO;oBACH+C,MAAM,CAACuF,IAAIC,KAAK,CAAC,GAAG;wBAAE,CAACD,IAAItI,IAAI,CAAC,EAAE;oBAAK;gBAC3C;YACJ;YAEA,OAAO+C;QACX,GAAG,CAAC;QAEJ,mBAAmB;QACnB8E,KAAK9B,OAAO,CAAC,CAACiE;YACV,MAAMC,aAAa,CAAC,GAAG,wCAAwC;YAE/D,sBAAsB;YACtB,MAAMtB,YAAYqB,IAAIF,MAAM,CAAC,CAAC/G,QAAQzC,OAAO4J;gBACzC,MAAM5B,MAAMR,OAAO,CAACoC,OAAO;gBAE3B,IAAI5B,IAAIC,KAAK,KAAK,KAAK;oBACnBxF,MAAM,CAACuF,IAAItI,IAAI,CAAC,GAAGM;gBACvB,OAAO,IAAIA,SAAS,MAAM;oBACtB,4CAA4C;oBAC5C,MAAMyJ,SAASE,UAAU,CAAC3B,IAAIC,KAAK,CAAC;oBACpC,IAAIwB,QAAQ;wBACR,wBAAwB;wBACxBA,MAAM,CAACzB,IAAItI,IAAI,CAAC,GAAGM;oBACvB,OAAO;wBACH2J,UAAU,CAAC3B,IAAIC,KAAK,CAAC,GAAG;4BACpB,GAAGsB,aAAa,CAACvB,IAAIC,KAAK,CAAC;4BAC3B,CAACD,IAAItI,IAAI,CAAC,EAAEM;wBAChB;oBACJ;gBACJ;gBAEA,OAAOyC;YACX,GAAG,CAAC;YAEJtD,OAAC,CAAC0K,MAAM,CAACF,YAAY,CAACG,KAAK7B;gBACvB,MAAMK,WAAWb,QAAQ,CAACQ,MAAM;gBAChC9I,OAAC,CAAC4K,GAAG,CAAC1B,WAAWC,UAAUwB;YAC/B;YAEA,MAAME,SAAS3B,SAAS,CAACN,KAAKpJ,IAAI,CAACsD,QAAQ,CAAC;YAC5C,MAAMmG,cAAcN,SAAS,CAACkC,OAAO;YACrC,IAAI5B,aAAa;gBACb,OAAOD,YAAYC,aAAaC,WAAWX,WAAW,EAAE;YAC5D;YAEA4B,YAAYX,IAAI,CAACN;YACjBP,SAAS,CAACkC,OAAO,GAAG;gBAChB3B;gBACAS,YAAYK,gBAAgBd,WAAWX;YAC3C;QACJ;QAEA,OAAO4B;IACX;IAEA;;;;;KAKC,GACD,OAAOW,qBAAqBC,IAAI,EAAEC,KAAK,EAAE;QACrC,MAAMtK,MAAM,CAAC;QACT,MAAMuK,SAAS,CAAC;QAChB,MAAMC,OAAO,CAAC;QAClB,MAAM1L,OAAO,IAAI,CAACA,IAAI,CAACuG,YAAY;QAEnC/F,OAAC,CAAC0K,MAAM,CAACK,MAAM,CAACI,GAAGC;YACf,IAAIA,CAAC,CAAC,EAAE,KAAK,KAAK;gBACd,iBAAiB;gBACjB,MAAMjM,SAASiM,EAAE5D,MAAM,CAAC;gBACxB,MAAM6D,YAAY7L,IAAI,CAACL,OAAO;gBAC9B,IAAI,CAACkM,WAAW;oBACZ,MAAM,IAAIC,sBAAe,CACrB,CAAC,qBAAqB,EAAEnM,OAAO,aAAa,EAAE,IAAI,CAACK,IAAI,CAACe,IAAI,CAAC,EAAE,CAAC;gBAExE;gBAEA,IACIyK,SACCK,CAAAA,UAAUtK,IAAI,KAAK,cAChBsK,UAAUtK,IAAI,KAAK,WAAU,KACjC5B,UAAU4L,MACZ;oBACE,MAAM,IAAIO,sBAAe,CACrB,CAAC,mBAAmB,EAAEnM,OAAO,aAAa,EAAE,IAAI,CAACK,IAAI,CAACe,IAAI,CAAC,uCAAuC,EAAEpB,OAAO,EAAE,CAAC;gBAEtH;gBAEA8L,MAAM,CAAC9L,OAAO,GAAGgM;YACrB,OAAO,IAAIC,CAAC,CAAC,EAAE,KAAK,KAAK;gBACrB,sBAAsB;gBACtB,MAAMjM,SAASiM,EAAE5D,MAAM,CAAC;gBACxB,MAAM6D,YAAY7L,IAAI,CAACL,OAAO;gBAC9B,IAAI,CAACkM,WAAW;oBACZ,MAAM,IAAIC,sBAAe,CACrB,CAAC,qBAAqB,EAAEnM,OAAO,aAAa,EAAE,IAAI,CAACK,IAAI,CAACe,IAAI,CAAC,EAAE,CAAC;gBAExE;gBAEA,IACI8K,UAAUtK,IAAI,KAAK,cACnBsK,UAAUtK,IAAI,KAAK,aACrB;oBACE,MAAM,IAAIuK,sBAAe,CACrB,CAAC,kBAAkB,EAAED,UAAUtK,IAAI,CAAC,yCAAyC,CAAC,EAC9E;wBACIsB,QAAQ,IAAI,CAAC7C,IAAI,CAACe,IAAI;wBACtBwK;oBACJ;gBAER;gBAEA,IAAIC,SAAS7L,UAAU4L,MAAM;oBACzB,MAAM,IAAIO,sBAAe,CACrB,CAAC,wBAAwB,EAAEnM,OAAO,aAAa,EAAE,IAAI,CAACK,IAAI,CAACe,IAAI,CAAC,uCAAuC,EAAEpB,OAAO,EAAE,CAAC;gBAE3H;gBAEA,MAAMoM,cAAc,MAAMpM;gBAC1B,IAAIoM,eAAeR,MAAM;oBACrB,MAAM,IAAIO,sBAAe,CACrB,CAAC,wBAAwB,EAAEnM,OAAO,aAAa,EAAE,IAAI,CAACK,IAAI,CAACe,IAAI,CAAC,mCAAmC,EAAEgL,YAAY,EAAE,CAAC;gBAE5H;gBAEA,IAAIJ,KAAK,MAAM;oBACXzK,GAAG,CAACvB,OAAO,GAAG;gBAClB,OAAO;oBACH+L,IAAI,CAAC/L,OAAO,GAAGgM;gBACnB;YACJ,OAAO;gBACHzK,GAAG,CAAC0K,EAAE,GAAGD;YACb;QACJ;QAEA,OAAO;YAACzK;YAAKuK;YAAQC;SAAK;IAC9B;IAEA,aAAaM,qBAAqBrJ,OAAO,EAAEsJ,UAAU,EAAE;QACnD,MAAMjM,OAAO,IAAI,CAACA,IAAI,CAACuG,YAAY;QAEnC,MAAM2F,IAAAA,gBAAU,EAACD,YAAY,OAAOE,UAAUxM;YAC1C,MAAMkM,YAAY7L,IAAI,CAACL,OAAO;YAC9B,MAAMyM,mBAAmB,IAAI,CAACpL,EAAE,CAACuG,KAAK,CAACsE,UAAUhJ,MAAM;YAEvD,MAAMwJ,UAAU,MAAMD,iBAAiBtJ,QAAQ,CAC3CqJ,UACAxJ,QAAQM,WAAW;YAGvB,IAAI,CAACoJ,SAAS;gBACV,MAAM,IAAI/J,8BAAuB,CAC7B,CAAC,mBAAmB,EAChB8J,iBAAiBpM,IAAI,CAACe,IAAI,CAC7B,OAAO,EAAEuL,KAAKC,SAAS,CAACJ,UAAU,WAAW,CAAC;YAEvD;YAEAxJ,QAAQzB,GAAG,CAACvB,OAAO,GAAG0M,OAAO,CAACR,UAAU1L,KAAK,CAAC;QAClD;IACJ;IAEA,aAAaqM,eAAe7J,OAAO,EAAE8I,MAAM,EAAEgB,kBAAkB,EAAE;QAC7D,MAAMzM,OAAO,IAAI,CAACA,IAAI,CAACuG,YAAY;QACnC,IAAImG;QAEJ,IAAI,CAACD,oBAAoB;YACrBC,WAAW/J,QAAQwB,MAAM,CAAC,IAAI,CAACnE,IAAI,CAACsD,QAAQ,CAAC;YAE7C,IAAI9C,OAAC,CAAC6J,KAAK,CAACqC,WAAW;gBACnB,IAAI/J,QAAQmB,MAAM,CAACC,YAAY,KAAK,GAAG;oBACnC,iBAAiB;oBAEjB,MAAM4I,QAAQ,IAAI,CAACpI,0BAA0B,CACzC5B,QAAQwB,MAAM;oBAElBxB,QAAQwB,MAAM,GAAG,MAAM,IAAI,CAACrB,QAAQ,CAChC;wBAAEC,QAAQ4J;oBAAM,GAChBhK,QAAQM,WAAW;oBAEvB,IAAI,CAACN,QAAQwB,MAAM,EAAE;wBACjB,MAAM,IAAIM,uBAAgB,CACtB,gGACA;4BACIkI;4BACApB,MAAM5I,QAAQwB,MAAM;4BACpBoC,cAAckF;wBAClB;oBAER;gBACJ;gBAEAiB,WAAW/J,QAAQwB,MAAM,CAAC,IAAI,CAACnE,IAAI,CAACsD,QAAQ,CAAC;gBAE7C,IAAI9C,OAAC,CAAC6J,KAAK,CAACqC,WAAW;oBACnB,MAAM,IAAIjI,uBAAgB,CACtB,uDACI,IAAI,CAACzE,IAAI,CAACe,IAAI,EAClB;wBACIwK,MAAM5I,QAAQwB,MAAM;wBACpBoC,cAAckF;oBAClB;gBAER;YACJ;QACJ;QAEA,MAAMmB,gBAAgB,CAAC;QACvB,MAAMC,WAAW,CAAC;QAElB,8DAA8D;QAC9D,MAAMC,gBAAgBtM,OAAC,CAACuM,IAAI,CAACpK,QAAQK,OAAO,EAAE;YAC1C;YACA;YACA;YACA;YACA;SACH;QAED,MAAMkJ,IAAAA,gBAAU,EAACT,QAAQ,OAAOF,MAAM5L;YAClC,MAAMkM,YAAY7L,IAAI,CAACL,OAAO;YAE9B,IACI8M,sBACAZ,UAAUtK,IAAI,KAAK,cACnBsK,UAAUtK,IAAI,KAAK,aACrB;gBACEqL,aAAa,CAACjN,OAAO,GAAG4L;gBACxB;YACJ;YAEA,MAAMyB,aAAa,IAAI,CAAChM,EAAE,CAACuG,KAAK,CAACsE,UAAUhJ,MAAM;YAEjD,IAAIgJ,UAAU/B,IAAI,EAAE;gBAChByB,OAAO/K,OAAC,CAACyM,SAAS,CAAC1B;gBAEnB,IAAI,CAACM,UAAU1L,KAAK,EAAE;oBAClB,MAAM,IAAIsE,uBAAgB,CACtB,CAAC,yDAAyD,EAAE9E,OAAO,aAAa,EAAE,IAAI,CAACK,IAAI,CAACe,IAAI,CAAC,EAAE,CAAC;gBAE5G;gBAEA,OAAOmL,IAAAA,gBAAU,EAACX,MAAM,CAAC2B,OACrBF,WAAW/K,OAAO,CACd;wBAAE,GAAGiL,IAAI;wBAAE,CAACrB,UAAU1L,KAAK,CAAC,EAAEuM;oBAAS,GACvCI,eACAnK,QAAQM,WAAW;YAG/B,OAAO,IAAI,CAACzC,OAAC,CAACmE,aAAa,CAAC4G,OAAO;gBAC/B,IAAI5J,MAAMC,OAAO,CAAC2J,OAAO;oBACrB,MAAM,IAAI9G,uBAAgB,CACtB,CAAC,mCAAmC,EAAEoH,UAAUhJ,MAAM,CAAC,uBAAuB,EAAE,IAAI,CAAC7C,IAAI,CAACe,IAAI,CAAC,mCAAmC,EAAEpB,OAAO,iCAAiC,CAAC;gBAErL;gBAEA,IAAI,CAACkM,UAAUvF,KAAK,EAAE;oBAClB,MAAM,IAAI7B,uBAAgB,CACtB,CAAC,kCAAkC,EAAE9E,OAAO,yCAAyC,CAAC;gBAE9F;gBAEA4L,OAAO;oBAAE,CAACM,UAAUvF,KAAK,CAAC,EAAEiF;gBAAK;YACrC;YAEA,IAAI,CAACkB,sBAAsBZ,UAAU1L,KAAK,EAAE;gBACxC,oBAAoB;gBACpBoL,OAAO;oBAAE,GAAGA,IAAI;oBAAE,CAACM,UAAU1L,KAAK,CAAC,EAAEuM;gBAAS;YAClD;YAEAI,cAAczI,iBAAiB,GAAG;YAClC,IAAIgI,UAAU,MAAMW,WAAW/K,OAAO,CAClCsJ,MACAuB,eACAnK,QAAQM,WAAW;YAGvB,IACI6J,cAAcnJ,OAAO,CAACI,YAAY,KAAK,KACtCiJ,WAAWlN,gBAAgB,IACxBgN,cAAcnJ,OAAO,CAACK,QAAQ,KAAK,GACzC;gBACE,6BAA6B;gBAE7B,MAAMmJ,aAAaH,WAAWzI,0BAA0B,CAACgH;gBAEzDc,UAAU,MAAMW,WAAWlK,QAAQ,CAC/B;oBAAEC,QAAQoK;gBAAW,GACrBxK,QAAQM,WAAW;gBAEvB,IAAI,CAACoJ,SAAS;oBACV,MAAM,IAAI5H,uBAAgB,CACtB,oGACA;wBACIkI,OAAOQ;wBACP5B;oBACJ;gBAER;YACJ;YAEAsB,QAAQ,CAAClN,OAAO,GAAG8M,qBACbJ,OAAO,CAACR,UAAU1L,KAAK,CAAC,GACxBkM,OAAO,CAACR,UAAU1E,GAAG,CAAC;QAChC;QAEA,IAAIsF,oBAAoB;YACpBjM,OAAC,CAAC0K,MAAM,CAAC2B,UAAU,CAACO,eAAeC;gBAC/B1K,QAAQzB,GAAG,CAACmM,WAAW,GAAGD;YAC9B;QACJ;QAEA,OAAOR;IACX;IAEA,aAAaU,eACT3K,OAAO,EACP8I,MAAM,EACN8B,kBAAkB,EAClBC,eAAe,EACjB;QACE,MAAMxN,OAAO,IAAI,CAACA,IAAI,CAACuG,YAAY;QAEnC,IAAIkH;QAEJ,IAAI,CAACF,oBAAoB;YACrBE,kBAAkBC,aACd;gBAAC/K,QAAQK,OAAO,CAACD,MAAM;gBAAEJ,QAAQwB,MAAM;aAAC,EACxC,IAAI,CAACnE,IAAI,CAACsD,QAAQ;YAEtB,IAAI9C,OAAC,CAAC6J,KAAK,CAACoD,kBAAkB;gBAC1B,0BAA0B;gBAC1B,MAAM,IAAIhJ,uBAAgB,CACtB,uDACI,IAAI,CAACzE,IAAI,CAACe,IAAI;YAE1B;QACJ;QAEA,MAAM6L,gBAAgB,CAAC;QAEvB,8DAA8D;QAC9D,MAAME,gBAAgBtM,OAAC,CAACuM,IAAI,CAACpK,QAAQK,OAAO,EAAE;YAC1C;YACA;YACA;YACA;SACH;QAED,MAAMkJ,IAAAA,gBAAU,EAACT,QAAQ,OAAOF,MAAM5L;YAClC,MAAMkM,YAAY7L,IAAI,CAACL,OAAO;YAE9B,IACI4N,sBACA1B,UAAUtK,IAAI,KAAK,cACnBsK,UAAUtK,IAAI,KAAK,aACrB;gBACEqL,aAAa,CAACjN,OAAO,GAAG4L;gBACxB;YACJ;YAEA,MAAMyB,aAAa,IAAI,CAAChM,EAAE,CAACuG,KAAK,CAACsE,UAAUhJ,MAAM;YAEjD,IAAIgJ,UAAU/B,IAAI,EAAE;gBAChByB,OAAO/K,OAAC,CAACyM,SAAS,CAAC1B;gBAEnB,IAAI,CAACM,UAAU1L,KAAK,EAAE;oBAClB,MAAM,IAAIsE,uBAAgB,CACtB,CAAC,yDAAyD,EAAE9E,OAAO,aAAa,EAAE,IAAI,CAACK,IAAI,CAACe,IAAI,CAAC,EAAE,CAAC;gBAE5G;gBAEA,MAAM4M,YAAYC,UACdrC,MACA,CAACsC,SAAWA,MAAM,CAAChC,UAAU1E,GAAG,CAAC,IAAI,MACrC,CAAC0G,SAAWA,MAAM,CAAChC,UAAU1E,GAAG,CAAC;gBAErC,MAAM2G,uBAAuB;oBACzB,CAACjC,UAAU1L,KAAK,CAAC,EAAEsN;gBACvB;gBACA,IAAIE,UAAUI,MAAM,GAAG,GAAG;oBACtBD,oBAAoB,CAACjC,UAAU1E,GAAG,CAAC,GAAG;wBAAE6G,QAAQL;oBAAU;gBAC9D;gBAEA,MAAMX,WAAWiB,WAAW,CACxBH,sBACAnL,QAAQM,WAAW;gBAGvB,OAAOiJ,IAAAA,gBAAU,EAACX,MAAM,CAAC2B,OACrBA,IAAI,CAACrB,UAAU1E,GAAG,CAAC,IAAI,OACjB6F,WAAWvK,UAAU,CACjB;wBACI,GAAGjC,OAAC,CAACgD,IAAI,CAAC0J,MAAM;4BAACrB,UAAU1E,GAAG;yBAAC,CAAC;wBAChC,CAAC0E,UAAU1L,KAAK,CAAC,EAAEsN;oBACvB,GACA;wBACI1K,QAAQ;4BACJ,CAAC8I,UAAU1E,GAAG,CAAC,EAAE+F,IAAI,CAACrB,UAAU1E,GAAG,CAAC;wBACxC;wBACA,GAAG2F,aAAa;oBACpB,GACAnK,QAAQM,WAAW,IAEvB+J,WAAW/K,OAAO,CACd;wBAAE,GAAGiL,IAAI;wBAAE,CAACrB,UAAU1L,KAAK,CAAC,EAAEsN;oBAAgB,GAC9CX,eACAnK,QAAQM,WAAW;YAGrC,OAAO,IAAI,CAACzC,OAAC,CAACmE,aAAa,CAAC4G,OAAO;gBAC/B,IAAI5J,MAAMC,OAAO,CAAC2J,OAAO;oBACrB,MAAM,IAAI9G,uBAAgB,CACtB,CAAC,mCAAmC,EAAEoH,UAAUhJ,MAAM,CAAC,uBAAuB,EAAE,IAAI,CAAC7C,IAAI,CAACe,IAAI,CAAC,mCAAmC,EAAEpB,OAAO,iCAAiC,CAAC;gBAErL;gBAEA,IAAI,CAACkM,UAAUvF,KAAK,EAAE;oBAClB,MAAM,IAAI7B,uBAAgB,CACtB,CAAC,kCAAkC,EAAE9E,OAAO,yCAAyC,CAAC;gBAE9F;gBAEA,eAAe;gBACf4L,OAAO;oBAAE,CAACM,UAAUvF,KAAK,CAAC,EAAEiF;gBAAK;YACrC;YAEA,IAAIgC,oBAAoB;gBACpB,IAAI/M,OAAC,CAACgE,OAAO,CAAC+G,OAAO;gBAErB,wBAAwB;gBACxB,IAAI2C,eAAeR,aACf;oBAAC/K,QAAQiD,QAAQ;oBAAEjD,QAAQK,OAAO,CAACD,MAAM;oBAAEJ,QAAQzB,GAAG;iBAAC,EACvDvB;gBAGJ,IAAIuO,gBAAgB,MAAM;oBACtB,IAAI1N,OAAC,CAACgE,OAAO,CAAC7B,QAAQiD,QAAQ,GAAG;wBAC7BjD,QAAQiD,QAAQ,GAAG,MAAM,IAAI,CAAC9C,QAAQ,CAClCH,QAAQK,OAAO,CAACD,MAAM,EACtBJ,QAAQM,WAAW;wBAEvB,IAAI,CAACN,QAAQiD,QAAQ,EAAE;4BACnB,MAAM,IAAIkG,sBAAe,CACrB,CAAC,WAAW,EAAE,IAAI,CAAC9L,IAAI,CAACe,IAAI,CAAC,YAAY,CAAC,EAC1C;gCACI4L,OAAOhK,QAAQK,OAAO,CAACD,MAAM;4BACjC;wBAER;wBACAmL,eAAevL,QAAQiD,QAAQ,CAACjG,OAAO;oBAC3C;oBAEA,IAAIuO,gBAAgB,MAAM;wBACtB,IAAI,CAAEvO,CAAAA,UAAUgD,QAAQiD,QAAQ,AAAD,GAAI;4BAC/B,MAAM,IAAInB,uBAAgB,CACtB,qEACA;gCACI9E;gCACA4L;gCACA3F,UAAUjD,QAAQiD,QAAQ;gCAC1B+G,OAAOhK,QAAQK,OAAO,CAACD,MAAM;gCAC7B7B,KAAKyB,QAAQzB,GAAG;4BACpB;wBAER;wBAEA,6CAA6C;wBAE7C4L,cAAczI,iBAAiB,GAAG;wBAClC,IAAIgI,UAAU,MAAMW,WAAW/K,OAAO,CAClCsJ,MACAuB,eACAnK,QAAQM,WAAW;wBAGvB,IAAI6J,cAAcnJ,OAAO,CAACI,YAAY,KAAK,GAAG;4BAC1C,iBAAiB;4BAEjB,MAAMoJ,aACFH,WAAWzI,0BAA0B,CAACgH;4BAC1Cc,UAAU,MAAMW,WAAWlK,QAAQ,CAC/B;gCAAEC,QAAQoK;4BAAW,GACrBxK,QAAQM,WAAW;4BAEvB,IAAI,CAACoJ,SAAS;gCACV,MAAM,IAAI5H,uBAAgB,CACtB,oGACA;oCACIkI,OAAOQ;oCACP5B;gCACJ;4BAER;wBACJ;wBAEA5I,QAAQzB,GAAG,CAACvB,OAAO,GAAG0M,OAAO,CAACR,UAAU1L,KAAK,CAAC;wBAC9C;oBACJ;gBACJ;gBAEA,IAAI+N,cAAc;oBACd,OAAOlB,WAAWvK,UAAU,CACxB8I,MACA;wBAAE,CAACM,UAAU1L,KAAK,CAAC,EAAE+N;wBAAc,GAAGpB,aAAa;oBAAC,GACpDnK,QAAQM,WAAW;gBAE3B;gBAEA,wCAAwC;gBACxC;YACJ;YAEA,MAAM+J,WAAWiB,WAAW,CACxB;gBAAE,CAACpC,UAAU1L,KAAK,CAAC,EAAEsN;YAAgB,GACrC9K,QAAQM,WAAW;YAGvB,IAAIuK,iBAAiB;gBACjB,OAAOR,WAAW/K,OAAO,CACrB;oBAAE,GAAGsJ,IAAI;oBAAE,CAACM,UAAU1L,KAAK,CAAC,EAAEsN;gBAAgB,GAC9CX,eACAnK,QAAQM,WAAW;YAE3B;YAEA,MAAM,IAAI9B,MACN;QAGJ,sIAAsI;QAC1I;QAEA,OAAOyL;IACX;AACJ;MAEA,WAAehN"}