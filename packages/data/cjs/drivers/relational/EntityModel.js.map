{"version":3,"sources":["../../../src/drivers/relational/EntityModel.js"],"sourcesContent":["import { _, eachAsync_ } from '@kitmi/july';\nimport EntityModel from '../../EntityModel';\nimport {\n    ApplicationError,\n    ReferencedNotExistError,\n    DuplicateError,\n    ValidationError,\n    InvalidArgument,\n} from '@kitmi/types';\nimport { Types } from '@kitmi/validators/allSync';\n\nconst defaultNestedKeyGetter = (anchor) => ':' + anchor;\n\n/**\n * Relational entity model class.\n */\nclass RelationalEntityModel extends EntityModel {\n    /**\n     * [specific] Check if this entity has auto increment feature.\n     */\n    get hasAutoIncrement() {\n        const autoId = this._meta.features.autoId;\n        return autoId && this._meta.fields[autoId.field].autoIncrementId;\n    }\n\n    /**\n     * [override] Serialize value into database acceptable format.\n     * @param {object} name - Name of the symbol token\n     */\n    _translateSymbolToken(name) {\n        if (name === 'NOW') {\n            return this.db.connector.raw('NOW()');\n        }\n\n        throw new Error('Unsupported symbol token: ' + name);\n    }\n\n    /**\n     * [override]\n     * @param {*} value\n     * @param {*} info\n     */\n    _serializeByTypeInfo(value, info) {\n        if (info.type === 'boolean') {\n            return value ? 1 : 0;\n        }\n\n        if (info.type === 'datetime') {\n            return Types.DATETIME.serialize(value);\n        }\n\n        if (info.type === 'array' && Array.isArray(value)) {\n            if (info.csv) {\n                return Types.ARRAY.toCsv(value);\n            } else {\n                return Types.ARRAY.serialize(value);\n            }\n        }\n\n        if (info.type === 'object') {\n            return Types.OBJECT.serialize(value);\n        }\n\n        return value;\n    }\n\n    async _doReplaceOne_(context) {\n        await this.ensureTransaction_(context);\n\n        const entity = await this.findOne_(\n            { $query: context.options.$query },\n            context.connOptions\n        );\n\n        let ret, options;\n\n        if (entity) {\n            if (context.options.$retrieveExisting) {\n                context.rawOptions.$existing = entity;\n            }\n\n            options = {\n                ...context.options,\n                $query: { [this._meta.keyField]: super.valueOfKey(entity) },\n                $existing: entity,\n            };\n\n            ret = await this.updateOne_(\n                context.raw,\n                options,\n                context.connOptions\n            );\n        } else {\n            options = {\n                ..._.omit(context.options, [\n                    '$retrieveUpdated',\n                    '$skipUniqueCheck',\n                ]),\n                $retrieveCreated: context.options.$retrieveUpdated,\n            };\n\n            ret = await this.create_(context.raw, options, context.connOptions);\n        }\n\n        if (options.$existing) {\n            context.rawOptions.$existing = options.$existing;\n        }\n\n        if (options.$result) {\n            context.rawOptions.$result = options.$result;\n        }\n\n        return ret;\n    }\n\n    _internalBeforeCreate_(context) {\n        return true;\n    }\n\n    _fillResult(context) {\n        if (this.hasAutoIncrement && context.result.affectedRows > 0) {\n            const { insertId } = context.result;\n            if (insertId > 0) {\n                context.latest = {\n                    ...context.latest,\n                    [this._meta.features.autoId.field]: insertId,\n                };\n            } else if (context.result.upsert) {\n                // the key is not correct \n                delete context.latest[this._meta.features.autoId.field];\n            }\n        } else if (context.result.upsert) {\n            // the key is not used \n            delete context.latest[this._meta.keyField];\n        }\n\n        context.return = context.latest;\n    }\n\n    /**\n     * Post create processing.\n     * @param {*} context\n     * @property {object} [context.options] - Create options\n     * @property {bool} [options.$retrieveCreated] - Retrieve the newly created record from db.\n     */\n    async _internalAfterCreate_(context) {\n        if (context.options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result;\n        }\n\n        if (context.options.$retrieveCreated) {\n            if (this.hasAutoIncrement) {\n                if (context.result.affectedRows === 0) {\n                    // insert ignored\n                    context.queryKey = this.getUniqueKeyValuePairsFrom(\n                        context.latest\n                    );\n\n                    if (_.isEmpty(context.queryKey)) {\n                        throw new ApplicationError(\n                            'Cannot extract unique keys from input data.',\n                            {\n                                entity: this._meta.name,\n                            }\n                        );\n                    }\n                } else {\n                    const { insertId } = context.result;\n                    context.queryKey = {\n                        [this._meta.features.autoId.field]: insertId,\n                    };\n                }\n            } else {\n                context.queryKey = this.getUniqueKeyValuePairsFrom(\n                    context.latest\n                );\n\n                if (_.isEmpty(context.queryKey)) {\n                    throw new ApplicationError(\n                        'Cannot extract unique keys from input data.',\n                        {\n                            entity: this._meta.name,\n                        }\n                    );\n                }\n            }\n\n            const retrieveOptions = _.isPlainObject(\n                context.options.$retrieveCreated\n            )\n                ? context.options.$retrieveCreated\n                : {};\n            context.return = await this.findOne_(\n                { ...retrieveOptions, $query: context.queryKey },\n                context.connOptions\n            );\n        } else {\n            if (this.hasAutoIncrement) {\n                if (context.result.affectedRows === 0) {\n                    context.queryKey = this.getUniqueKeyValuePairsFrom(\n                        context.latest\n                    );\n                } else {\n                    const { insertId } = context.result;\n                    context.queryKey = {\n                        [this._meta.features.autoId.field]: insertId,\n                    };\n                }\n            }\n        }\n    }\n\n    static _internalBeforeUpdate_(context) {\n        return true;\n    }\n\n    static _internalBeforeUpdateMany_(context) {\n        return true;\n    }\n\n    /**\n     * Post update processing.\n     * @param {*} context\n     * @property {object} [context.options] - Update options\n     * @property {bool} [context.options.$retrieveUpdated] - Retrieve the newly updated record from db.\n     */\n    static async _internalAfterUpdate_(context) {\n        const options = context.options;\n\n        if (options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result || {\n                affectedRows: 0,\n                changedRows: 0,\n            };\n        }\n\n        let retrieveUpdated = options.$retrieveUpdated;\n\n        if (!retrieveUpdated) {\n            if (\n                options.$retrieveActualUpdated &&\n                context.result.affectedRows > 0\n            ) {\n                retrieveUpdated = options.$retrieveActualUpdated;\n            } else if (\n                options.$retrieveNotUpdate &&\n                context.result.affectedRows === 0\n            ) {\n                retrieveUpdated = options.$retrieveNotUpdate;\n            }\n        }\n\n        if (retrieveUpdated) {\n            const condition = {\n                $query: this.getUniqueKeyValuePairsFrom(options.$query),\n            };\n            if (options.$skipUniqueCheck) {\n                condition.$skipUniqueCheck = options.$skipUniqueCheck;\n            }\n\n            let retrieveOptions = {};\n\n            if (_.isPlainObject(retrieveUpdated)) {\n                retrieveOptions = retrieveUpdated;\n            } else if (options.$relationships) {\n                retrieveOptions.$relationships = options.$relationships;\n            }\n\n            context.return = await this.findOne_(\n                {\n                    ...condition,\n                    $includeDeleted: options.$retrieveDeleted,\n                    ...retrieveOptions,\n                },\n                context.connOptions\n            );\n\n            if (context.return) {\n                context.queryKey = this.getUniqueKeyValuePairsFrom(\n                    context.return\n                );\n            } else {\n                context.queryKey = condition.$query;\n            }\n        }\n    }\n\n    /**\n     * Post update processing.\n     * @param {*} context\n     * @param {object} [options] - Update options\n     * @property {bool} [options.$retrieveUpdated] - Retrieve the newly updated record from db.\n     */\n    static async _internalAfterUpdateMany_(context) {\n        const options = context.options;\n\n        if (options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result || {\n                affectedRows: 0,\n                changedRows: 0,\n            };\n\n            /**\n             * afterUpdateMany ResultSetHeader {\n             * fieldCount: 0,\n             * affectedRows: 1,\n             * insertId: 0,\n             * info: 'Rows matched: 1  Changed: 1  Warnings: 0',\n             * serverStatus: 3,\n             * warningStatus: 0,\n             * changedRows: 1 }\n             */\n        }\n\n        if (options.$retrieveUpdated) {\n            let retrieveOptions = {};\n\n            if (_.isPlainObject(options.$retrieveUpdated)) {\n                retrieveOptions = options.$retrieveUpdated;\n            } else if (options.$relationships) {\n                retrieveOptions.$relationships = options.$relationships;\n            }\n\n            context.return = await this.findAll_(\n                {\n                    $query: options.$query,\n                    $includeDeleted: options.$retrieveDeleted,\n                    ...retrieveOptions,\n                },\n                context.connOptions\n            );\n        }\n\n        context.queryKey = options.$query;\n    }\n\n    /**\n     * Before deleting an entity.\n     * @param {*} context\n     * @property {object} [context.options] - Delete options\n     * @property {bool} [context.options.$retrieveDeleted] - Retrieve the recently deleted record from db.\n     */\n    static async _internalBeforeDelete_(context) {\n        if (context.options.$retrieveDeleted) {\n            await this.ensureTransaction_(context);\n\n            const retrieveOptions = _.isPlainObject(\n                context.options.$retrieveDeleted\n            )\n                ? {\n                      ...context.options.$retrieveDeleted,\n                      $query: context.options.$query,\n                  }\n                : { $query: context.options.$query };\n\n            if (context.options.$physicalDeletion) {\n                retrieveOptions.$includeDeleted = true;\n            }\n\n            context.return = context.existing = await this.findOne_(\n                retrieveOptions,\n                context.connOptions\n            );\n        }\n\n        return true;\n    }\n\n    static async _internalBeforeDeleteMany_(context) {\n        if (context.options.$retrieveDeleted) {\n            await this.ensureTransaction_(context);\n\n            const retrieveOptions = _.isPlainObject(\n                context.options.$retrieveDeleted\n            )\n                ? {\n                      ...context.options.$retrieveDeleted,\n                      $query: context.options.$query,\n                  }\n                : { $query: context.options.$query };\n\n            if (context.options.$physicalDeletion) {\n                retrieveOptions.$includeDeleted = true;\n            }\n\n            context.return = context.existing = await this.findAll_(\n                retrieveOptions,\n                context.connOptions\n            );\n        }\n\n        return true;\n    }\n\n    /**\n     * Post delete processing.\n     * @param {*} context\n     */\n    static _internalAfterDelete_(context) {\n        if (context.options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result;\n        }\n    }\n\n    /**\n     * Post delete processing.\n     * @param {*} context\n     */\n    static _internalAfterDeleteMany_(context) {\n        if (context.options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result;\n        }\n    }\n\n    /**\n     *\n     * @param {*} findOptions\n     */\n    static _prepareAssociations(findOptions) {\n        const [normalAssocs, customAssocs] = _.partition(\n            findOptions.$association,\n            (assoc) => typeof assoc === 'string'\n        );\n\n        const associations = _.uniq(normalAssocs).sort().concat(customAssocs);\n        const assocTable = {};\n            let counter = 0;\n            const cache = {};\n\n        associations.forEach((assoc) => {\n            if (_.isPlainObject(assoc)) {\n                assoc = this._translateSchemaNameToDb(assoc);\n\n                let alias = assoc.alias;\n                if (!assoc.alias) {\n                    alias = ':join' + ++counter;\n                }\n\n                assocTable[alias] = {\n                    entity: assoc.entity,\n                    joinType: assoc.type,\n                    output: assoc.output,\n                    key: assoc.key,\n                    alias,\n                    on: assoc.on,\n                    ...(assoc.dataset\n                        ? this.db.connector.buildQuery(\n                              assoc.entity,\n                              assoc.model._prepareQueries({\n                                  ...assoc.dataset,\n                                  $variables: findOptions.$variables,\n                              })\n                          )\n                        : {}),\n                };\n            } else {\n                this._loadAssocIntoTable(assocTable, cache, assoc);\n            }\n        });\n\n        return assocTable;\n    }\n\n    /**\n     *\n     * @param {*} assocTable - Hierarchy with subAssocs\n     * @param {*} cache - Dotted path as key\n     * @param {*} assoc - Dotted path\n     */\n    static _loadAssocIntoTable(assocTable, cache, assoc) {\n        if (cache[assoc]) return cache[assoc];\n\n        const lastPos = assoc.lastIndexOf('.');\n        let result;\n\n        if (lastPos === -1) {\n            // direct association\n            const assocInfo = { ...this._meta.associations[assoc] };\n            if (_.isEmpty(assocInfo)) {\n                throw new InvalidArgument(\n                    `Entity \"${this._meta.name}\" does not have the association \"${assoc}\".`\n                );\n            }\n\n            result =\n                cache[assoc] =\n                assocTable[assoc] =\n                    { ...this._translateSchemaNameToDb(assocInfo) };\n        } else {\n            const base = assoc.substr(0, lastPos);\n            const last = assoc.substr(lastPos + 1);\n\n            let baseNode = cache[base];\n            if (!baseNode) {\n                baseNode = this._loadAssocIntoTable(assocTable, cache, base);\n            }\n\n            const entity = baseNode.model || this.db.model(baseNode.entity);\n            const assocInfo = { ...entity.meta.associations[last] };\n            if (_.isEmpty(assocInfo)) {\n                throw new InvalidArgument(\n                    `Entity \"${entity.meta.name}\" does not have the association \"${assoc}\".`\n                );\n            }\n\n            result = { ...entity._translateSchemaNameToDb(assocInfo, this.db) };\n\n            if (!baseNode.subAssocs) {\n                baseNode.subAssocs = {};\n            }\n\n            cache[assoc] = baseNode.subAssocs[last] = result;\n        }\n\n        if (result.assoc) {\n            this._loadAssocIntoTable(\n                assocTable,\n                cache,\n                assoc + '.' + result.assoc\n            );\n        }\n\n        return result;\n    }\n\n    static _translateSchemaNameToDb(assoc, currentDb) {\n        if (!assoc.entity) {\n            throw new ApplicationError('\"entity\" is required in the association object.');\n        }\n\n        if (assoc.entity.indexOf('.') > 0) {\n            const [schemaName, entityName] = assoc.entity.split('.', 2);\n\n            const app = this.db.app;\n\n            const refDb = app.db(schemaName);\n            if (!refDb) {\n                throw new ApplicationError(\n                    `The referenced schema \"${schemaName}\" does not have db model in the same application.`\n                );\n            }\n\n            assoc.entity = refDb.connector.database + '.' + entityName;\n            assoc.model = refDb.model(entityName);\n\n            if (!assoc.model) {\n                throw new ApplicationError(\n                    `Failed load the entity model \"${schemaName}.${entityName}\".`\n                );\n            }\n        } else {\n            assoc.model = this.db.model(assoc.entity);\n\n            if (currentDb && currentDb !== this.db) {\n                assoc.entity = this.db.connector.database + '.' + assoc.entity;\n            }\n        }\n\n        if (!assoc.key) {\n            assoc.key = assoc.model.meta.keyField;\n        }\n\n        return assoc;\n    }\n\n    static _mapRecordsToObjects(\n        [rows, columns, aliasMap],\n        hierarchy,\n        nestedKeyGetter\n    ) {\n        nestedKeyGetter == null && (nestedKeyGetter = defaultNestedKeyGetter);\n        aliasMap = _.mapValues(aliasMap, (chain) =>\n            chain.map((anchor) => nestedKeyGetter(anchor))\n        );\n\n        const mainIndex = {};\n        const self = this;\n\n        // map mysql column result into array of { table <table alias>, name: <column name> }\n        columns = columns.map((col) => {\n            if (col.table === '') {\n                const pos = col.name.indexOf('$');\n                if (pos > 0) {\n                    return {\n                        table: col.name.substr(0, pos),\n                        name: col.name.substr(pos + 1),\n                    };\n                }\n\n                return {\n                    table: 'A',\n                    name: col.name,\n                };\n            }\n\n            return {\n                table: col.table,\n                name: col.name,\n            };\n        });\n\n        // map flat record into hierachy\n        function mergeRecord(existingRow, rowObject, associations, nodePath) {\n            return _.each(\n                associations,\n                ({ sql, key, list, subAssocs }, anchor) => {\n                    if (sql) return;\n\n                    const currentPath = nodePath.concat();\n                    currentPath.push(anchor);\n\n                    const objKey = nestedKeyGetter(anchor);\n                    const subObj = rowObject[objKey];\n\n                    if (!subObj) {\n                        // associated entity not in result set, probably when custom projection is used\n                        return;\n                    }\n\n                    const subIndexes = existingRow.subIndexes[objKey];\n\n                    // joined an empty record\n                    const rowKeyValue = subObj[key];\n                    if (_.isNil(rowKeyValue)) {\n                        if (list && rowKeyValue == null) {\n                            if (existingRow.rowObject[objKey]) {\n                                existingRow.rowObject[objKey].push(subObj);\n                            } else {\n                                existingRow.rowObject[objKey] = [subObj];\n                            }\n                        }\n\n                        return;\n                    }\n\n                    const existingSubRow = subIndexes && subIndexes[rowKeyValue];\n                    if (existingSubRow) {\n                        if (subAssocs) {\n                            return mergeRecord(\n                                existingSubRow,\n                                subObj,\n                                subAssocs,\n                                currentPath\n                            );\n                        }\n                    } else {\n                        if (!list) {\n                            throw new ApplicationError(\n                                `The structure of association \"${currentPath.join(\n                                    '.'\n                                )}\" with [key=${key}] of entity \"${\n                                    self.meta.name\n                                }\" should be a list.`,\n                                { existingRow, rowObject }\n                            );\n                        }\n\n                        if (existingRow.rowObject[objKey]) {\n                            existingRow.rowObject[objKey].push(subObj);\n                        } else {\n                            existingRow.rowObject[objKey] = [subObj];\n                        }\n\n                        const subIndex = {\n                            rowObject: subObj,\n                        };\n\n                        if (subAssocs) {\n                            subIndex.subIndexes = buildSubIndexes(\n                                subObj,\n                                subAssocs\n                            );\n                        }\n\n                        if (!subIndexes) {\n                            throw new ApplicationError(\n                                `The subIndexes of association \"${currentPath.join(\n                                    '.'\n                                )}\" with [key=${key}] of entity \"${\n                                    self.meta.name\n                                }\" does not exist.`,\n                                { existingRow, rowObject }\n                            );\n                        }\n\n                        subIndexes[rowKeyValue] = subIndex;\n                    }\n                }\n            );\n        }\n\n        // build sub index for list member\n        function buildSubIndexes(rowObject, associations) {\n            const indexes = {};\n\n            _.each(associations, ({ sql, key, list, subAssocs }, anchor) => {\n                if (sql) {\n                    return;\n                }\n\n                const objKey = nestedKeyGetter(anchor);\n                let subObject = rowObject[objKey];\n                const subIndex = {\n                    rowObject: subObject,\n                };\n\n                if (list) {\n                    if (!subObject) {\n                        // associated entity not in result set, probably when custom projection is used\n                        rowObject[objKey] = [];\n                        return;\n                    }\n\n                    rowObject[objKey] = [subObject];\n\n                    // many to *\n                    if (_.isNil(subObject[key])) {\n                        // when custom projection is used\n                        subObject = null;\n                    }\n                }\n\n                if (subObject) {\n                    if (subAssocs) {\n                        subIndex.subIndexes = buildSubIndexes(\n                            subObject,\n                            subAssocs\n                        );\n                    }\n\n                    indexes[objKey] = subObject[key]\n                        ? {\n                              [subObject[key]]: subIndex,\n                          }\n                        : {};\n                }\n            });\n\n            return indexes;\n        }\n\n        const arrayOfObjs = [];\n\n        // build the result object skeleton\n        const tableTemplate = columns.reduce((result, col) => {\n            if (col.table !== 'A') {\n                const bucket = result[col.table];\n                if (bucket) {\n                    bucket[col.name] = null;\n                } else {\n                    result[col.table] = { [col.name]: null };\n                }\n            }\n\n            return result;\n        }, {});\n\n        // process each row\n        rows.forEach((row) => {\n            const tableCache = {}; // from alias to child prop of rowObject\n\n            // hash-style data row\n            const rowObject = row.reduce((result, value, colIdx) => {\n                const col = columns[colIdx];\n\n                if (col.table === 'A') {\n                    result[col.name] = value;\n                } else if (value != null) {\n                    // avoid a object with all null value exists\n                    const bucket = tableCache[col.table];\n                    if (bucket) {\n                        // already nested inside\n                        bucket[col.name] = value;\n                    } else {\n                        tableCache[col.table] = {\n                            ...tableTemplate[col.table],\n                            [col.name]: value,\n                        };\n                    }\n                }\n\n                return result;\n            }, {});\n\n            _.forOwn(tableCache, (obj, table) => {\n                const nodePath = aliasMap[table];\n                _.set(rowObject, nodePath, obj);\n            });\n\n            const rowKey = rowObject[self.meta.keyField];\n            const existingRow = mainIndex[rowKey];\n            if (existingRow) {\n                return mergeRecord(existingRow, rowObject, hierarchy, []);\n            }\n\n            arrayOfObjs.push(rowObject);\n            mainIndex[rowKey] = {\n                rowObject,\n                subIndexes: buildSubIndexes(rowObject, hierarchy),\n            };\n        });\n\n        return arrayOfObjs;\n    }\n\n    /**\n     * Pre-process assoicated db operation\n     * @param {*} data\n     * @param {*} isNew - New record flag, true for creating, false for updating\n     * @returns {Array} [raw, assocs, refs];\n     */\n    static _extractAssociations(data, isNew) {\n        const raw = {};\n            const assocs = {};\n            const refs = {};\n        const meta = this._meta.associations;\n\n        _.forOwn(data, (v, k) => {\n            if (k[0] === ':') {\n                // cascade update\n                const anchor = k.substr(1);\n                const assocMeta = meta[anchor];\n                if (!assocMeta) {\n                    throw new ValidationError(\n                        `Unknown association \"${anchor}\" of entity \"${this._meta.name}\".`\n                    );\n                }\n\n                if (\n                    isNew &&\n                    (assocMeta.type === 'refersTo' ||\n                        assocMeta.type === 'belongsTo') &&\n                    anchor in data\n                ) {\n                    throw new ValidationError(\n                        `Association data \":${anchor}\" of entity \"${this._meta.name}\" conflicts with input value of field \"${anchor}\".`\n                    );\n                }\n\n                assocs[anchor] = v;\n            } else if (k[0] === '@') {\n                // update by reference\n                const anchor = k.substr(1);\n                const assocMeta = meta[anchor];\n                if (!assocMeta) {\n                    throw new ValidationError(\n                        `Unknown association \"${anchor}\" of entity \"${this._meta.name}\".`\n                    );\n                }\n\n                if (\n                    assocMeta.type !== 'refersTo' &&\n                    assocMeta.type !== 'belongsTo'\n                ) {\n                    throw new ValidationError(\n                        `Association type \"${assocMeta.type}\" cannot be used for update by reference.`,\n                        {\n                            entity: this._meta.name,\n                            data,\n                        }\n                    );\n                }\n\n                if (isNew && anchor in data) {\n                    throw new ValidationError(\n                        `Association reference \"@${anchor}\" of entity \"${this._meta.name}\" conflicts with input value of field \"${anchor}\".`\n                    );\n                }\n\n                const assocAnchor = ':' + anchor;\n                if (assocAnchor in data) {\n                    throw new ValidationError(\n                        `Association reference \"@${anchor}\" of entity \"${this._meta.name}\" conflicts with association data \"${assocAnchor}\".`\n                    );\n                }\n\n                if (v == null) {\n                    raw[anchor] = null;\n                } else {\n                    refs[anchor] = v;\n                }\n            } else {\n                raw[k] = v;\n            }\n        });\n\n        return [raw, assocs, refs];\n    }\n\n    static async _populateReferences_(context, references) {\n        const meta = this._meta.associations;\n\n        await eachAsync_(references, async (refQuery, anchor) => {\n            const assocMeta = meta[anchor];\n            const ReferencedEntity = this.db.model(assocMeta.entity);\n\n            const created = await ReferencedEntity.findOne_(\n                refQuery,\n                context.connOptions\n            );\n\n            if (!created) {\n                throw new ReferencedNotExistError(\n                    `Referenced entity \"${\n                        ReferencedEntity.meta.name\n                    }\" with ${JSON.stringify(refQuery)} not exist.`\n                );\n            }\n\n            context.raw[anchor] = created[assocMeta.field];\n        });\n    }\n\n    static async _createAssocs_(context, assocs, beforeEntityCreate) {\n        const meta = this._meta.associations;\n        let keyValue;\n\n        if (!beforeEntityCreate) {\n            keyValue = context.return[this._meta.keyField];\n\n            if (_.isNil(keyValue)) {\n                if (context.result.affectedRows === 0) {\n                    // insert ignored\n\n                    const query = this.getUniqueKeyValuePairsFrom(\n                        context.return\n                    );\n                    context.return = await this.findOne_(\n                        { $query: query },\n                        context.connOptions\n                    );\n                    if (!context.return) {\n                        throw new ApplicationError(\n                            'The parent entity is duplicated on unique keys different from the pair of keys used to query',\n                            {\n                                query,\n                                data: context.return,\n                                associations: assocs,\n                            }\n                        );\n                    }\n                }\n\n                keyValue = context.return[this._meta.keyField];\n\n                if (_.isNil(keyValue)) {\n                    throw new ApplicationError(\n                        'Missing required primary key field value. Entity: ' +\n                            this._meta.name,\n                        {\n                            data: context.return,\n                            associations: assocs,\n                        }\n                    );\n                }\n            }\n        }\n\n        const pendingAssocs = {};\n        const finished = {};\n\n        // todo: double check to ensure including all required options\n        const passOnOptions = _.pick(context.options, [\n            '$skipModifiers',\n            '$migration',\n            '$variables',\n            '$upsert',\n            '$dryRun'\n        ]);\n\n        await eachAsync_(assocs, async (data, anchor) => {\n            const assocMeta = meta[anchor];\n\n            if (\n                beforeEntityCreate &&\n                assocMeta.type !== 'refersTo' &&\n                assocMeta.type !== 'belongsTo'\n            ) {\n                pendingAssocs[anchor] = data;\n                return;\n            }\n\n            const assocModel = this.db.model(assocMeta.entity);\n\n            if (assocMeta.list) {\n                data = _.castArray(data);\n\n                if (!assocMeta.field) {\n                    throw new ApplicationError(\n                        `Missing \"field\" property in the metadata of association \"${anchor}\" of entity \"${this._meta.name}\".`\n                    );\n                }\n\n                return eachAsync_(data, (item) =>\n                    assocModel.create_(\n                        { ...item, [assocMeta.field]: keyValue },\n                        passOnOptions,\n                        context.connOptions\n                    )\n                );\n            } else if (!_.isPlainObject(data)) {\n                if (Array.isArray(data)) {\n                    throw new ApplicationError(\n                        `Invalid type of associated entity (${assocMeta.entity}) data triggered from \"${this._meta.name}\" entity. Singular value expected (${anchor}), but an array is given instead.`\n                    );\n                }\n\n                if (!assocMeta.assoc) {\n                    throw new ApplicationError(\n                        `The associated field of relation \"${anchor}\" does not exist in the entity meta data.`\n                    );\n                }\n\n                data = { [assocMeta.assoc]: data };\n            }\n\n            if (!beforeEntityCreate && assocMeta.field) {\n                // hasMany or hasOne\n                data = { ...data, [assocMeta.field]: keyValue };\n            }\n\n            passOnOptions.$retrieveDbResult = true;\n            let created = await assocModel.create_(\n                data,\n                passOnOptions,\n                context.connOptions\n            );\n\n            if (\n                passOnOptions.$result.affectedRows === 0 ||\n                (assocModel.hasAutoIncrement &&\n                    passOnOptions.$result.insertId === 0)\n            ) {\n                // insert ignored or upserted\n\n                const assocQuery = assocModel.getUniqueKeyValuePairsFrom(data);\n\n                created = await assocModel.findOne_(\n                    { $query: assocQuery },\n                    context.connOptions\n                );\n                if (!created) {\n                    throw new ApplicationError(\n                        'The assoicated entity is duplicated on unique keys different from the pair of keys used to query',\n                        {\n                            query: assocQuery,\n                            data,\n                        }\n                    );\n                }\n            }\n\n            finished[anchor] = beforeEntityCreate\n                ? created[assocMeta.field]\n                : created[assocMeta.key];\n        });\n\n        if (beforeEntityCreate) {\n            _.forOwn(finished, (refFieldValue, localField) => {\n                context.raw[localField] = refFieldValue;\n            });\n        }\n\n        return pendingAssocs;\n    }\n\n    static async _updateAssocs_(\n        context,\n        assocs,\n        beforeEntityUpdate,\n        forSingleRecord\n    ) {\n        const meta = this._meta.associations;\n\n        let currentKeyValue;\n\n        if (!beforeEntityUpdate) {\n            currentKeyValue = getValueFrom(\n                [context.options.$query, context.return],\n                this._meta.keyField\n            );\n            if (_.isNil(currentKeyValue)) {\n                // should have in updating\n                throw new ApplicationError(\n                    'Missing required primary key field value. Entity: ' +\n                        this._meta.name\n                );\n            }\n        }\n\n        const pendingAssocs = {};\n\n        // todo: double check to ensure including all required options\n        const passOnOptions = _.pick(context.options, [\n            '$skipModifiers',\n            '$migration',\n            '$variables',\n            '$upsert',\n        ]);\n\n        await eachAsync_(assocs, async (data, anchor) => {\n            const assocMeta = meta[anchor];\n\n            if (\n                beforeEntityUpdate &&\n                assocMeta.type !== 'refersTo' &&\n                assocMeta.type !== 'belongsTo'\n            ) {\n                pendingAssocs[anchor] = data;\n                return;\n            }\n\n            const assocModel = this.db.model(assocMeta.entity);\n\n            if (assocMeta.list) {\n                data = _.castArray(data);\n\n                if (!assocMeta.field) {\n                    throw new ApplicationError(\n                        `Missing \"field\" property in the metadata of association \"${anchor}\" of entity \"${this._meta.name}\".`\n                    );\n                }\n\n                const assocKeys = mapFilter(\n                    data,\n                    (record) => record[assocMeta.key] != null,\n                    (record) => record[assocMeta.key]\n                );\n                const assocRecordsToRemove = {\n                    [assocMeta.field]: currentKeyValue,\n                };\n                if (assocKeys.length > 0) {\n                    assocRecordsToRemove[assocMeta.key] = { $notIn: assocKeys };\n                }\n\n                await assocModel.deleteMany_(\n                    assocRecordsToRemove,\n                    context.connOptions\n                );\n\n                return eachAsync_(data, (item) =>\n                    item[assocMeta.key] != null\n                        ? assocModel.updateOne_(\n                              {\n                                  ..._.omit(item, [assocMeta.key]),\n                                  [assocMeta.field]: currentKeyValue,\n                              },\n                              {\n                                  $query: {\n                                      [assocMeta.key]: item[assocMeta.key],\n                                  },\n                                  ...passOnOptions,\n                              },\n                              context.connOptions\n                          )\n                        : assocModel.create_(\n                              { ...item, [assocMeta.field]: currentKeyValue },\n                              passOnOptions,\n                              context.connOptions\n                          )\n                );\n            } else if (!_.isPlainObject(data)) {\n                if (Array.isArray(data)) {\n                    throw new ApplicationError(\n                        `Invalid type of associated entity (${assocMeta.entity}) data triggered from \"${this._meta.name}\" entity. Singular value expected (${anchor}), but an array is given instead.`\n                    );\n                }\n\n                if (!assocMeta.assoc) {\n                    throw new ApplicationError(\n                        `The associated field of relation \"${anchor}\" does not exist in the entity meta data.`\n                    );\n                }\n\n                // connected by\n                data = { [assocMeta.assoc]: data };\n            }\n\n            if (beforeEntityUpdate) {\n                if (_.isEmpty(data)) return;\n\n                // refersTo or belongsTo\n                let destEntityId = getValueFrom(\n                    [context.existing, context.options.$query, context.raw],\n                    anchor\n                );\n\n                if (destEntityId == null) {\n                    if (_.isEmpty(context.existing)) {\n                        context.existing = await this.findOne_(\n                            context.options.$query,\n                            context.connOptions\n                        );\n                        if (!context.existing) {\n                            throw new ValidationError(\n                                `Specified \"${this._meta.name}\" not found.`,\n                                {\n                                    query: context.options.$query,\n                                }\n                            );\n                        }\n                        destEntityId = context.existing[anchor];\n                    }\n\n                    if (destEntityId == null) {\n                        if (!(anchor in context.existing)) {\n                            throw new ApplicationError(\n                                'Existing entity record does not contain the referenced entity id.',\n                                {\n                                    anchor,\n                                    data,\n                                    existing: context.existing,\n                                    query: context.options.$query,\n                                    raw: context.raw,\n                                }\n                            );\n                        }\n\n                        // to create the associated, existing is null\n\n                        passOnOptions.$retrieveDbResult = true;\n                        let created = await assocModel.create_(\n                            data,\n                            passOnOptions,\n                            context.connOptions\n                        );\n\n                        if (passOnOptions.$result.affectedRows === 0) {\n                            // insert ignored\n\n                            const assocQuery =\n                                assocModel.getUniqueKeyValuePairsFrom(data);\n                            created = await assocModel.findOne_(\n                                { $query: assocQuery },\n                                context.connOptions\n                            );\n                            if (!created) {\n                                throw new ApplicationError(\n                                    'The assoicated entity is duplicated on unique keys different from the pair of keys used to query',\n                                    {\n                                        query: assocQuery,\n                                        data,\n                                    }\n                                );\n                            }\n                        }\n\n                        context.raw[anchor] = created[assocMeta.field];\n                        return;\n                    }\n                }\n\n                if (destEntityId) {\n                    return assocModel.updateOne_(\n                        data,\n                        { [assocMeta.field]: destEntityId, ...passOnOptions },\n                        context.connOptions\n                    );\n                }\n\n                // nothing to do for null dest entity id\n                return;\n            }\n\n            await assocModel.deleteMany_(\n                { [assocMeta.field]: currentKeyValue },\n                context.connOptions\n            );\n\n            if (forSingleRecord) {\n                return assocModel.create_(\n                    { ...data, [assocMeta.field]: currentKeyValue },\n                    passOnOptions,\n                    context.connOptions\n                );\n            }\n\n            throw new Error(\n                'update associated data for multiple records not implemented'\n            );\n\n            // return assocModel.replaceOne_({ ...data, ...(assocMeta.field ? { [assocMeta.field]: keyValue } : {}) }, null, context.connOptions);\n        });\n\n        return pendingAssocs;\n    }\n}\n\nexport default RelationalEntityModel;\n"],"names":["defaultNestedKeyGetter","anchor","RelationalEntityModel","EntityModel","hasAutoIncrement","autoId","_meta","features","fields","field","autoIncrementId","_translateSymbolToken","name","db","connector","raw","Error","_serializeByTypeInfo","value","info","type","Types","DATETIME","serialize","Array","isArray","csv","ARRAY","toCsv","OBJECT","_doReplaceOne_","context","ensureTransaction_","entity","findOne_","$query","options","connOptions","ret","$retrieveExisting","rawOptions","$existing","keyField","valueOfKey","updateOne_","_","omit","$retrieveCreated","$retrieveUpdated","create_","$result","_internalBeforeCreate_","_fillResult","result","affectedRows","insertId","latest","upsert","return","_internalAfterCreate_","$retrieveDbResult","queryKey","getUniqueKeyValuePairsFrom","isEmpty","ApplicationError","retrieveOptions","isPlainObject","_internalBeforeUpdate_","_internalBeforeUpdateMany_","_internalAfterUpdate_","changedRows","retrieveUpdated","$retrieveActualUpdated","$retrieveNotUpdate","condition","$skipUniqueCheck","$relationships","$includeDeleted","$retrieveDeleted","_internalAfterUpdateMany_","findAll_","_internalBeforeDelete_","$physicalDeletion","existing","_internalBeforeDeleteMany_","_internalAfterDelete_","_internalAfterDeleteMany_","_prepareAssociations","findOptions","normalAssocs","customAssocs","partition","$association","assoc","associations","uniq","sort","concat","assocTable","counter","cache","forEach","_translateSchemaNameToDb","alias","joinType","output","key","on","dataset","buildQuery","model","_prepareQueries","$variables","_loadAssocIntoTable","lastPos","lastIndexOf","assocInfo","InvalidArgument","base","substr","last","baseNode","meta","subAssocs","currentDb","indexOf","schemaName","entityName","split","app","refDb","database","_mapRecordsToObjects","rows","columns","aliasMap","hierarchy","nestedKeyGetter","mapValues","chain","map","mainIndex","self","col","table","pos","mergeRecord","existingRow","rowObject","nodePath","each","sql","list","currentPath","push","objKey","subObj","subIndexes","rowKeyValue","isNil","existingSubRow","join","subIndex","buildSubIndexes","indexes","subObject","arrayOfObjs","tableTemplate","reduce","bucket","row","tableCache","colIdx","forOwn","obj","set","rowKey","_extractAssociations","data","isNew","assocs","refs","v","k","assocMeta","ValidationError","assocAnchor","_populateReferences_","references","eachAsync_","refQuery","ReferencedEntity","created","ReferencedNotExistError","JSON","stringify","_createAssocs_","beforeEntityCreate","keyValue","query","pendingAssocs","finished","passOnOptions","pick","assocModel","castArray","item","assocQuery","refFieldValue","localField","_updateAssocs_","beforeEntityUpdate","forSingleRecord","currentKeyValue","getValueFrom","assocKeys","mapFilter","record","assocRecordsToRemove","length","$notIn","deleteMany_","destEntityId"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}