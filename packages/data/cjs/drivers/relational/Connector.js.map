{"version":3,"sources":["../../../src/drivers/relational/Connector.js"],"sourcesContent":["import ntol from 'number-to-letter';\nimport { isPlainObject, isEmpty, snakeCase, isInteger, _ } from '@kimit/utils';\n\nimport Connector from '../../Connector';\nimport { isRawSql, extractRawSql } from '../../utils/Rules';\n\nclass RelationalConnector extends Connector {\n    /**\n     * Create a new instance of the connector.\n     * @param {App} app\n     * @param {string} connectionString\n     * @param {object} options\n     * @property {boolean} [options.logStatement] - Flag to log executed SQL statement.\n     * @property {boolean} [options.logConnection] - Flag to log connect and disconnect.\n     * @property {boolean} [options.verboseAlias] - Flag to use verbose alias.\n     */\n    constructor(app, driver, connectionString, options) {\n        super(app, driver, connectionString, options);\n\n        this.relational = true;\n    }\n\n    /**\n     * Run aggregate pipeline\n     * @param {string} model\n     * @param {array} pipeline\n     * @param {object} [options]\n     * @returns {*}\n     */\n     async aggregate_(model, pipeline, options, connection) {\n        if (!Array.isArray(pipeline) || pipeline.length === 0) {\n            throw new InvalidArgument('\"pipeline\" should be an unempty array.');\n        }\n\n        const [startingQuery, ..._pipeline] = pipeline;\n\n        let query = this.buildQuery(model, startingQuery);\n\n        _pipeline.forEach((stage, i) => {\n            let _params = query.params;\n\n            query = this.buildQuery(\n                {\n                    sql: query.sql,\n                    alias: `_STAGE_${i}`,\n                },\n                stage\n            );\n\n            query.params = _params.concat(query.params);\n        });\n\n        return this._executeQuery_(query, null, options, connection);\n    }\n\n    /**\n     * \n     * @param {*} query \n     * @param {*} queryOptions \n     * @param {*} options \n     * @param {*} connection \n     * @returns \n     */\n    async _executeQuery_(query, queryOptions, options, connection) {\n        let result, totalCount;\n\n        if (query.countSql) {\n            const res = await this.execute_(query.countSql, query.countParams, options, connection);\n            totalCount = res.rows[0].count;\n        }\n\n        if (query.hasJoining) {\n            options = { ...options, rowsAsArray: true };\n            result = await this.execute_(query.sql, query.params, options, connection);\n\n            const reverseAliasMap = _.reduce(\n                query.aliasMap,\n                (result, alias, nodePath) => {\n                    result[alias] = nodePath\n                        .split('.')\n                        .slice(\n                            1\n                        ) /* .map(n => ':' + n) changed to be padding by orm and can be customized with other key getter */;\n                    return result;\n                },\n                {}\n            );\n\n            if (query.countSql) {\n                return { ...result, reverseAliasMap, totalCount }; \n            }\n\n            return  { ...result, reverseAliasMap };\n\n        } else if (queryOptions?.$skipOrm) {\n            options = { ...options, rowsAsArray: true };\n        }\n\n        result = await this.execute_(query.sql, query.params, options);\n\n        if (query.countSql) {\n            return { ...result, totalCount };\n        }\n\n        return result;\n    }\n\n    /**\n     * Build CTE header and return the select from target and CTE header\n     * @param {string} model\n     * @returns {object} { fromTable, withTables, model }\n     */\n    _buildCTEHeader(model) {\n        let fromTable = this.escapeId(model);\n        let withTables = '';\n\n        // CTE, used by aggregation\n        if (typeof model === 'object') {\n            const { sql: subSql, alias } = model;\n\n            model = alias;\n            fromTable = alias;\n            withTables = `WITH ${alias} AS (${subSql}) `;\n        }\n\n        return { fromTable, withTables, model };\n    }\n\n    /**\n     * Build sql statement\n     * @param {string|object} model - Model name or CTE object\n     * @param {*} condition\n     * @property {object} $relation\n     * @property {object} $select\n     * @property {object} $where\n     * @property {object} $groupBy\n     * @property {object} $orderBy\n     * @property {number} $offset - Offset\n     * @property {number} $limit - Limit\n     * @property {boolean|string} $totalCount - Whether to count the total number of records\n     * @property {string} $key\n     * @returns {object} { sql, params, countSql, countParams, hasJoining, aliasMap }\n     */\n    buildQuery(model, { $relation, $select, $where, $groupBy, $orderBy, $offset, $limit, $totalCount, $key }) {\n        const hasTotalCount = $totalCount;\n        let needDistinctForLimit = ($limit != null && $limit > 0) || ($offset != null && $offset > 0);\n\n        const { fromTable, withTables, model: _model } = this._buildCTEHeader(model);\n        model = _model; // replaced with CTE alias\n\n        const aliasMap = { [model]: 'A' };\n\n        let joinings;\n        let hasJoining = false; // false or primary model name\n        const joiningParams = [];\n\n        // build alias map first\n        // cache params\n        if ($relation) {\n            joinings = this._joinAssociations($relation, model, aliasMap, 1, joiningParams);\n            hasJoining = true;\n        }\n\n        // !!!limit or offset with mutiple joining requires group by distinct field to calculate the correct number of records\n        needDistinctForLimit &&= hasJoining && isEmpty($groupBy);\n\n        // count does not require selectParams\n        const countParams = hasTotalCount ? joiningParams.concat() : null;\n        const mainEntity = hasJoining ? model : null;\n\n        // Build select columns\n        const selectParams = [];\n        const selectColomns = $select ? this._buildColumns($select, selectParams, mainEntity, aliasMap) : '*';\n\n        // Build from clause\n        let fromClause = ' FROM ' + fromTable;\n        let fromAndJoin = fromClause;\n        if (joinings) {\n            fromAndJoin += ' A ' + joinings.join(' ');\n        }\n\n        // Build where clause\n        let whereClause = '';\n        const whereParams = [];\n\n        if ($where) {\n            whereClause = this._joinCondition($where, whereParams, null, mainEntity, aliasMap);\n\n            if (whereClause) {\n                whereClause = ' WHERE ' + whereClause;\n                if (countParams) {\n                    whereParams.forEach((p) => {\n                        countParams.push(p);\n                    });\n                }\n            }\n        }\n\n        // Build group by clause\n        let groupByClause = '';\n        const groupByParams = [];\n\n        if ($groupBy) {\n            groupByClause += ' ' + this._buildGroupBy($groupBy, groupByParams, mainEntity, aliasMap);\n            if (countParams) {\n                groupByParams.forEach((p) => {\n                    countParams.push(p);\n                });\n            }\n        }\n\n        // Build order by clause\n        let orderByClause = '';\n        if ($orderBy) {\n            orderByClause += ' ' + this._buildOrderBy($orderBy, mainEntity, aliasMap);\n        }\n\n        // Build limit & offset clause\n        const limitOffetParams = [];\n        let limitOffset = this._buildLimitOffset($limit, $offset, limitOffetParams);\n\n        const result = { hasJoining, aliasMap };\n\n        // The field used as the key of counting or pagination\n        let distinctFieldRaw;\n        let distinctField;\n\n        if (hasTotalCount || needDistinctForLimit) {\n            distinctFieldRaw = typeof $totalCount === 'string' ? $totalCount : $key;\n            distinctField = this._escapeIdWithAlias(\n                distinctFieldRaw,\n                mainEntity,\n                aliasMap\n            );\n        }\n\n        if (hasTotalCount) {\n            const countSubject = 'DISTINCT(' + distinctField + ')';\n\n            result.countSql =\n                withTables + `SELECT COUNT(${countSubject}) AS count` + fromAndJoin + whereClause + groupByClause;\n            result.countParams = countParams;\n        }\n\n        if (needDistinctForLimit) {\n            const distinctFieldWithAlias = `${distinctField} AS key_`;\n            const keysSql = orderByClause\n                ? `WITH records_ AS (SELECT ${distinctFieldWithAlias}, ROW_NUMBER() OVER(${orderByClause}) AS row_${fromAndJoin}${whereClause}${groupByClause}) SELECT key_ FROM records_ GROUP BY key_ ORDER BY row_${limitOffset}`\n                : `WITH records_ AS (SELECT ${distinctFieldWithAlias}${fromAndJoin}${whereClause}${groupByClause}) SELECT key_ FROM records_ GROUP BY key_${limitOffset}`;\n\n            const keySqlAliasIndex = Object.keys(aliasMap).length;\n            const keySqlAnchor = ntol(keySqlAliasIndex);\n\n            this._joinAssociation(\n                {\n                    sql: keysSql,\n                    params: joiningParams.concat(whereParams, groupByParams, limitOffetParams),\n                    joinType: 'INNER JOIN',\n                    on: {\n                        [distinctFieldRaw]: {\n                            $xr: 'Column',\n                            name: `${keySqlAnchor}.key_`,\n                        },\n                    },\n                    output: true,\n                },\n                keySqlAnchor,\n                joinings,\n                model,\n                aliasMap,\n                keySqlAliasIndex,\n                joiningParams\n            );\n\n            fromAndJoin = fromClause + ' A ' + joinings.join(' ');\n\n            result.sql =\n                withTables + 'SELECT ' + selectColomns + fromAndJoin + whereClause + groupByClause + orderByClause;\n            result.params = selectParams.concat(joiningParams, whereParams, groupByParams);\n        } else {\n            result.sql =\n                withTables +\n                'SELECT ' +\n                selectColomns +\n                fromAndJoin +\n                whereClause +\n                groupByClause +\n                orderByClause +\n                limitOffset;\n\n            result.params = selectParams.concat(joiningParams, whereParams, groupByParams, limitOffetParams);\n        }\n\n        return result;\n    }\n\n    /**\n     * Generate an alias\n     * @param {*} index \n     * @param {*} anchor \n     * @returns {string}\n     */\n    _generateAlias(index, anchor) {\n        if (this.options.verboseAlias) {\n            return `${snakeCase(anchor).toUpperCase()}${index}`;\n        }\n\n        return ntol(index);\n    }\n\n    /**\n     * Extract associations into joining clauses.\n     *  [{\n     *      entity: <remote entity>\n     *      joinType: 'LEFT JOIN|INNER JOIN|FULL OUTER JOIN'\n     *      on: join condition\n     *      anchor: 'local property to place the remote entity'\n     *      localField: <local field to join>\n     *      remoteField: <remote field to join>\n     *      $relation: { ... }\n     *  }]\n     *\n     * @param {*} associations\n     * @param {*} parentAliasKey\n     * @param {*} aliasMap\n     * @param {*} params\n     * @param {*} startId\n     * @param {*} params\n     * @returns {object}\n     */\n    _joinAssociations(associations, parentAliasKey, aliasMap, startId, params) {\n        let joinings = [];\n\n        _.each(associations, (assocInfo, anchor) => {\n            startId = this._joinAssociation(assocInfo, anchor, joinings, parentAliasKey, aliasMap, startId, params);\n        });\n\n        return joinings;\n    }\n\n    /**\n     * Convert an association into joining clause\n     * @param {object} assocInfo\n     * @property {string} [assocInfo.joinType=\"LEFT JOIN\"] - Join type\n     * @property {object} [assocInfo.on] - Join condition\n     * @property {string} [assocInfo.alias] - Alias of the association\n     * @property {string} [assocInfo.sql] - Explicit SQL statement\n     * @property {array} [assocInfo.params] - Parameters for the SQL statement\n     * @property {string} [assocInfo.entity] - The entity to join\n     * @property {object} [assocInfo.$relation] - Sub-associations\n     * @property {boolean} [assocInfo.output] - Whether to output the association\n     * @param {string} anchor - The anchor of the association, usually the property name (prefixed by \":\") in the parent entity\n     * @param {array} joinings - The array to store the joining clauses\n     * @param {string} parentAliasKey - The parent alias key\n     * @param {object} aliasMap - The alias map\n     * @param {integer} startId - The starting index for alias generation\n     * @param {array} params - The parameters array\n     * @returns\n     */\n    _joinAssociation(assocInfo, anchor, joinings, parentAliasKey, aliasMap, startId, params) {\n        const alias = assocInfo.alias || this._generateAlias(startId++, anchor);\n        let { joinType, on } = assocInfo;\n\n        joinType || (joinType = 'LEFT JOIN');\n\n        if (assocInfo.sql) {\n            if (assocInfo.output) {\n                aliasMap[parentAliasKey + '.' + alias] = alias;\n            }\n\n            assocInfo.params.forEach((p) => params.push(p));\n            joinings.push(\n                `${joinType} (${assocInfo.sql}) ${alias} ON ${this._joinCondition(\n                    on,\n                    params,\n                    null,\n                    parentAliasKey,\n                    aliasMap\n                )}`\n            );\n\n            return startId;\n        }\n\n        const { entity, $relation } = assocInfo;\n        const aliasKey = parentAliasKey + '.' + anchor;\n        aliasMap[aliasKey] = alias;\n\n        if ($relation) {\n            const _params = [];\n            const subJoinings = this._joinAssociations($relation, aliasKey, aliasMap, startId, _params);\n            startId += subJoinings.length;\n\n            joinings.push(\n                `${joinType} ${this.escapeId(entity)} ${alias} ON ${this._joinCondition(\n                    on,\n                    params,\n                    null,\n                    parentAliasKey,\n                    aliasMap\n                )}`\n            );\n\n            subJoinings.forEach((sj) => joinings.push(sj));\n            _params.forEach((p) => params.push(p));\n        } else {\n            joinings.push(\n                `${joinType} ${this.escapeId(entity)} ${alias} ON ${this._joinCondition(\n                    on,\n                    params,\n                    null,\n                    parentAliasKey,\n                    aliasMap\n                )}`\n            );\n        }\n\n        return startId;\n    }\n\n    /**\n     * SQL condition representation\n     *   Rules:\n     *     default:\n     *        array: OR\n     *        kv-pair: AND\n     *     $all:\n     *        array: AND\n     *     $any:\n     *        kv-pair: OR\n     *     $not:\n     *        array: not ( or )\n     *        kv-pair: not ( and )\n     * @param {object|array|string} condition - The condition object\n     * @param {array} params - The parameters array\n     * @param {string} joinOperator - 'AND' or 'OR'\n     * @param {string} mainEntity - The entity name that has joining\n     * @param {object} aliasMap - The alias map, dot separated key -> alias\n     */\n    _joinCondition(condition, params, joinOperator, mainEntity, aliasMap) {\n        if (Array.isArray(condition)) {\n            if (!joinOperator) {\n                joinOperator = 'OR';\n            }\n            return condition\n                .map((c) => '(' + this._joinCondition(c, params, null, mainEntity, aliasMap) + ')')\n                .join(` ${joinOperator} `);\n        }\n\n        if (isPlainObject(condition)) {\n            if (condition.$xr) {\n                return this._packValue(condition, params, mainEntity, aliasMap);\n            }\n\n            if (!joinOperator) {\n                joinOperator = 'AND';\n            }\n\n            return _.map(condition, (value, key) => {\n                if (key === '$all' || key === '$and' || key.startsWith('$and_')) {\n                    // for avoiding duplicate, $and_1, $and_2 is valid\n                    if (!Array.isArray(value) && !isPlainObject(value)) {\n                        throw new Error('\"$and\" operator value should be an array or plain object.');\n                    }\n\n                    return '(' + this._joinCondition(value, params, 'AND', mainEntity, aliasMap) + ')';\n                }\n\n                if (key === '$any' || key === '$or' || key.startsWith('$or_')) {\n                    // for avoiding dupliate, $or_1, $or_2 is valid\n                    if (!Array.isArray(value) && !isPlainObject(value)) {\n                        throw new Error('\"$or\" operator value should be an array or plain object.');\n                    }\n\n                    return '(' + this._joinCondition(value, params, 'OR', mainEntity, aliasMap) + ')';\n                }\n\n                if (key === '$not') {\n                    if (Array.isArray(value)) {\n                        if (value.length === 0) {\n                            throw new Error('\"$not\" operator value should be non-empty.');\n                        }\n\n                        return 'NOT (' + this._joinCondition(value, params, null, mainEntity, aliasMap) + ')';\n                    }\n\n                    if (isPlainObject(value)) {\n                        if (isEmpty(value)) {\n                            throw new Error('\"$not\" operator value should be non-empty.');\n                        }\n\n                        return 'NOT (' + this._joinCondition(value, params, null, mainEntity, aliasMap) + ')';\n                    }\n\n                    if (typeof value !== 'string') {\n                        throw new Error('Unsupported condition!');\n                    }\n\n                    return 'NOT (' + condition + ')';\n                }\n\n                if ((key === '$expr' || key.startsWith('$expr_')) && value.$xr && value.$xr === 'BinExpr') {\n                    const left = this._packValue(value.left, params, mainEntity, aliasMap);\n                    const right = this._packValue(value.right, params, mainEntity, aliasMap);\n                    return left + ` ${value.op} ` + right;\n                }\n\n                return this._wrapCondition(key, value, params, mainEntity, aliasMap);\n            }).join(` ${joinOperator} `);\n        }\n\n        if (typeof condition !== 'string') {\n            throw new Error('Unsupported condition!\\n Value: ' + JSON.stringify(condition));\n        }\n\n        return condition;\n    }\n\n    /**\n     * Build limit and offset clause\n     * @param {*} $limit\n     * @param {*} $offset\n     * @param {*} params\n     * @returns {string} '' or ' LIMIT X OFFSET Y'\n     */\n    _buildLimitOffset($limit, $offset, params) {\n        let sql = '';\n\n        if (isInteger($limit) && $limit > 0) {\n            if (isInteger($offset) && $offset > 0) {\n                params.push($offset);\n                sql = ` OFFSET ${this.specParamToken(params.length)} LIMIT ${this.specParamToken(params.length+1)}`;                \n                params.push($limit);\n            } else {\n                params.push($limit);\n                sql = ` LIMIT ${this.specParamToken(params.length)}`;                \n            }\n        } else if (isInteger($offset) && $offset > 0) {\n            params.push($offset);\n            sql = ` OFFSET ${this.specParamToken(params.length)}`;            \n        }\n\n        return sql;\n    }\n\n    /**\n     * Convert the dot separated field name to alias padded and escaped field name\n     * @param {string} fieldName - The dot separate field name or starting with \"::\" for skipping alias padding\n     * @param {string} mainEntity - Only called when mainEntity != null\n     * @param {*} aliasMap\n     * @returns {string}\n     */\n    _replaceFieldNameWithAlias(fieldName, mainEntity, aliasMap) {\n        if (fieldName.startsWith('::')) {\n            // ::fieldName for skipping alias padding\n            return this.escapeId(fieldName.substring(2));\n        }\n\n        const parts = fieldName.split('.');\n        if (parts.length > 1) {\n            const actualFieldName = parts.pop();\n\n            const aliasKey = mainEntity + '.' + parts.join('.');\n            const alias = aliasMap[aliasKey];\n            if (!alias) {\n                throw new InvalidArgument(`Column reference \"${fieldName}\" not found in populated associations.`, {\n                    entity: mainEntity,\n                    alias: aliasKey,\n                    aliasMap,\n                });\n            }\n\n            return alias + '.' + (actualFieldName === '*' ? '*' : this.escapeId(actualFieldName));\n        }\n\n        if (aliasMap[fieldName] === fieldName) {\n            return this.escapeId(fieldName);\n        }\n\n        return aliasMap[mainEntity] + '.' + (fieldName === '*' ? '*' : this.escapeId(fieldName));\n    }\n\n    /**\n     * Escape the field name with alias, skip if the field name is \"*\"\n     * @param {string} fieldName\n     * @param {string} mainEntity\n     * @param {object} aliasMap\n     * @returns {string}\n     */\n    _escapeIdWithAlias(fieldName, mainEntity, aliasMap) {\n        if (mainEntity) {\n            return this._replaceFieldNameWithAlias(fieldName, mainEntity, aliasMap);\n        }\n\n        return fieldName === '*' ? fieldName : this.escapeId(fieldName);\n    }\n\n    /**\n     * Pack an array of values into params and return the parameterized string with placeholders\n     * @param {*} array\n     * @param {*} params\n     * @param {*} mainEntity\n     * @param {*} aliasMap\n     * @returns {string}\n     */\n    _packArray(array, params, mainEntity, aliasMap) {\n        return array.map((value) => this._packValue(value, params, mainEntity, aliasMap)).join(',');\n    }\n\n    /**\n     * Pack a value into params and return the parameter placeholder\n     * @param {*} value\n     * @param {*} params\n     * @param {*} mainEntity\n     * @param {*} aliasMap\n     * @returns\n     */\n    _packValue(value, params, mainEntity, aliasMap) {\n        if (isPlainObject(value)) {\n            if (value.$xr) {\n                switch (value.$xr) {\n                    case 'Column':\n                        return this._escapeIdWithAlias(value.name, mainEntity, aliasMap);\n\n                    case 'Function':\n                        return (\n                            value.name +\n                            '(' +\n                            (value.args ? this._packArray(value.args, params, mainEntity, aliasMap) : '') +\n                            ')'\n                        );\n\n                    case 'Raw':\n                        return value.value;\n\n                    case 'Query':\n                        return this._joinCondition(value.query, params, null, mainEntity, aliasMap);\n\n                    case 'BinExpr': {\n                        const left = this._packValue(value.left, params, mainEntity, aliasMap);\n                        const right = this._packValue(value.right, params, mainEntity, aliasMap);\n                        return left + ` ${value.op} ` + right;\n                    }\n\n                    default:\n                        throw new Error(`Unknown xeml runtime type: ${value.$xr}`);\n                }\n            }\n\n            value = JSON.stringify(value);\n        }\n\n        params.push(value);\n        return this.specParamToken(params.length);\n    }\n\n    /**\n     * Wrap a condition clause\n     *\n     * Value can be a literal or a plain condition object.\n     *   1. fieldName, <literal>\n     *   2. fieldName, { normal object }\n     *\n     * @param {string} fieldName - The field name in a condition object.\n     * @param {*} value\n     * @param {array} params - The parameters array\n     * @param {string} mainEntity - The entity name that has joining\n     * @param {object} aliasMap - The alias map, dot separated key -> alias\n     * @param {boolean} [inject=false] - Whether to inject the value directly\n     */\n    _wrapCondition(fieldName, value, params, mainEntity, aliasMap, inject) {\n        if (value == null) {\n            return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' IS NULL';\n        }\n\n        if (Array.isArray(value)) {\n            return this._wrapCondition(fieldName, { $in: value }, params, mainEntity, aliasMap, inject);\n        }\n\n        if (isPlainObject(value)) {\n            if (value.$xr) {\n                return (\n                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +\n                    ' = ' +\n                    this._packValue(value, params, mainEntity, aliasMap)\n                );\n            }\n\n            const hasOperator = _.find(Object.keys(value), (k) => k && k[0] === '$');\n\n            if (hasOperator) {\n                return _.map(value, (v, k) => {\n                    if (k && k[0] === '$') {\n                        // operator\n                        switch (k) {\n                            case '$exist':\n                            case '$exists':\n                                return (\n                                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +\n                                    (v ? ' IS NOT NULL' : 'IS NULL')\n                                );\n\n                            case '$eq':\n                            case '$equal':\n                                return this._wrapCondition(fieldName, v, params, mainEntity, aliasMap, inject);\n\n                            case '$ne':\n                            case '$neq':\n                            case '$notEqual':\n                                if (v == null) {\n                                    return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' IS NOT NULL';\n                                }\n\n                                v = this.typeCast(v);\n\n                                if (inject) {\n                                    return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' <> ' + v;\n                                }\n\n                                return (\n                                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +\n                                    ` <> ${this._packValue(v, params, mainEntity, aliasMap)}`\n                                );\n\n                            case '$>':\n                            case '$gt':\n                            case '$greaterThan':\n                                v = this.typeCast(v);\n\n                                if (inject) {\n                                    return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' > ' + v;\n                                }\n\n                                return (\n                                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +\n                                    ` > ${this._packValue(v, params, mainEntity, aliasMap)}`\n                                );\n\n                            case '$>=':\n                            case '$gte':\n                            case '$greaterThanOrEqual':\n                                v = this.typeCast(v);\n\n                                if (inject) {\n                                    return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' >= ' + v;\n                                }\n\n                                return (\n                                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +\n                                    ` >= ${this._packValue(v, params, mainEntity, aliasMap)}`\n                                );\n\n                            case '$<':\n                            case '$lt':\n                            case '$lessThan':\n                                v = this.typeCast(v);\n\n                                if (inject) {\n                                    return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' < ' + v;\n                                }\n\n                                return (\n                                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +\n                                    ` < ${this._packValue(v, params, mainEntity, aliasMap)}`\n                                );\n\n                            case '$<=':\n                            case '$lte':\n                            case '$lessThanOrEqual':\n                                v = this.typeCast(v);\n\n                                if (inject) {\n                                    return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' <= ' + v;\n                                }\n\n                                return (\n                                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +\n                                    ` <= ${this._packValue(v, params, mainEntity, aliasMap)}`\n                                );\n\n                            case '$in':\n                                if (isPlainObject(v) && v.$xr === 'DataSet') {\n                                    const sqlInfo = this.buildQuery(v.model, v.query);\n                                    sqlInfo.params && sqlInfo.params.forEach((p) => params.push(p));\n\n                                    return (\n                                        this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +\n                                        ` IN (${sqlInfo.sql})`\n                                    );\n                                } else {\n                                    if (!Array.isArray(v)) {\n                                        throw new Error(\n                                            'The value should be a dataset or an array when using \"$in\" operator.'\n                                        );\n                                    }\n\n                                    if (inject) {\n                                        return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ` IN (${v})`;\n                                    }\n\n                                    params.push(v);\n                                    return (\n                                        this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +\n                                        this.specInClause(params.length)\n                                    );\n                                }\n\n                            case '$nin':\n                            case '$notIn':\n                                if (isPlainObject(v) && v.$xr === 'DataSet') {\n                                    const sqlInfo = this.buildQuery(v.model, v.query);\n                                    sqlInfo.params && sqlInfo.params.forEach((p) => params.push(p));\n\n                                    return (\n                                        this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +\n                                        ` NOT IN (${sqlInfo.sql})`\n                                    );\n                                } else {\n                                    if (!Array.isArray(v)) {\n                                        throw new Error('The value should be an array when using \"$in\" operator.');\n                                    }\n\n                                    if (inject) {\n                                        return (\n                                            this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ` NOT IN (${v})`\n                                        );\n                                    }\n\n                                    params.push(v);\n                                    return (\n                                        this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +\n                                        this.specNotInClause(params.length)\n                                    );\n                                }\n\n                            case '$startWith':\n                            case '$startsWith':\n                                if (typeof v !== 'string') {\n                                    throw new Error('The value should be a string when using \"$startWith\" operator.');\n                                }\n\n                                params.push(`${v}%`);\n                                return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' LIKE ?';\n\n                            case '$endWith':\n                            case '$endsWith':\n                                if (typeof v !== 'string') {\n                                    throw new Error('The value should be a string when using \"$endWith\" operator.');\n                                }\n\n                                params.push(`%${v}`);\n                                return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' LIKE ?';\n\n                            case '$like':\n                            case '$likes':\n                                if (typeof v !== 'string') {\n                                    throw new Error('The value should be a string when using \"$like\" operator.');\n                                }\n\n                                params.push(`%${v}%`);\n                                return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' LIKE ?';\n\n                            default:\n                                throw new Error(`Unsupported condition operator: \"${k}\"!`);\n                        }\n                    } else {\n                        throw new Error('Operator should not be mixed with condition value.');\n                    }\n                }).join(' AND ');\n            }\n\n            params.push(JSON.stringify(value));\n            return (\n                this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' = ' + this.specParamToken(params.length)\n            );\n        }\n\n        value = this.typeCast(value);\n\n        if (inject) {\n            return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' = ' + value;\n        }\n\n        params.push(value);\n        return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' = ' + this.specParamToken(params.length);\n    }\n\n    /**\n     * Build column list\n     * @param {array} columns\n     * @param {array} params\n     * @param {*} mainEntity\n     * @param {*} aliasMap\n     * @returns {string}\n     */\n    _buildColumns(columns, params, mainEntity, aliasMap) {\n        return _.map(_.castArray(columns), (col) => this._buildColumn(col, params, mainEntity, aliasMap)).join(', ');\n    }\n\n    /**\n     *\n     * @param {string|number|object} col - The column object or string, quoted string will be treated as raw SQL\n     * @property {string} [col.alias] - The alias of the column, can be a dot separated string\n     * @property {string} [col.type] - The type of the column, \"function\" | \"func\", \"expression\" | \"expr, \"column\" | \"col\"\n     * @property {string} [col.name] - The column name\n     * @property {string} [col.prefix] - The prefix of the function, like DISTINCT\n     * @property {array} [col.args] - The arguments of the function\n     * @property {object} [col.over] - The window function over clause\n     * @property {array} [col.over.$partitionBy] - The partition by clause\n     * @property {array} [col.over.$orderBy] - The order by clause\n     * @property {string} [col.over.$nulls] - The nulls clause, FIRST | LAST\n     * @param {*} params\n     * @param {*} mainEntity\n     * @param {*} aliasMap\n     * @returns\n     */\n    _buildColumn(col, params, mainEntity, aliasMap) {\n        if (typeof col === 'string') {\n            // it's a string if it's quoted when passed in\n            return isRawSql(col) ? extractRawSql(col) : this._escapeIdWithAlias(col, mainEntity, aliasMap);\n        }\n\n        if (typeof col === 'number') {\n            return col;\n        }\n\n        if (isPlainObject(col)) {\n            if (col.alias) {\n                const lastDotIndex = col.alias.lastIndexOf('.');\n                let alias = lastDotIndex > 0 ? col.alias.substring(lastDotIndex + 1) : col.alias;\n\n                if (lastDotIndex > 0) {\n                    if (!mainEntity) {\n                        throw new InvalidArgument(\n                            'Cascade alias is not allowed when the query has no associated entity populated.',\n                            {\n                                alias: col.alias,\n                            }\n                        );\n                    }\n\n                    const fullPath = mainEntity + '.' + col.alias.substring(0, lastDotIndex);\n                    const aliasPrefix = aliasMap[fullPath];\n                    if (!aliasPrefix) {\n                        throw new InvalidArgument(`Invalid cascade alias. \"${fullPath}\" not found in associations.`, {\n                            alias: col.alias,\n                        });\n                    }\n\n                    alias = aliasPrefix + '_' + alias;\n                }\n\n                aliasMap[col.alias] = alias;\n\n                return (\n                    this._buildColumn(_.omit(col, ['alias']), params, mainEntity, aliasMap) +\n                    ' AS ' +\n                    this.escapeId(alias)\n                );\n            }\n\n            if (col.type.startsWith('func')) {\n                const name = col.name.toUpperCase();\n                if (name === 'COUNT' && col.args.length === 1 && col.args[0] === '*') {\n                    return 'COUNT(*)';\n                }\n\n                if (this.constructor.windowFunctions.has(name)) {\n                    if (!col.over) {\n                        throw new InvalidArgument(`\"${name}\" window function requires over clause.`);\n                    }\n                } else if (!this.constructor.windowableFunctions.has(name) && col.over) {\n                    throw new InvalidArgument(`\"${name}\" function does not support over clause.`);\n                }\n\n                let funcClause =\n                    name +\n                    '(' +\n                    (col.prefix ? `${col.prefix.toUpperCase()} ` : '') +\n                    (col.args ? this._buildColumns(col.args, params, mainEntity, aliasMap) : '') +\n                    ')';\n\n                if (col.over) {\n                    funcClause += ' OVER(';\n                    if (col.over.$partitionBy) {\n                        funcClause += this._buildPartitionBy(col.over.$partitionBy, mainEntity, aliasMap);\n                    }\n\n                    if (col.over.$orderBy) {\n                        if (!funcClause.endsWith('(')) {\n                            funcClause += ' ';\n                        }\n                        funcClause += this._buildOrderBy(col.over.$orderBy, mainEntity, aliasMap);\n                    }\n\n                    if (col.over.$nulls) {\n                        funcClause += ' NULLS ' + col.over.$nulls; // FIRST | LAST\n                    }\n\n                    funcClause += ')';\n                }\n\n                return funcClause;\n            }\n\n            if (col.type.startsWith('expr')) {\n                return this._joinCondition(col.expr, params, null, mainEntity, aliasMap);\n            }\n\n            if (col.type.starsWith('column')) {\n                return this._escapeIdWithAlias(col.name, mainEntity, aliasMap);\n            }\n        }\n\n        throw new ApplicationError(`Unknow column syntax: ${JSON.stringify(col)}`);\n    }\n\n    /**\n     * Build group by column\n     * @param {string|object} groupBy \n     * @param {*} mainEntity \n     * @param {*} aliasMap \n     * @returns {string}\n     */\n    _buildGroupByColumn(groupBy, mainEntity, aliasMap) {\n        if (typeof groupBy === 'string') {\n            return isRawSql(groupBy) ? extractRawSql(groupBy) : this._escapeIdWithAlias(groupBy, mainEntity, aliasMap);\n        }\n\n        if (typeof groupBy === 'object') {\n            if (groupBy.alias) {\n                return this._escapeIdWithAlias(groupBy.alias, mainEntity, aliasMap);\n            }\n        }\n\n        throw new ApplicationError(`Unknown GROUP BY syntax: ${JSON.stringify(groupBy)}`);\n    }\n\n    /**\n     * Build group by column list\n     * @param {array|string} groupBy \n     * @param {*} mainEntity \n     * @param {*} aliasMap \n     * @returns {string}\n     */\n    _buildGroupByList(groupBy, mainEntity, aliasMap) {\n        if (Array.isArray(groupBy)) {\n            return 'GROUP BY ' + groupBy.map((by) => this._buildGroupByColumn(by, mainEntity, aliasMap)).join(', ');\n        }\n\n        return 'GROUP BY ' + this._buildGroupByColumn(groupBy, mainEntity, aliasMap);\n    }\n\n    /**\n     * Build group by clause from groupBy object\n     * @param {object|array|string} groupBy \n     * @property {array} [groupBy.columns] - The columns to group by\n     * @property {object} [groupBy.having] - The having condition\n     * @param {*} params \n     * @param {string} [mainEntity] - The entity name that has joining \n     * @param {*} aliasMap \n     * @returns {string}\n     */\n    _buildGroupBy(groupBy, params, mainEntity, aliasMap) {\n        if (isPlainObject(groupBy)) {\n            const { columns, having } = groupBy;\n\n            if (!columns || !Array.isArray(columns)) {\n                throw new ApplicationError(`Invalid group by syntax: ${JSON.stringify(groupBy)}`);\n            }\n\n            let groupByClause = this._buildGroupByList(columns, mainEntity, aliasMap);\n            const havingCluse = having && this._joinCondition(having, params, null, mainEntity, aliasMap);\n            if (havingCluse) {\n                groupByClause += ' HAVING ' + havingCluse;\n            }\n\n            return groupByClause;\n        }\n\n        return this._buildGroupByList(groupBy, mainEntity, aliasMap);\n    }\n\n    /**\n     * Build partition by clause\n     * @param {*} partitionBy \n     * @param {*} mainEntity \n     * @param {*} aliasMap \n     * @returns \n     */\n    _buildPartitionBy(partitionBy, mainEntity, aliasMap) {\n        if (typeof partitionBy === 'string') {\n            return 'PARTITION BY ' + this._escapeIdWithAlias(partitionBy, mainEntity, aliasMap);\n        }\n\n        if (Array.isArray(partitionBy)) {\n            return (\n                'PARTITION BY ' + partitionBy.map((by) => this._escapeIdWithAlias(by, mainEntity, aliasMap)).join(', ')\n            );\n        }\n\n        throw new ApplicationError(`Unknown PARTITION BY syntax: ${JSON.stringify(partitionBy)}`);\n    }\n\n    /**\n     * Build order by clause\n     * @param {string|array|object} orderBy \n     * @param {*} mainEntity \n     * @param {*} aliasMap \n     * @returns {string}\n     * \n     * @example\n     * $orderBy: 'name' => 'ORDER BY A.name'     \n     * $orderBy: ['name', 'age'] => 'ORDER BY A.name, A.age'\n     * $orderBy: { name: -1, age: 1 } => 'ORDER BY A.name DESC, A.age ASC'\n     */\n    _buildOrderBy(orderBy, mainEntity, aliasMap) {\n        if (typeof orderBy === 'string') {\n            return 'ORDER BY ' + this._escapeIdWithAlias(orderBy, mainEntity, aliasMap);\n        }\n\n        if (Array.isArray(orderBy))\n            return 'ORDER BY ' + orderBy.map((by) => this._escapeIdWithAlias(by, mainEntity, aliasMap)).join(', ');\n\n        if (isPlainObject(orderBy)) {\n            return (\n                'ORDER BY ' +\n                _.map(\n                    orderBy,\n                    (asc, col) =>\n                        this._escapeIdWithAlias(col, mainEntity, aliasMap) +\n                        (asc === false || asc === -1 ? ' DESC' : '')\n                ).join(', ')\n            );\n        }\n\n        throw new ApplicationError(`Unknown ORDER BY syntax: ${JSON.stringify(orderBy)}`);\n    }\n}\n\nexport default RelationalConnector;\n"],"names":["RelationalConnector","Connector","aggregate_","model","pipeline","options","connection","Array","isArray","length","InvalidArgument","startingQuery","_pipeline","query","buildQuery","forEach","stage","i","_params","params","sql","alias","concat","_executeQuery_","queryOptions","result","totalCount","countSql","res","execute_","countParams","rows","count","hasJoining","rowsAsArray","reverseAliasMap","_","reduce","aliasMap","nodePath","split","slice","$skipOrm","_buildCTEHeader","fromTable","escapeId","withTables","subSql","$relation","$select","$where","$groupBy","$orderBy","$offset","$limit","$totalCount","$key","hasTotalCount","needDistinctForLimit","_model","joinings","joiningParams","_joinAssociations","isEmpty","mainEntity","selectParams","selectColomns","_buildColumns","fromClause","fromAndJoin","join","whereClause","whereParams","_joinCondition","p","push","groupByClause","groupByParams","_buildGroupBy","orderByClause","_buildOrderBy","limitOffetParams","limitOffset","_buildLimitOffset","distinctFieldRaw","distinctField","_escapeIdWithAlias","countSubject","distinctFieldWithAlias","keysSql","keySqlAliasIndex","Object","keys","keySqlAnchor","ntol","_joinAssociation","joinType","on","$xr","name","output","_generateAlias","index","anchor","verboseAlias","snakeCase","toUpperCase","associations","parentAliasKey","startId","each","assocInfo","entity","aliasKey","subJoinings","sj","condition","joinOperator","map","c","isPlainObject","_packValue","value","key","startsWith","Error","left","right","op","_wrapCondition","JSON","stringify","isInteger","specParamToken","_replaceFieldNameWithAlias","fieldName","substring","parts","actualFieldName","pop","_packArray","array","args","inject","$in","hasOperator","find","k","v","typeCast","sqlInfo","specInClause","specNotInClause","columns","castArray","col","_buildColumn","isRawSql","extractRawSql","lastDotIndex","lastIndexOf","fullPath","aliasPrefix","omit","type","constructor","windowFunctions","has","over","windowableFunctions","funcClause","prefix","$partitionBy","_buildPartitionBy","endsWith","$nulls","expr","starsWith","ApplicationError","_buildGroupByColumn","groupBy","_buildGroupByList","by","having","havingCluse","partitionBy","orderBy","asc","app","driver","connectionString","relational"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}