{"version":3,"sources":["../../../src/drivers/relational/Connector.js"],"sourcesContent":["import ntol from 'number-to-letter';\nimport { isPlainObject, isEmpty, snakeCase, isInteger, _ } from '@kimit/utils';\n\nimport Connector from '../../Connector';\nimport { isRawSql, extractRawSql } from '../../utils/Rules';\n\nclass RelationalConnector extends Connector {\n    /**\n     * Create a new instance of the connector.\n     * @param {App} app\n     * @param {string} connectionString\n     * @param {object} options\n     * @property {boolean} [options.logStatement] - Flag to log executed SQL statement.\n     * @property {boolean} [options.logConnection] - Flag to log connect and disconnect.\n     * @property {boolean} [options.verboseAlias] - Flag to use verbose alias.\n     */\n    constructor(app, driver, connectionString, options) {\n        super(app, driver, connectionString, options);\n\n        this.relational = true;\n    }\n\n    /**\n     * Build CTE header and return the select from target and CTE header\n     * @param {string} model\n     * @returns {object} { fromTable, withTables, model }\n     */\n    _buildCTEHeader(model) {\n        let fromTable = this.escapeId(model);\n        let withTables = '';\n\n        // CTE, used by aggregation\n        if (typeof model === 'object') {\n            const { sql: subSql, alias } = model;\n\n            model = alias;\n            fromTable = alias;\n            withTables = `WITH ${alias} AS (${subSql}) `;\n        }\n\n        return { fromTable, withTables, model };\n    }\n\n    /**\n     * Build sql statement\n     * @param {string|object} model - Model name or CTE object\n     * @param {*} condition\n     * @property {object} $relation\n     * @property {object} $projection\n     * @property {object} $query\n     * @property {object} $groupBy\n     * @property {object} $orderBy\n     * @property {number} $offset - Offset\n     * @property {number} $limit - Limit\n     * @property {boolean} $totalCount - Whether to count the total number of records\n     * @property {string} $key\n     */\n    buildQuery(model, { $relation, $projection, $query, $groupBy, $orderBy, $offset, $limit, $totalCount, $key }) {\n        const hasTotalCount = $totalCount;\n        let needDistinctForLimit = ($limit != null && $limit > 0) || ($offset != null && $offset > 0);\n\n        const { fromTable, withTables, model: _model } = this._buildCTEHeader(model);\n        model = _model; // replaced with CTE alias\n\n        const aliasMap = { [model]: 'A' };\n\n        let joinings;\n        let hasJoining = false; // false or primary model name\n        const joiningParams = [];\n\n        // build alias map first\n        // cache params\n        if ($relation) {\n            joinings = this._joinAssociations($relation, model, aliasMap, 1, joiningParams);\n            hasJoining = model;\n        }\n\n        // !!!limit or offset with mutiple joining requires group by distinct field to calculate the correct number of records\n        needDistinctForLimit &&= hasJoining && isEmpty($groupBy);\n\n        // count does not require selectParams\n        const countParams = hasTotalCount ? joiningParams.concat() : null;\n\n        // Build select columns\n        const selectParams = [];\n        const selectColomns = $projection ? this._buildColumns($projection, selectParams, hasJoining, aliasMap) : '*';\n\n        // Build from clause\n        let fromClause = ' FROM ' + fromTable;\n        let fromAndJoin = fromClause;\n        if (joinings) {\n            fromAndJoin += ' A ' + joinings.join(' ');\n        }\n\n        // Build where clause\n        let whereClause = '';\n        const whereParams = [];\n\n        if ($query) {\n            whereClause = this._joinCondition($query, whereParams, null, hasJoining, aliasMap);\n\n            if (whereClause) {\n                whereClause = ' WHERE ' + whereClause;\n                if (countParams) {\n                    whereParams.forEach((p) => {\n                        countParams.push(p);\n                    });\n                }\n            }\n        }\n\n        // Build group by clause\n        let groupByClause = '';\n        const groupByParams = [];\n\n        if ($groupBy) {\n            groupByClause += ' ' + this._buildGroupBy($groupBy, groupByParams, hasJoining, aliasMap);\n            if (countParams) {\n                groupByParams.forEach((p) => {\n                    countParams.push(p);\n                });\n            }\n        }\n\n        // Build order by clause\n        let orderByClause = '';\n        if ($orderBy) {\n            orderByClause += ' ' + this._buildOrderBy($orderBy, hasJoining, aliasMap);\n        }\n\n        // Build limit & offset clause\n        const limitOffetParams = [];\n        let limitOffset = this._buildLimitOffset($limit, $offset, limitOffetParams);\n\n        const result = { hasJoining, aliasMap };\n\n        // The field used as the key of counting or pagination\n        let distinctField;\n\n        if (hasTotalCount || needDistinctForLimit) {\n            distinctField = this._escapeIdWithAlias(\n                typeof $totalCount === 'string' ? $totalCount : $key,\n                hasJoining,\n                aliasMap\n            );\n        }\n\n        if (hasTotalCount) {\n            const countSubject = 'DISTINCT(' + distinctField + ')';\n\n            result.countSql =\n                withTables + `SELECT COUNT(${countSubject}) AS count` + fromAndJoin + whereClause + groupByClause;\n            result.countParams = countParams;\n        }\n\n        if (needDistinctForLimit) {\n            const distinctFieldWithAlias = `${distinctField} AS key_`;\n            const keysSql = orderByClause\n                ? `WITH records_ AS (SELECT ${distinctFieldWithAlias}, ROW_NUMBER() OVER(${orderByClause}) AS row_${fromAndJoin}${whereClause}${groupByClause}) SELECT key_ FROM records_ GROUP BY key_ ORDER BY row_${limitOffset}`\n                : `WITH records_ AS (SELECT ${distinctFieldWithAlias}${fromAndJoin}${whereClause}${groupByClause}) SELECT key_ FROM records_ GROUP BY key_${limitOffset}`;\n\n            const keySqlAliasIndex = Object.keys(aliasMap).length;\n            const keySqlAnchor = ntol(keySqlAliasIndex);\n\n            this._joinAssociation(\n                {\n                    sql: keysSql,\n                    params: joiningParams.concat(whereParams, groupByParams, limitOffetParams),\n                    joinType: 'INNER JOIN',\n                    on: {\n                        [$key]: {\n                            $xt: 'ColumnReference',\n                            name: `${keySqlAnchor}.key_`,\n                        },\n                    },\n                    output: true,\n                },\n                keySqlAnchor,\n                joinings,\n                model,\n                aliasMap,\n                keySqlAliasIndex,\n                joiningParams\n            );\n\n            fromAndJoin = fromClause + ' A ' + joinings.join(' ');\n\n            result.sql =\n                withTables + 'SELECT ' + selectColomns + fromAndJoin + whereClause + groupByClause + orderByClause;\n            result.params = selectParams.concat(joiningParams, whereParams, groupByParams);\n        } else {\n            result.sql =\n                withTables +\n                'SELECT ' +\n                selectColomns +\n                fromAndJoin +\n                whereClause +\n                groupByClause +\n                orderByClause +\n                limitOffset;\n\n            result.params = selectParams.concat(joiningParams, whereParams, groupByParams, limitOffetParams);\n        }\n\n        return result;\n    }\n\n    /**\n     * Generate an alias\n     * @param {*} index \n     * @param {*} anchor \n     * @returns {string}\n     */\n    _generateAlias(index, anchor) {\n        if (this.options.verboseAlias) {\n            return `${snakeCase(anchor).toUpperCase()}${index}`;\n        }\n\n        return ntol(index);\n    }\n\n    /**\n     * Extract associations into joining clauses.\n     *  [{\n     *      entity: <remote entity>\n     *      joinType: 'LEFT JOIN|INNER JOIN|FULL OUTER JOIN'\n     *      on: join condition\n     *      anchor: 'local property to place the remote entity'\n     *      localField: <local field to join>\n     *      remoteField: <remote field to join>\n     *      $relation: { ... }\n     *  }]\n     *\n     * @param {*} associations\n     * @param {*} parentAliasKey\n     * @param {*} aliasMap\n     * @param {*} params\n     * @param {*} startId\n     * @param {*} params\n     * @returns {object}\n     */\n    _joinAssociations(associations, parentAliasKey, aliasMap, startId, params) {\n        let joinings = [];\n\n        _.each(associations, (assocInfo, anchor) => {\n            startId = this._joinAssociation(assocInfo, anchor, joinings, parentAliasKey, aliasMap, startId, params);\n        });\n\n        return joinings;\n    }\n\n    /**\n     * Convert an association into joining clause\n     * @param {object} assocInfo\n     * @property {string} [assocInfo.joinType=\"LEFT JOIN\"] - Join type\n     * @property {object} [assocInfo.on] - Join condition\n     * @property {string} [assocInfo.alias] - Alias of the association\n     * @property {string} [assocInfo.sql] - Explicit SQL statement\n     * @property {array} [assocInfo.params] - Parameters for the SQL statement\n     * @property {string} [assocInfo.entity] - The entity to join\n     * @property {object} [assocInfo.$relation] - Sub-associations\n     * @property {boolean} [assocInfo.output] - Whether to output the association\n     * @param {string} anchor - The anchor of the association, usually the property name (prefixed by \":\") in the parent entity\n     * @param {array} joinings - The array to store the joining clauses\n     * @param {string} parentAliasKey - The parent alias key\n     * @param {object} aliasMap - The alias map\n     * @param {integer} startId - The starting index for alias generation\n     * @param {array} params - The parameters array\n     * @returns\n     */\n    _joinAssociation(assocInfo, anchor, joinings, parentAliasKey, aliasMap, startId, params) {\n        const alias = assocInfo.alias || this._generateAlias(startId++, anchor);\n        let { joinType, on } = assocInfo;\n\n        joinType || (joinType = 'LEFT JOIN');\n\n        if (assocInfo.sql) {\n            if (assocInfo.output) {\n                aliasMap[parentAliasKey + '.' + alias] = alias;\n            }\n\n            assocInfo.params.forEach((p) => params.push(p));\n            joinings.push(\n                `${joinType} (${assocInfo.sql}) ${alias} ON ${this._joinCondition(\n                    on,\n                    params,\n                    null,\n                    parentAliasKey,\n                    aliasMap\n                )}`\n            );\n\n            return startId;\n        }\n\n        const { entity, $relation } = assocInfo;\n        const aliasKey = parentAliasKey + '.' + anchor;\n        aliasMap[aliasKey] = alias;\n\n        if ($relation) {\n            const _params = [];\n            const subJoinings = this._joinAssociations($relation, aliasKey, aliasMap, startId, _params);\n            startId += subJoinings.length;\n\n            joinings.push(\n                `${joinType} ${this.escapeId(entity)} ${alias} ON ${this._joinCondition(\n                    on,\n                    params,\n                    null,\n                    parentAliasKey,\n                    aliasMap\n                )}`\n            );\n\n            subJoinings.forEach((sj) => joinings.push(sj));\n            _params.forEach((p) => params.push(p));\n        } else {\n            joinings.push(\n                `${joinType} ${this.escapeId(entity)} ${alias} ON ${this._joinCondition(\n                    on,\n                    params,\n                    null,\n                    parentAliasKey,\n                    aliasMap\n                )}`\n            );\n        }\n\n        return startId;\n    }\n\n    /**\n     * SQL condition representation\n     *   Rules:\n     *     default:\n     *        array: OR\n     *        kv-pair: AND\n     *     $all:\n     *        array: AND\n     *     $any:\n     *        kv-pair: OR\n     *     $not:\n     *        array: not ( or )\n     *        kv-pair: not ( and )\n     * @param {object|array|string} condition - The condition object\n     * @param {array} params - The parameters array\n     * @param {string} joinOperator - 'AND' or 'OR'\n     * @param {string} mainEntity - The entity name that has joining\n     * @param {object} aliasMap - The alias map, dot separated key -> alias\n     */\n    _joinCondition(condition, params, joinOperator, mainEntity, aliasMap) {\n        if (Array.isArray(condition)) {\n            if (!joinOperator) {\n                joinOperator = 'OR';\n            }\n            return condition\n                .map((c) => '(' + this._joinCondition(c, params, null, mainEntity, aliasMap) + ')')\n                .join(` ${joinOperator} `);\n        }\n\n        if (isPlainObject(condition)) {\n            if (condition.$xr) {\n                return this._packValue(condition, params, mainEntity, aliasMap);\n            }\n\n            if (!joinOperator) {\n                joinOperator = 'AND';\n            }\n\n            return _.map(condition, (value, key) => {\n                if (key === '$all' || key === '$and' || key.startsWith('$and_')) {\n                    // for avoiding duplicate, $and_1, $and_2 is valid\n                    if (!Array.isArray(value) && !isPlainObject(value)) {\n                        throw new Error('\"$and\" operator value should be an array or plain object.');\n                    }\n\n                    return '(' + this._joinCondition(value, params, 'AND', mainEntity, aliasMap) + ')';\n                }\n\n                if (key === '$any' || key === '$or' || key.startsWith('$or_')) {\n                    // for avoiding dupliate, $or_1, $or_2 is valid\n                    if (!Array.isArray(value) && !isPlainObject(value)) {\n                        throw new Error('\"$or\" operator value should be an array or plain object.');\n                    }\n\n                    return '(' + this._joinCondition(value, params, 'OR', mainEntity, aliasMap) + ')';\n                }\n\n                if (key === '$not') {\n                    if (Array.isArray(value)) {\n                        if (value.length === 0) {\n                            throw new Error('\"$not\" operator value should be non-empty.');\n                        }\n\n                        return 'NOT (' + this._joinCondition(value, params, null, mainEntity, aliasMap) + ')';\n                    }\n\n                    if (isPlainObject(value)) {\n                        if (isEmpty(value)) {\n                            throw new Error('\"$not\" operator value should be non-empty.');\n                        }\n\n                        return 'NOT (' + this._joinCondition(value, params, null, mainEntity, aliasMap) + ')';\n                    }\n\n                    if (typeof value !== 'string') {\n                        throw new Error('Unsupported condition!');\n                    }\n\n                    return 'NOT (' + condition + ')';\n                }\n\n                if ((key === '$expr' || key.startsWith('$expr_')) && value.$xt && value.$xt === 'BinaryExpression') {\n                    const left = this._packValue(value.left, params, mainEntity, aliasMap);\n                    const right = this._packValue(value.right, params, mainEntity, aliasMap);\n                    return left + ` ${value.op} ` + right;\n                }\n\n                return this._wrapCondition(key, value, params, mainEntity, aliasMap);\n            }).join(` ${joinOperator} `);\n        }\n\n        if (typeof condition !== 'string') {\n            throw new Error('Unsupported condition!\\n Value: ' + JSON.stringify(condition));\n        }\n\n        return condition;\n    }\n\n    /**\n     * Build limit and offset clause\n     * @param {*} $limit\n     * @param {*} $offset\n     * @param {*} params\n     * @returns {string} '' or ' LIMIT X, Y'\n     */\n    _buildLimitOffset($limit, $offset, params) {\n        let sql = '';\n\n        if (isInteger($limit) && $limit > 0) {\n            if (isInteger($offset) && $offset > 0) {\n                sql = ' LIMIT ?, ?';\n                params.push($offset);\n                params.push($limit);\n            } else {\n                sql = ' LIMIT ?';\n                params.push($limit);\n            }\n        } else if (isInteger($offset) && $offset > 0) {\n            sql = ` LIMIT ?, ${Number.MAX_SAFE_INTEGER}`;\n            params.push($offset);\n        }\n\n        return sql;\n    }\n\n    /**\n     * Convert the dot separated field name to alias padded and escaped field name\n     * @param {string} fieldName - The dot separate field name or starting with \"::\" for skipping alias padding\n     * @param {*} mainEntity\n     * @param {*} aliasMap\n     * @returns {string}\n     */\n    _replaceFieldNameWithAlias(fieldName, mainEntity, aliasMap) {\n        if (fieldName.startsWith('::')) {\n            // ::fieldName for skipping alias padding\n            return this.escapeId(fieldName.substring(2));\n        }\n\n        const parts = fieldName.split('.');\n        if (parts.length > 1) {\n            const actualFieldName = parts.pop();\n            const aliasKey = mainEntity + '.' + parts.join('.');\n            const alias = aliasMap[aliasKey];\n            if (!alias) {\n                throw new InvalidArgument(`Column reference \"${fieldName}\" not found in populated associations.`, {\n                    entity: mainEntity,\n                    alias: aliasKey,\n                    aliasMap,\n                });\n            }\n\n            return alias + '.' + (actualFieldName === '*' ? '*' : this.escapeId(actualFieldName));\n        }\n\n        if (aliasMap[fieldName] === fieldName) {\n            return this.escapeId(fieldName);\n        }\n\n        return aliasMap[mainEntity] + '.' + (fieldName === '*' ? '*' : this.escapeId(fieldName));\n    }\n\n    /**\n     * Escape the field name with alias, skip if the field name is \"*\"\n     * @param {string} fieldName\n     * @param {string} mainEntity\n     * @param {object} aliasMap\n     * @returns {string}\n     */\n    _escapeIdWithAlias(fieldName, mainEntity, aliasMap) {\n        if (mainEntity) {\n            return this._replaceFieldNameWithAlias(fieldName, mainEntity, aliasMap);\n        }\n\n        return fieldName === '*' ? fieldName : this.escapeId(fieldName);\n    }\n\n    _splitColumnsAsInput(data, params, hasJoining, aliasMap) {\n        return _.map(data, (v, fieldName) => {\n            return (\n                this._escapeIdWithAlias(fieldName, hasJoining, aliasMap) +\n                '=' +\n                this._packValue(v, params, hasJoining, aliasMap)\n            );\n        });\n    }\n\n    /**\n     * Pack an array of values into params and return the parameterized string with placeholders\n     * @param {*} array\n     * @param {*} params\n     * @param {*} mainEntity\n     * @param {*} aliasMap\n     * @returns {string}\n     */\n    _packArray(array, params, mainEntity, aliasMap) {\n        return array.map((value) => this._packValue(value, params, mainEntity, aliasMap)).join(',');\n    }\n\n    /**\n     * Pack a value into params and return the parameter placeholder\n     * @param {*} value\n     * @param {*} params\n     * @param {*} hasJoining\n     * @param {*} aliasMap\n     * @returns\n     */\n    _packValue(value, params, hasJoining, aliasMap) {\n        if (isPlainObject(value)) {\n            if (value.$xr) {\n                switch (value.$xr) {\n                    case 'ColumnReference':\n                        return this._escapeIdWithAlias(value.name, hasJoining, aliasMap);\n\n                    case 'Function':\n                        return (\n                            value.name +\n                            '(' +\n                            (value.args ? this._packArray(value.args, params, hasJoining, aliasMap) : '') +\n                            ')'\n                        );\n\n                    case 'Raw':\n                        return value.statement;\n\n                    case 'Query':\n                        return this._joinCondition(value.query, params, null, hasJoining, aliasMap);\n\n                    case 'BinaryExpression': {\n                        const left = this._packValue(value.left, params, hasJoining, aliasMap);\n                        const right = this._packValue(value.right, params, hasJoining, aliasMap);\n                        return left + ` ${value.op} ` + right;\n                    }\n\n                    default:\n                        throw new Error(`Unknown oor type: ${value.$xr}`);\n                }\n            }\n\n            value = JSON.stringify(value);\n        }\n\n        params.push(value);\n        return this.specParamToken(params.length);\n    }\n\n    /**\n     * Wrap a condition clause\n     *\n     * Value can be a literal or a plain condition object.\n     *   1. fieldName, <literal>\n     *   2. fieldName, { normal object }\n     *\n     * @param {string} fieldName - The field name in a condition object.\n     * @param {*} value\n     * @param {array} params - The parameters array\n     * @param {string} mainEntity - The entity name that has joining\n     * @param {object} aliasMap - The alias map, dot separated key -> alias\n     * @param {boolean} [inject=false] - Whether to inject the value directly\n     */\n    _wrapCondition(fieldName, value, params, mainEntity, aliasMap, inject) {\n        if (value == null) {\n            return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' IS NULL';\n        }\n\n        if (Array.isArray(value)) {\n            return this._wrapCondition(fieldName, { $in: value }, params, mainEntity, aliasMap, inject);\n        }\n\n        if (isPlainObject(value)) {\n            if (value.$xr) {\n                return (\n                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +\n                    ' = ' +\n                    this._packValue(value, params, mainEntity, aliasMap)\n                );\n            }\n\n            const hasOperator = _.find(Object.keys(value), (k) => k && k[0] === '$');\n\n            if (hasOperator) {\n                return _.map(value, (v, k) => {\n                    if (k && k[0] === '$') {\n                        // operator\n                        switch (k) {\n                            case '$exist':\n                            case '$exists':\n                                return (\n                                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +\n                                    (v ? ' IS NOT NULL' : 'IS NULL')\n                                );\n\n                            case '$eq':\n                            case '$equal':\n                                return this._wrapCondition(fieldName, v, params, mainEntity, aliasMap, inject);\n\n                            case '$ne':\n                            case '$neq':\n                            case '$notEqual':\n                                if (v == null) {\n                                    return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' IS NOT NULL';\n                                }\n\n                                v = this.typeCast(v);\n\n                                if (inject) {\n                                    return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' <> ' + v;\n                                }\n\n                                return (\n                                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +\n                                    ` <> ${this._packValue(v, params, mainEntity, aliasMap)}`\n                                );\n\n                            case '$>':\n                            case '$gt':\n                            case '$greaterThan':\n                                v = this.typeCast(v);\n\n                                if (inject) {\n                                    return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' > ' + v;\n                                }\n\n                                return (\n                                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +\n                                    ` > ${this._packValue(v, params, mainEntity, aliasMap)}`\n                                );\n\n                            case '$>=':\n                            case '$gte':\n                            case '$greaterThanOrEqual':\n                                v = this.typeCast(v);\n\n                                if (inject) {\n                                    return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' >= ' + v;\n                                }\n\n                                return (\n                                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +\n                                    ` >= ${this._packValue(v, params, mainEntity, aliasMap)}`\n                                );\n\n                            case '$<':\n                            case '$lt':\n                            case '$lessThan':\n                                v = this.typeCast(v);\n\n                                if (inject) {\n                                    return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' < ' + v;\n                                }\n\n                                return (\n                                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +\n                                    ` < ${this._packValue(v, params, mainEntity, aliasMap)}`\n                                );\n\n                            case '$<=':\n                            case '$lte':\n                            case '$lessThanOrEqual':\n                                v = this.typeCast(v);\n\n                                if (inject) {\n                                    return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' <= ' + v;\n                                }\n\n                                return (\n                                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +\n                                    ` <= ${this._packValue(v, params, mainEntity, aliasMap)}`\n                                );\n\n                            case '$in':\n                                if (isPlainObject(v) && v.$xr === 'DataSet') {\n                                    const sqlInfo = this.buildQuery(v.model, v.query);\n                                    sqlInfo.params && sqlInfo.params.forEach((p) => params.push(p));\n\n                                    return (\n                                        this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +\n                                        ` IN (${sqlInfo.sql})`\n                                    );\n                                } else {\n                                    if (!Array.isArray(v)) {\n                                        throw new Error(\n                                            'The value should be a dataset or an array when using \"$in\" operator.'\n                                        );\n                                    }\n\n                                    if (inject) {\n                                        return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ` IN (${v})`;\n                                    }\n\n                                    params.push(v);\n                                    return (\n                                        this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +\n                                        this.specInClause(params.length)\n                                    );\n                                }\n\n                            case '$nin':\n                            case '$notIn':\n                                if (isPlainObject(v) && v.$xr === 'DataSet') {\n                                    const sqlInfo = this.buildQuery(v.model, v.query);\n                                    sqlInfo.params && sqlInfo.params.forEach((p) => params.push(p));\n\n                                    return (\n                                        this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +\n                                        ` NOT IN (${sqlInfo.sql})`\n                                    );\n                                } else {\n                                    if (!Array.isArray(v)) {\n                                        throw new Error('The value should be an array when using \"$in\" operator.');\n                                    }\n\n                                    if (inject) {\n                                        return (\n                                            this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ` NOT IN (${v})`\n                                        );\n                                    }\n\n                                    params.push(v);\n                                    return (\n                                        this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +\n                                        this.specNotInClause(params.length)\n                                    );\n                                }\n\n                            case '$startWith':\n                            case '$startsWith':\n                                if (typeof v !== 'string') {\n                                    throw new Error('The value should be a string when using \"$startWith\" operator.');\n                                }\n\n                                params.push(`${v}%`);\n                                return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' LIKE ?';\n\n                            case '$endWith':\n                            case '$endsWith':\n                                if (typeof v !== 'string') {\n                                    throw new Error('The value should be a string when using \"$endWith\" operator.');\n                                }\n\n                                params.push(`%${v}`);\n                                return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' LIKE ?';\n\n                            case '$like':\n                            case '$likes':\n                                if (typeof v !== 'string') {\n                                    throw new Error('The value should be a string when using \"$like\" operator.');\n                                }\n\n                                params.push(`%${v}%`);\n                                return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' LIKE ?';\n\n                            default:\n                                throw new Error(`Unsupported condition operator: \"${k}\"!`);\n                        }\n                    } else {\n                        throw new Error('Operator should not be mixed with condition value.');\n                    }\n                }).join(' AND ');\n            }\n\n            params.push(JSON.stringify(value));\n            return (\n                this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' = ' + this.specParamToken(params.length)\n            );\n        }\n\n        value = this.typeCast(value);\n\n        if (inject) {\n            return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' = ' + value;\n        }\n\n        params.push(value);\n        return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' = ' + this.specParamToken(params.length);\n    }\n\n    /**\n     * Build column list\n     * @param {array} columns\n     * @param {array} params\n     * @param {*} mainEntity\n     * @param {*} aliasMap\n     * @returns {string}\n     */\n    _buildColumns(columns, params, mainEntity, aliasMap) {\n        return _.map(_.castArray(columns), (col) => this._buildColumn(col, params, mainEntity, aliasMap)).join(', ');\n    }\n\n    /**\n     *\n     * @param {string|number|object} col - The column object or string, quoted string will be treated as raw SQL\n     * @property {string} [col.alias] - The alias of the column, can be a dot separated string\n     * @property {string} [col.type] - The type of the column, \"function\" | \"func\", \"expression\" | \"expr, \"column\" | \"col\"\n     * @property {string} [col.name] - The column name\n     * @property {string} [col.prefix] - The prefix of the function, like DISTINCT\n     * @property {array} [col.args] - The arguments of the function\n     * @property {object} [col.over] - The window function over clause\n     * @property {array} [col.over.$partitionBy] - The partition by clause\n     * @property {array} [col.over.$orderBy] - The order by clause\n     * @property {string} [col.over.$nulls] - The nulls clause, FIRST | LAST\n     * @param {*} params\n     * @param {*} mainEntity\n     * @param {*} aliasMap\n     * @returns\n     */\n    _buildColumn(col, params, mainEntity, aliasMap) {\n        if (typeof col === 'string') {\n            // it's a string if it's quoted when passed in\n            return isRawSql(col) ? extractRawSql(col) : this._escapeIdWithAlias(col, mainEntity, aliasMap);\n        }\n\n        if (typeof col === 'number') {\n            return col;\n        }\n\n        if (isPlainObject(col)) {\n            if (col.alias) {\n                const lastDotIndex = col.alias.lastIndexOf('.');\n                let alias = lastDotIndex > 0 ? col.alias.substring(lastDotIndex + 1) : col.alias;\n\n                if (lastDotIndex > 0) {\n                    if (!mainEntity) {\n                        throw new InvalidArgument(\n                            'Cascade alias is not allowed when the query has no associated entity populated.',\n                            {\n                                alias: col.alias,\n                            }\n                        );\n                    }\n\n                    const fullPath = mainEntity + '.' + col.alias.substring(0, lastDotIndex);\n                    const aliasPrefix = aliasMap[fullPath];\n                    if (!aliasPrefix) {\n                        throw new InvalidArgument(`Invalid cascade alias. \"${fullPath}\" not found in associations.`, {\n                            alias: col.alias,\n                        });\n                    }\n\n                    alias = aliasPrefix + '_' + alias;\n                }\n\n                aliasMap[col.alias] = alias;\n\n                return (\n                    this._buildColumn(_.omit(col, ['alias']), params, mainEntity, aliasMap) +\n                    ' AS ' +\n                    this.escapeId(alias)\n                );\n            }\n\n            if (col.type.startsWith('func')) {\n                const name = col.name.toUpperCase();\n                if (name === 'COUNT' && col.args.length === 1 && col.args[0] === '*') {\n                    return 'COUNT(*)';\n                }\n\n                if (this.constructor.windowFunctions.has(name)) {\n                    if (!col.over) {\n                        throw new InvalidArgument(`\"${name}\" window function requires over clause.`);\n                    }\n                } else if (!this.constructor.windowableFunctions.has(name) && col.over) {\n                    throw new InvalidArgument(`\"${name}\" function does not support over clause.`);\n                }\n\n                let funcClause =\n                    name +\n                    '(' +\n                    (col.prefix ? `${col.prefix.toUpperCase()} ` : '') +\n                    (col.args ? this._buildColumns(col.args, params, mainEntity, aliasMap) : '') +\n                    ')';\n\n                if (col.over) {\n                    funcClause += ' OVER(';\n                    if (col.over.$partitionBy) {\n                        funcClause += this._buildPartitionBy(col.over.$partitionBy, mainEntity, aliasMap);\n                    }\n\n                    if (col.over.$orderBy) {\n                        if (!funcClause.endsWith('(')) {\n                            funcClause += ' ';\n                        }\n                        funcClause += this._buildOrderBy(col.over.$orderBy, mainEntity, aliasMap);\n                    }\n\n                    if (col.over.$nulls) {\n                        funcClause += ' NULLS ' + col.over.$nulls; // FIRST | LAST\n                    }\n\n                    funcClause += ')';\n                }\n\n                return funcClause;\n            }\n\n            if (col.type.startsWith('expr')) {\n                return this._joinCondition(col.expr, params, null, mainEntity, aliasMap);\n            }\n\n            if (col.type.starsWith('column')) {\n                return this._escapeIdWithAlias(col.name, mainEntity, aliasMap);\n            }\n        }\n\n        throw new ApplicationError(`Unknow column syntax: ${JSON.stringify(col)}`);\n    }\n\n    /**\n     * Build group by column\n     * @param {string|object} groupBy \n     * @param {*} mainEntity \n     * @param {*} aliasMap \n     * @returns {string}\n     */\n    _buildGroupByColumn(groupBy, mainEntity, aliasMap) {\n        if (typeof groupBy === 'string') {\n            return isRawSql(groupBy) ? extractRawSql(groupBy) : this._escapeIdWithAlias(groupBy, mainEntity, aliasMap);\n        }\n\n        if (typeof groupBy === 'object') {\n            if (groupBy.alias) {\n                return this._escapeIdWithAlias(groupBy.alias, mainEntity, aliasMap);\n            }\n        }\n\n        throw new ApplicationError(`Unknown GROUP BY syntax: ${JSON.stringify(groupBy)}`);\n    }\n\n    _buildGroupByList(groupBy, hasJoining, aliasMap) {\n        if (Array.isArray(groupBy)) {\n            return 'GROUP BY ' + groupBy.map((by) => this._buildGroupByColumn(by, hasJoining, aliasMap)).join(', ');\n        }\n\n        return 'GROUP BY ' + this._buildGroupByColumn(groupBy, hasJoining, aliasMap);\n    }\n\n    _buildGroupBy(groupBy, params, hasJoining, aliasMap) {\n        if (isPlainObject(groupBy)) {\n            const { columns, having } = groupBy;\n\n            if (!columns || !Array.isArray(columns)) {\n                throw new ApplicationError(`Invalid group by syntax: ${JSON.stringify(groupBy)}`);\n            }\n\n            let groupByClause = this._buildGroupByList(columns, hasJoining, aliasMap);\n            const havingCluse = having && this._joinCondition(having, params, null, hasJoining, aliasMap);\n            if (havingCluse) {\n                groupByClause += ' HAVING ' + havingCluse;\n            }\n\n            return groupByClause;\n        }\n\n        return this._buildGroupByList(groupBy, hasJoining, aliasMap);\n    }\n\n    _buildPartitionBy(partitionBy, hasJoining, aliasMap) {\n        if (typeof partitionBy === 'string') {\n            return 'PARTITION BY ' + this._escapeIdWithAlias(partitionBy, hasJoining, aliasMap);\n        }\n\n        if (Array.isArray(partitionBy)) {\n            return (\n                'PARTITION BY ' + partitionBy.map((by) => this._escapeIdWithAlias(by, hasJoining, aliasMap)).join(', ')\n            );\n        }\n\n        throw new ApplicationError(`Unknown PARTITION BY syntax: ${JSON.stringify(partitionBy)}`);\n    }\n\n    _buildOrderBy(orderBy, hasJoining, aliasMap) {\n        if (typeof orderBy === 'string') {\n            return 'ORDER BY ' + this._escapeIdWithAlias(orderBy, hasJoining, aliasMap);\n        }\n\n        if (Array.isArray(orderBy))\n            return 'ORDER BY ' + orderBy.map((by) => this._escapeIdWithAlias(by, hasJoining, aliasMap)).join(', ');\n\n        if (isPlainObject(orderBy)) {\n            return (\n                'ORDER BY ' +\n                _.map(\n                    orderBy,\n                    (asc, col) =>\n                        this._escapeIdWithAlias(col, hasJoining, aliasMap) +\n                        (asc === false || asc === -1 ? ' DESC' : '')\n                ).join(', ')\n            );\n        }\n\n        throw new ApplicationError(`Unknown ORDER BY syntax: ${JSON.stringify(orderBy)}`);\n    }\n}\n\nexport default RelationalConnector;\n"],"names":["RelationalConnector","Connector","_buildCTEHeader","model","fromTable","escapeId","withTables","sql","subSql","alias","buildQuery","$relation","$projection","$query","$groupBy","$orderBy","$offset","$limit","$totalCount","$key","hasTotalCount","needDistinctForLimit","_model","aliasMap","joinings","hasJoining","joiningParams","_joinAssociations","isEmpty","countParams","concat","selectParams","selectColomns","_buildColumns","fromClause","fromAndJoin","join","whereClause","whereParams","_joinCondition","forEach","p","push","groupByClause","groupByParams","_buildGroupBy","orderByClause","_buildOrderBy","limitOffetParams","limitOffset","_buildLimitOffset","result","distinctField","_escapeIdWithAlias","countSubject","countSql","distinctFieldWithAlias","keysSql","keySqlAliasIndex","Object","keys","length","keySqlAnchor","ntol","_joinAssociation","params","joinType","on","$xt","name","output","_generateAlias","index","anchor","options","verboseAlias","snakeCase","toUpperCase","associations","parentAliasKey","startId","_","each","assocInfo","entity","aliasKey","_params","subJoinings","sj","condition","joinOperator","mainEntity","Array","isArray","map","c","isPlainObject","$xr","_packValue","value","key","startsWith","Error","left","right","op","_wrapCondition","JSON","stringify","isInteger","Number","MAX_SAFE_INTEGER","_replaceFieldNameWithAlias","fieldName","substring","parts","split","actualFieldName","pop","InvalidArgument","_splitColumnsAsInput","data","v","_packArray","array","args","statement","query","specParamToken","inject","$in","hasOperator","find","k","typeCast","sqlInfo","specInClause","specNotInClause","columns","castArray","col","_buildColumn","isRawSql","extractRawSql","lastDotIndex","lastIndexOf","fullPath","aliasPrefix","omit","type","constructor","windowFunctions","has","over","windowableFunctions","funcClause","prefix","$partitionBy","_buildPartitionBy","endsWith","$nulls","expr","starsWith","ApplicationError","_buildGroupByColumn","groupBy","_buildGroupByList","by","having","havingCluse","partitionBy","orderBy","asc","app","driver","connectionString","relational"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}