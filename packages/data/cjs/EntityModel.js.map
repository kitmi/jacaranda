{"version":3,"sources":["../src/EntityModel.js"],"sourcesContent":["const { HttpCode, UnexpectedState, ValidationError, DatabaseError, InvalidArgument } = require('@genx/error');\nconst { _, eachAsync_ } = require('@genx/july');\nconst Generators = require('./Generators');\nconst Convertors = require('./Convertors');\nconst Types = require('./types');\nconst Features = require('./entityFeatures');\nconst Rules = require('./enum/Rules');\nconst { excludeColumn } = require('./drivers/mysql/mixin/excludeColumn');\n\nconst { isNothing, hasValueIn } = require('./utils/lang');\nconst JES = require('@genx/jes');\n\nconst NEED_OVERRIDE = 'Should be overrided by driver-specific subclass.';\n\nfunction minifyAssocs(assocs) {\n    const sorted = _.uniq(assocs).sort().reverse();\n\n    const minified = _.take(sorted, 1);\n    const l = sorted.length - 1;\n\n    for (let i = 1; i < l; i++) {\n        const k = sorted[i] + '.';\n\n        if (!_.find(minified, (a) => a.startsWith(k))) {\n            minified.push(sorted[i]);\n        }\n    }\n\n    return minified;\n}\n\nconst $xrsToBypass = new Set([\n    'ColumnReference',\n    'Function',\n    'BinaryExpression',\n    'DataSet',\n    'SQL',\n]);\n\n/**\n * Base entity model class.\n * @class\n */\nclass EntityModel {\n    /**\n     * @param {Object} [rawData] - Raw data object\n     */\n    constructor(rawData) {\n        if (rawData) {\n            // only pick those that are fields of this entity\n            Object.assign(this, rawData);\n        }\n    }\n\n    static valueOfKey(data) {\n        return data[this.meta.keyField];\n    }\n\n    // alias of fieldSchema, backward compatible with v1\n    static feildMeta(...args) {\n        return this.fieldSchema(...args);\n    }\n\n    /**\n     * Get a field schema based on the metadata of the field.\n     * @param {string} name - Field name\n     * @param {object} [extra] - Extra schema options\n     * @return {object|array} Schema object\n     */\n    static fieldSchema(name, extra) {\n        const meta = this.meta.fields[name];\n        if (!meta) {\n            throw new InvalidArgument(\n                `Unknown field \"${name}\" of entity \"${this.meta.name}\".`\n            );\n        }\n\n        const schema = _.omit(meta, ['default', 'optional']);\n\n        if (extra) {\n            const { $addEnumValues, $orAsArray, ...others } = extra;\n            let arrayElem = schema;\n\n            if ($orAsArray) {\n                arrayElem = { ...schema, ...others };\n            }\n\n            if (meta.type === Types.ENUM.name && $addEnumValues) {\n                schema.values = schema.values.concat($addEnumValues);\n            }\n\n            Object.assign(schema, others);\n\n            if ($orAsArray) {\n                return [\n                    schema,\n                    {\n                        type: 'array',\n                        elementSchema: arrayElem,\n                    },\n                ];\n            }\n        }\n\n        return schema;\n    }\n\n    /**\n     * Get a map of fields schema by predefined input set.\n     * @param {string} inputSetName - Input set name, predefined in geml\n     * @param {object} [options] - Input set options\n     * @return {object} Schema object\n     */\n    static inputSchema(inputSetName, options) {\n        const key =\n            inputSetName + (options == null ? '{}' : JSON.stringify(options));\n\n        if (this._cachedSchema) {\n            const cache = this._cachedSchema[key];\n            if (cache) {\n                return cache;\n            }\n        } else {\n            this._cachedSchema = {};\n        }\n\n        const schemaGenerator = this.db.require(\n            `inputs/${this.meta.name}-${inputSetName}`\n        );\n\n        return (this._cachedSchema[key] = schemaGenerator(options));\n    }\n\n    /**\n     * Helper to combine explicit required associations and associations required by query fields or projection fields.\n     * @param {*} extraArray \n     * @param {*} fields \n     * @returns {Array}\n     */\n    static assocFrom(extraArray, fields) {\n        const result = new Set(extraArray);\n\n        if (fields) {\n            fields.forEach(keyPath => {\n                const keyNodes = keyPath.split('.');\n                if (keyNodes.length > 1) {\n                    const assoc = keyNodes.slice(0, -1).map(p => p.startsWith(\":\") ? p.substring(1) : p).join('.');\n                    result.add(assoc);\n                }\n            })\n        }\n\n        return Array.from(result);\n    }\n\n    /**\n     * Get field names array of a unique key from input data.\n     * @param {object} data - Input data.\n     */\n    static getUniqueKeyFieldsFrom(data) {\n        return _.find(this.meta.uniqueKeys, (fields) =>\n            _.every(fields, (f) => !_.isNil(data[f]))\n        );\n    }\n\n    /**\n     * Get key-value pairs of a unique key from input data.\n     * @param {object} data - Input data.\n     */\n    static getUniqueKeyValuePairsFrom(data) {\n        const ukFields = this.getUniqueKeyFieldsFrom(data);\n        return _.pick(data, ukFields);\n    }\n\n    /**\n     * Get nested object of an entity.\n     * @param {*} entityObj\n     * @param {*} keyPath\n     */\n    static getNestedObject(entityObj, keyPath, defaultValue) {\n        const nodes = (\n            Array.isArray(keyPath) ? keyPath : keyPath.split('.')\n        ).map((key) => (key[0] === ':' ? key : ':' + key));\n        return _.get(entityObj, nodes, defaultValue);\n    }\n\n    /**\n     * Ensure the entity object containing required fields, if not, it will automatically fetched from db and return.\n     * @param {*} entityObj \n     * @param {Array} fields \n     * @param {*} connOpts \n     * @returns {Object}\n     */\n    static async ensureFields_(entityObj, fields, connOpts) {\n        if (_.find(fields, field => !_.has(entityObj, field))) {\n            const uk = this.getUniqueKeyValuePairsFrom(entityObj);\n\n            if (_.isEmpty(uk)) {\n                throw new UnexpectedState('None of the unique keys found from the data set.');\n            }\n\n            const findOptions = { $query: uk, /* $projection: fields,*/ $association: this.assocFrom(null, fields) };\n\n            return this.findOne_(findOptions, connOpts)\n        }\n\n        return entityObj;\n    }\n\n    /**\n     * Ensure context.latest be the just created entity.\n     * @param {*} context\n     * @param {*} customOptions\n     */\n    static ensureRetrieveCreated(context, customOptions) {\n        if (!context.options.$retrieveCreated) {\n            context.options.$retrieveCreated = customOptions || true;\n        }\n    }\n\n    /**\n     * Ensure context.latest be the just updated entity.\n     * @param {*} context\n     * @param {*} customOptions\n     */\n    static ensureRetrieveUpdated(context, customOptions) {\n        if (!context.options.$retrieveUpdated) {\n            context.options.$retrieveUpdated = customOptions || true;\n        }\n    }\n\n    /**\n     * Ensure context.exisintg be the just deleted entity.\n     * @param {*} context\n     * @param {*} customOptions\n     */\n    static ensureRetrieveDeleted(context, customOptions) {\n        if (!context.options.$retrieveDeleted) {\n            context.options.$retrieveDeleted = customOptions || true;\n        }\n    }\n\n    /**\n     * Ensure the upcoming operations are executed in a transaction.\n     * @param {*} context\n     */\n    static async ensureTransaction_(context) {\n        if (!context.connOptions || !context.connOptions.connection) {\n            context.connOptions || (context.connOptions = {});\n\n            context.connOptions.connection =\n                await this.db.connector.beginTransaction_();\n        }\n    }\n\n    /**\n     * Get value from context, e.g. session, query ...\n     * @param {*} context\n     * @param {string} key\n     * @returns {*}\n     */\n    static getValueFromContext(context, key) {\n        return _.get(context, 'options.$variables.' + key);\n    }\n\n    /**\n     * Get a pk-indexed hashtable with all undeleted data\n     * {string} [key] - The key field to used by the hashtable.\n     * {array} [associations] - With an array of associations.\n     * {object} [connOptions] - Connection options, e.g. transaction handle\n     */\n    static async cached_(key, associations, connOptions) {\n        if (key) {\n            let combinedKey = key;\n\n            if (!_.isEmpty(associations)) {\n                combinedKey += '/' + minifyAssocs(associations).join('&');\n            }\n\n            let cachedData;\n\n            if (!this._cachedData) {\n                this._cachedData = {};\n            } else if (this._cachedData[combinedKey]) {\n                cachedData = this._cachedData[combinedKey];\n            }\n\n            if (!cachedData) {\n                cachedData = this._cachedData[combinedKey] =\n                    await this.findAll_(\n                        { $association: associations, $toDictionary: key },\n                        connOptions\n                    );\n            }\n\n            return cachedData;\n        }\n\n        return this.cached_(this.meta.keyField, associations, connOptions);\n    }\n\n    static toDictionary(entityCollection, key, transformer) {\n        key || (key = this.meta.keyField);\n\n        return Convertors.toKVPairs(entityCollection, key, transformer);\n    }\n\n    /**\n     * Run aggregate pipeline\n     * @param {array} pipeline\n     * @param {object} [connOptions]\n     * @returns {*}\n     */\n    static async aggregate_(pipeline, connOptions) {\n        const _pipeline = pipeline.map(q => this._prepareQueries(q));\n\n        return this.db.connector.aggregate_(\n            this.meta.name,\n            _pipeline,\n            connOptions\n        );\n    }\n\n    /**\n     * Find one record, returns a model object containing the record or undefined if nothing found.     \n     * @param {object} [findOptions] - findOptions\n     * @property {object} [findOptions.$association] - Joinings\n     * @property {object} [findOptions.$projection] - Selected fields\n     * @property {object} [findOptions.$transformer] - Transform fields before returning\n     * @property {object} [findOptions.$query] - Extra condition\n     * @property {object} [findOptions.$groupBy] - Group by fields\n     * @property {object} [findOptions.$orderBy] - Order by fields\n     * @property {number} [findOptions.$offset] - Offset\n     * @property {number} [findOptions.$limit] - Limit\n     * @property {bool} [findOptions.$includeDeleted=false] - Include those marked as logical deleted.\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     * @returns {*}\n     */\n    static async findOne_(findOptions, connOptions) {\n        const rawOptions = findOptions;\n\n        findOptions = this._prepareQueries(\n            findOptions,\n            true /* for single record */\n        );\n\n        const context = {\n            op: 'find',\n            options: findOptions,\n            connOptions,\n        };\n\n        await Features.applyRules_(Rules.RULE_BEFORE_FIND, this, context);\n\n        const result = await this._safeExecute_(async (context) => {\n            let records = await this.db.connector.find_(\n                this.meta.name,\n                context.options,\n                context.connOptions\n            );\n            if (!records)\n                throw new DatabaseError(\n                    'connector.find_() returns undefined data record.'\n                );\n\n            if (rawOptions && rawOptions.$retrieveDbResult) {\n                rawOptions.$result = records.slice(1);\n            }\n\n            if (findOptions.$relationships && !findOptions.$skipOrm) {\n                // rows, coloumns, aliasMap\n                if (records[0].length === 0) return undefined;\n\n                records = this._mapRecordsToObjects(\n                    records,\n                    findOptions.$relationships,\n                    findOptions.$nestedKeyGetter\n                );\n            } else if (records.length === 0) {\n                return undefined;\n            }\n\n            if (records.length !== 1) {\n                this.db.connector.log(\n                    'error',\n                    `findOne() returns more than one record.`,\n                    { entity: this.meta.name, options: context.options }\n                );\n            }\n\n            const result = records[0];\n\n            return result;\n        }, context);\n\n        if (findOptions.$transformer) {\n            return JES.evaluate(result, findOptions.$transformer);\n        }\n\n        return result;\n    }\n\n    /**\n     * Find records matching the condition, returns an array of records.\n     * @param {object} [findOptions] - findOptions\n     * @property {object} [findOptions.$association] - Joinings\n     * @property {object} [findOptions.$projection] - Selected fields\n     * @property {object} [findOptions.$transformer] - Transform fields before returning\n     * @property {object} [findOptions.$query] - Extra condition\n     * @property {object} [findOptions.$groupBy] - Group by fields\n     * @property {object} [findOptions.$orderBy] - Order by fields\n     * @property {number} [findOptions.$offset] - Offset\n     * @property {number} [findOptions.$limit] - Limit\n     * @property {number} [findOptions.$totalCount] - Return totalCount\n     * @property {bool} [findOptions.$includeDeleted=false] - Include those marked as logical deleted.\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     * @returns {array}\n     */\n    static async findAll_(findOptions, connOptions) {\n        const rawOptions = findOptions;\n\n        findOptions = this._prepareQueries(findOptions);\n\n        const context = {\n            op: 'find',\n            options: findOptions,\n            connOptions,\n        };\n\n        await Features.applyRules_(Rules.RULE_BEFORE_FIND, this, context);\n\n        let totalCount;\n        \n        let rows = await this._safeExecute_(async (context) => {\n            let records = await this.db.connector.find_(\n                this.meta.name,\n                context.options,\n                context.connOptions\n            );\n\n            if (!records)\n                throw new DatabaseError(\n                    'connector.find_() returns undefined data record.'\n                );\n\n            if (rawOptions && rawOptions.$retrieveDbResult) {\n                rawOptions.$result = records.slice(1);\n            }\n\n            if (findOptions.$relationships) {\n                if (findOptions.$totalCount) {\n                    totalCount = records[3];\n                }\n\n                if (!findOptions.$skipOrm) {\n                    records = this._mapRecordsToObjects(\n                        records,\n                        findOptions.$relationships,\n                        findOptions.$nestedKeyGetter\n                    );\n                } else {\n                    records = records[0];\n                }\n            } else {\n                if (findOptions.$totalCount) {\n                    totalCount = records[1];\n                    records = records[0];\n                } else if (findOptions.$skipOrm) {\n                    records = records[0];\n                }\n            }\n\n            return this.afterFindAll_(context, records);\n        }, context);\n\n        if (findOptions.$transformer) {\n            rows = rows.map((row) =>\n                JES.evaluate(row, findOptions.$transformer)\n            );\n        }\n\n        if (findOptions.$totalCount) {\n            const ret = { totalItems: totalCount, items: rows };\n\n            if (!isNothing(findOptions.$offset)) {\n                ret.offset = findOptions.$offset;\n            }\n\n            if (!isNothing(findOptions.$limit)) {\n                ret.limit = findOptions.$limit;\n            }\n\n            return ret;\n        }\n\n        return rows;\n    }\n\n    /**\n     * Regenerate creation data and try again if duplicate record exists\n     * @param {Function} dataGenerator_\n     * @param {Object} connOptions\n     */\n    static async retryCreateOnDuplicate_(\n        dataGenerator_,\n        maxRery,\n        createOptions,\n        connOptions\n    ) {\n        let counter = 0;\n        let errorRet;\n        maxRery || (maxRery = 10);\n\n        while (counter++ < maxRery) {\n            const data = await dataGenerator_();\n\n            try {\n                return await this.create_(data, createOptions, connOptions);\n            } catch (error) {\n                if (error.code !== 'E_DUPLICATE') {\n                    throw error;\n                }\n\n                errorRet = error;\n            }\n        }\n\n        return errorRet;\n    }\n\n    /**\n     * Create a new entity with given data.\n     * @param {object} data - Entity data\n     * @param {object} [createOptions] - Create options\n     * @property {bool} [createOptions.$retrieveCreated=false] - Retrieve the newly created record from db.\n     * @property {bool} [createOptions.$upsert=false] - If already exist, just update the record.\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     * @returns {EntityModel}\n     */\n    static async create_(data, createOptions, connOptions) {\n        const rawOptions = createOptions;\n\n        if (!createOptions) {\n            createOptions = {};\n        }\n\n        let [raw, associations, references] = this._extractAssociations(\n            data,\n            true\n        );\n\n        const context = {\n            op: 'create',\n            raw,\n            rawOptions,\n            options: createOptions,\n            connOptions,\n        };\n\n        if (!(await this.beforeCreate_(context))) {\n            return context.return;\n        }\n\n        const success = await this._safeExecute_(async (context) => {\n            if (!_.isEmpty(references)) {\n                await this.ensureTransaction_(context);\n                await this._populateReferences_(context, references);\n            }\n\n            let needCreateAssocs = !_.isEmpty(associations);\n            if (needCreateAssocs) {\n                await this.ensureTransaction_(context);\n\n                associations = await this._createAssocs_(\n                    context,\n                    associations,\n                    true /* before create */\n                );\n                // check any other associations left\n                needCreateAssocs = !_.isEmpty(associations);\n            }\n\n            await this._prepareEntityData_(context);\n\n            if (\n                !(await Features.applyRules_(\n                    Rules.RULE_BEFORE_CREATE,\n                    this,\n                    context\n                ))\n            ) {\n                return false;\n            }\n\n            if (!(await this._internalBeforeCreate_(context))) {\n                return false;\n            }\n\n            if (!context.options.$dryRun) {\n                if (context.options.$upsert) {\n                    const dataForUpdating = _.pick(context.latest, Object.keys(context.raw)); // only update the raw part    \n\n                    context.result = await this.db.connector.upsertOne_(\n                        this.meta.name,\n                        dataForUpdating,\n                        this.getUniqueKeyFieldsFrom(context.latest),\n                        context.connOptions,\n                        context.latest\n                    );\n                } else {\n                    context.result = await this.db.connector.create_(\n                        this.meta.name,\n                        context.latest,\n                        context.connOptions\n                    );\n                }\n\n                this._fillResult(context);\n            } else {\n                context.return = context.latest;\n                context.result = { insertId: context.latest[this.meta.keyField], affectedRows: 1 };\n            }\n\n            if (needCreateAssocs) {\n                await this._createAssocs_(context, associations);\n            }\n\n            await this._internalAfterCreate_(context);\n\n            if (!context.queryKey) {\n                context.queryKey = this.getUniqueKeyValuePairsFrom(\n                    context.latest\n                );\n            }\n\n            await Features.applyRules_(Rules.RULE_AFTER_CREATE, this, context);\n\n            return true;\n        }, context);\n\n        if (success && !context.options.$dryRun) {\n            await this.afterCreate_(context);\n        }\n\n        return context.return;\n    }\n\n    /**\n     * Update an existing entity with given data.\n     * @param {object} data - Entity data with at least one unique key (pair) given\n     * @param {object} [updateOptions] - Update options\n     * @property {object} [updateOptions.$query] - Extra condition\n     * @property {bool} [updateOptions.$retrieveUpdated=false] - Retrieve the updated entity from database\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     * @returns {object}\n     */\n    static async updateOne_(data, updateOptions, connOptions) {\n        return this._update_(data, updateOptions, connOptions, true);\n    }\n\n    /**\n     * Update many existing entites with given data.\n     * @param {*} data\n     * @param {*} updateOptions\n     * @param {*} connOptions\n     */\n    static async updateMany_(data, updateOptions, connOptions) {\n        return this._update_(data, updateOptions, connOptions, false);\n    }\n\n    static async _update_(data, updateOptions, connOptions, forSingleRecord) {\n        const rawOptions = updateOptions;\n\n        if (!updateOptions) {\n            // if no condition given, extract from data\n            const conditionFields = this.getUniqueKeyFieldsFrom(data);\n            if (_.isEmpty(conditionFields)) {\n                throw new InvalidArgument(\n                    'Primary key value(s) or at least one group of unique key value(s) is required for updating an entity.',\n                    {\n                        entity: this.meta.name,\n                        data,\n                    }\n                );\n            }\n            updateOptions = { $query: _.pick(data, conditionFields) };\n            data = _.omit(data, conditionFields);\n        }\n\n        // see if there is associated entity data provided together\n        let [raw, associations, references] = this._extractAssociations(data);\n\n        const context = {\n            op: 'update',\n            raw,\n            rawOptions,\n            options: this._prepareQueries(\n                updateOptions,\n                forSingleRecord /* for single record */\n            ),\n            connOptions,\n            forSingleRecord,\n        };\n\n        // see if there is any runtime feature stopping the update\n        let toUpdate;\n\n        if (forSingleRecord) {\n            toUpdate = await this.beforeUpdate_(context);\n        } else {\n            toUpdate = await this.beforeUpdateMany_(context);\n        }\n\n        if (!toUpdate) {\n            return context.return;\n        }\n\n        const success = await this._safeExecute_(async (context) => {\n            if (!_.isEmpty(references)) {\n                await this.ensureTransaction_(context);\n                await this._populateReferences_(context, references);\n            }\n\n            let needUpdateAssocs = !_.isEmpty(associations);\n            let doneUpdateAssocs;\n\n            if (needUpdateAssocs) {\n                await this.ensureTransaction_(context);\n\n                associations = await this._updateAssocs_(\n                    context,\n                    associations,\n                    true /* before update */,\n                    forSingleRecord\n                );\n                needUpdateAssocs = !_.isEmpty(associations);\n                doneUpdateAssocs = true;\n            }\n\n            await this._prepareEntityData_(\n                context,\n                true /* is updating */,\n                forSingleRecord\n            );\n\n            if (\n                !(await Features.applyRules_(\n                    Rules.RULE_BEFORE_UPDATE,\n                    this,\n                    context\n                ))\n            ) {\n                return false;\n            }\n\n            if (forSingleRecord) {\n                toUpdate = await this._internalBeforeUpdate_(context);\n            } else {\n                toUpdate = await this._internalBeforeUpdateMany_(context);\n            }\n\n            if (!toUpdate) {\n                return false;\n            }\n\n            const { $query, ...otherOptions } = context.options;\n\n            if (_.isEmpty(context.latest)) {\n                if (!doneUpdateAssocs && !needUpdateAssocs) {\n                    throw new InvalidArgument(\n                        'Cannot do the update with empty record. Entity: ' +\n                        this.meta.name\n                    );\n                }\n            } else {\n                if (\n                    needUpdateAssocs &&\n                    !hasValueIn([$query, context.latest], this.meta.keyField) &&\n                    !otherOptions.$retrieveUpdated\n                ) {\n                    // has associated data depending on this record\n                    // should ensure the latest result will contain the key of this record\n                    otherOptions.$retrieveUpdated = true;\n                }\n\n                if (forSingleRecord && !otherOptions.$limit) {\n                    otherOptions.$limit = 1;\n                }\n\n                context.result = await this.db.connector.update_(\n                    this.meta.name,\n                    context.latest,\n                    $query,\n                    otherOptions,\n                    context.connOptions\n                );\n\n                context.return = context.latest;\n            }\n\n            if (forSingleRecord) {\n                await this._internalAfterUpdate_(context);\n\n                if (!context.queryKey) {\n                    context.queryKey = this.getUniqueKeyValuePairsFrom($query);\n                }\n            } else {\n                await this._internalAfterUpdateMany_(context);\n            }\n\n            await Features.applyRules_(Rules.RULE_AFTER_UPDATE, this, context);\n\n            if (needUpdateAssocs) {\n                await this._updateAssocs_(\n                    context,\n                    associations,\n                    false,\n                    forSingleRecord\n                );\n            }\n\n            return true;\n        }, context);\n\n        if (success && !context.options.$dryRun) {\n            if (forSingleRecord) {\n                await this.afterUpdate_(context);\n            } else {\n                await this.afterUpdateMany_(context);\n            }\n        }\n\n        return context.return;\n    }\n\n    /**\n     * Update an existing entity with given data, or create one if not found.\n     * @param {*} data\n     * @param {*} updateOptions\n     * @param {*} connOptions\n     */\n    static async replaceOne_(data, updateOptions, connOptions) {\n        const rawOptions = updateOptions;\n\n        if (!updateOptions) {\n            const conditionFields = this.getUniqueKeyFieldsFrom(data);\n            if (_.isEmpty(conditionFields)) {\n                throw new InvalidArgument(\n                    'Primary key value(s) or at least one group of unique key value(s) is required for replacing an entity.',\n                    {\n                        entity: this.meta.name,\n                        data,\n                    }\n                );\n            }\n\n            updateOptions = {\n                ...updateOptions,\n                $query: _.pick(data, conditionFields),\n            };\n        } else {\n            updateOptions = this._prepareQueries(updateOptions, true);\n        }\n\n        const context = {\n            op: 'replace',\n            raw: data,\n            rawOptions,\n            options: updateOptions,\n            connOptions,\n        };\n\n        return this._safeExecute_(async (context) => {\n            return this._doReplaceOne_(context); // different dbms has different replacing strategy\n        }, context);\n    }\n\n    /**\n     * Remove an existing entity with given data.\n     * @param {object} [deleteOptions] - Update options\n     * @property {object} [deleteOptions.$query] - Extra condition\n     * @property {bool} [deleteOptions.$retrieveDeleted=false] - Retrieve the deleted entity from database\n     * @property {bool} [deleteOptions.$physicalDeletion=false] - When $physicalDeletion = true, deletetion will not take into account logicaldeletion feature\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     */\n    static async deleteOne_(deleteOptions, connOptions) {\n        return this._delete_(deleteOptions, connOptions, true);\n    }\n\n    /**\n     * Remove an existing entity with given data.\n     * @param {object} [deleteOptions] - Update options\n     * @property {object} [deleteOptions.$query] - Extra condition\n     * @property {bool} [deleteOptions.$retrieveDeleted=false] - Retrieve the deleted entity from database\n     * @property {bool} [deleteOptions.$physicalDeletion=false] - When $physicalDeletion = true, deletetion will not take into account logicaldeletion feature\n     * @property {bool} [deleteOptions.$deleteAll=false] - When $deleteAll = true, the operation will proceed even empty condition is given\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     */\n    static async deleteMany_(deleteOptions, connOptions) {\n        return this._delete_(deleteOptions, connOptions, false);\n    }\n\n    static async deleteAll_(connOptions) {\n        return this.deleteMany_({ $deleteAll: true }, connOptions);\n    }\n\n    /**\n     * Remove an existing entity with given data.\n     * @param {object} [deleteOptions] - Update options\n     * @property {object} [deleteOptions.$query] - Extra condition\n     * @property {bool} [deleteOptions.$retrieveDeleted=false] - Retrieve the deleted entity from database\n     * @property {bool} [deleteOptions.$physicalDeletion=false] - When $physicalDeletion = true, deletetion will not take into account logicaldeletion feature\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     */\n    static async _delete_(deleteOptions, connOptions, forSingleRecord) {\n        const rawOptions = deleteOptions;\n\n        deleteOptions = this._prepareQueries(\n            deleteOptions,\n            forSingleRecord /* for single record */\n        );\n\n        if (\n            _.isEmpty(deleteOptions.$query) &&\n            (forSingleRecord || !deleteOptions.$deleteAll)\n        ) {\n            throw new InvalidArgument(\n                'Empty condition is not allowed for deleting or add { $deleteAll: true } to delete all records.',\n                {\n                    entity: this.meta.name,\n                    deleteOptions,\n                }\n            );\n        }\n\n        const context = {\n            op: 'delete',\n            rawOptions,\n            options: deleteOptions,\n            connOptions,\n            forSingleRecord,\n        };\n\n        let toDelete;\n\n        if (forSingleRecord) {\n            toDelete = await this.beforeDelete_(context);\n        } else {\n            toDelete = await this.beforeDeleteMany_(context);\n        }\n\n        if (!toDelete) {\n            return context.return;\n        }\n\n        const deletedCount = await this._safeExecute_(async (context) => {\n            if (\n                !(await Features.applyRules_(\n                    Rules.RULE_BEFORE_DELETE,\n                    this,\n                    context\n                ))\n            ) {\n                return false;\n            }\n\n            if (forSingleRecord) {\n                toDelete = await this._internalBeforeDelete_(context);\n            } else {\n                toDelete = await this._internalBeforeDeleteMany_(context);\n            }\n\n            if (!toDelete) {\n                return false;\n            }\n\n            const { $query, ...otherOptions } = context.options;\n\n            context.result = await this.db.connector.delete_(\n                this.meta.name,\n                $query,\n                otherOptions,\n                context.connOptions\n            );\n\n            if (forSingleRecord) {\n                await this._internalAfterDelete_(context);\n            } else {\n                await this._internalAfterDeleteMany_(context);\n            }\n\n            if (!context.queryKey) {\n                if (forSingleRecord) {\n                    context.queryKey = this.getUniqueKeyValuePairsFrom(\n                        context.options.$query\n                    );\n                } else {\n                    context.queryKey = context.options.$query;\n                }\n            }\n\n            await Features.applyRules_(Rules.RULE_AFTER_DELETE, this, context);\n\n            return this.db.connector.deletedCount(context);\n        }, context);\n\n        if (deletedCount && !context.options.$dryRun) {\n            if (forSingleRecord) {\n                await this.afterDelete_(context);\n            } else {\n                await this.afterDeleteMany_(context);\n            }\n        }\n\n        return context.return || deletedCount;\n    }\n\n    /**\n     * Check whether a data record contains primary key or at least one unique key pair.\n     * @param {object} data\n     */\n    static _containsUniqueKey(data) {\n        let hasKeyNameOnly = false;\n\n        const hasNotNullKey = _.find(this.meta.uniqueKeys, (fields) => {\n            const hasKeys = _.every(fields, (f) => f in data);\n            hasKeyNameOnly = hasKeyNameOnly || hasKeys;\n\n            return _.every(fields, (f) => !_.isNil(data[f]));\n        });\n\n        return [hasNotNullKey, hasKeyNameOnly];\n    }\n\n    /**\n     * Ensure the condition contains one of the unique keys.\n     * @param {*} condition\n     */\n    static _ensureContainsUniqueKey(condition) {\n        const [containsUniqueKeyAndValue, containsUniqueKeyOnly] =\n            this._containsUniqueKey(condition);\n\n        if (!containsUniqueKeyAndValue) {\n            if (containsUniqueKeyOnly) {\n                throw new ValidationError(\n                    'One of the unique key field as query condition is null. Condition: ' +\n                    JSON.stringify(condition)\n                );\n            }\n\n            throw new InvalidArgument(\n                'Single record operation requires at least one unique key value pair in the query condition.',\n                {\n                    entity: this.meta.name,\n                    condition,\n                }\n            );\n        }\n    }\n\n    /**\n     * Prepare valid and sanitized entity data for sending to database.\n     * @param {object} context - Operation context.\n     * @property {object} context.raw - Raw input data.\n     * @property {object} [context.connOptions]\n     * @param {bool} isUpdating - Flag for updating existing entity.\n     */\n    static async _prepareEntityData_(\n        context,\n        isUpdating = false,\n        forSingleRecord = true\n    ) {\n        const meta = this.meta;\n        const i18n = this.i18n;\n        const { name, fields } = meta;\n\n        let { raw } = context;\n        let latest = {};\n        // returned by $retrieveExisting\n        let existing = context.options.$existing;\n        context.latest = latest;\n\n        if (!context.i18n) {\n            context.i18n = i18n;\n        }\n\n        const opOptions = context.options;\n\n        if (opOptions.$upsert && typeof opOptions.$upsert === 'object') {\n            raw = { ...raw, ...opOptions.$upsert };\n        }\n\n        if (\n            isUpdating &&\n            _.isEmpty(existing) &&\n            (this._dependsOnExistingData(raw) || opOptions.$retrieveExisting)\n        ) {\n            await this.ensureTransaction_(context);\n\n            if (forSingleRecord) {\n                existing = await this.findOne_(\n                    { $query: opOptions.$query },\n                    context.connOptions\n                );\n            } else {\n                existing = await this.findAll_(\n                    { $query: opOptions.$query },\n                    context.connOptions\n                );\n            }\n            context.existing = existing;\n        }\n\n        if (opOptions.$retrieveExisting && !context.rawOptions.$existing) {\n            context.rawOptions.$existing = existing;\n        }\n\n        await Features.applyRules_(Rules.RULE_BEFORE_VALIDATION, this, context);\n\n        await eachAsync_(fields, async (fieldInfo, fieldName) => {\n            let value;\n            let useRaw = false;\n\n            if (fieldName in raw) {\n                value = raw[fieldName];\n                useRaw = true;\n            } else if (fieldName in latest) {\n                value = latest[fieldName];\n            }\n\n            if (typeof value !== 'undefined') {\n                // field value given in raw data\n                if (fieldInfo.readOnly && useRaw) {\n                    if (\n                        !opOptions.$migration &&\n                        (!opOptions.$bypassReadOnly ||\n                            !opOptions.$bypassReadOnly.has(fieldName))\n                    ) {\n                        // read only, not allow to set by input value\n                        throw new ValidationError(\n                            `Read-only field \"${fieldName}\" is not allowed to be set by manual input.`,\n                            {\n                                entity: name,\n                                fieldInfo: fieldInfo,\n                            }\n                        );\n                    }\n                }\n\n                if (isUpdating && fieldInfo.freezeAfterNonDefault) {\n                    if (!existing) {\n                        throw new Error(\n                            '\"freezeAfterNonDefault\" qualifier requires existing data.'\n                        );\n                    }\n\n                    if (existing[fieldName] !== fieldInfo.default) {\n                        // freezeAfterNonDefault, not allow to change if value is non-default\n                        throw new ValidationError(\n                            `FreezeAfterNonDefault field \"${fieldName}\" is not allowed to be changed.`,\n                            {\n                                entity: name,\n                                fieldInfo: fieldInfo,\n                            }\n                        );\n                    }\n                }\n\n                /**  todo: fix dependency, check writeProtect \n                if (isUpdating && fieldInfo.writeOnce) {     \n                    assert: existing, '\"writeOnce\" qualifier requires existing data.';\n                    if (!_.isNil(existing[fieldName])) {\n                        throw new ValidationError(`Write-once field \"${fieldName}\" is not allowed to be update once it was set.`, {\n                            entity: name,\n                            fieldInfo: fieldInfo \n                        });\n                    }\n                } */\n\n                // sanitize first\n                if (isNothing(value)) {\n                    if (fieldInfo.default) {\n                        // has default setting in meta data\n                        latest[fieldName] = fieldInfo.default;\n                    } else if (!fieldInfo.optional) {\n                        throw new ValidationError(\n                            `The \"${fieldName}\" value of \"${name}\" entity cannot be null.`,\n                            {\n                                entity: name,\n                                fieldInfo: fieldInfo,\n                            }\n                        );\n                    } else {\n                        latest[fieldName] = null;\n                    }\n                } else {\n                    if (_.isPlainObject(value) && value.$xr) {\n                        latest[fieldName] = value;\n\n                        return;\n                    }\n\n                    try {\n                        latest[fieldName] = Types.sanitize(\n                            value,\n                            fieldInfo,\n                            i18n\n                        );\n                    } catch (error) {\n                        throw new ValidationError(\n                            `Invalid \"${fieldName}\" value of \"${name}\" entity.`,\n                            {\n                                entity: name,\n                                fieldInfo: fieldInfo,\n                                value,\n                                error: error.stack,\n                            }\n                        );\n                    }\n                }\n\n                return;\n            }\n\n            // not given in raw data\n            if (isUpdating) {\n                if (fieldInfo.forceUpdate) {\n                    // has force update policy, e.g. updateTimestamp\n                    if (fieldInfo.updateByDb || fieldInfo.hasActivator) {\n                        return;\n                    }\n\n                    // require generator to refresh auto generated value\n                    if (fieldInfo.auto) {\n                        latest[fieldName] = await Generators.default(\n                            fieldInfo,\n                            i18n\n                        );\n                        return;\n                    }\n\n                    throw new ValidationError(\n                        `Field \"${fieldName}\" of \"${name}\" entity is required for each update.`,\n                        {\n                            entity: name,\n                            fieldInfo: fieldInfo,\n                        }\n                    );\n                }\n\n                return;\n            }\n\n            // new record\n            if (!fieldInfo.createByDb) {\n                if ('default' in fieldInfo) {\n                    // has default setting in meta data\n                    latest[fieldName] = fieldInfo.default;\n                } else if (fieldInfo.optional) {\n                    // ignore\n                } else if (fieldInfo.auto) {\n                    // automatically generated\n                    latest[fieldName] = await Generators.default(\n                        fieldInfo,\n                        i18n\n                    );\n                } else if (!fieldInfo.hasActivator) {\n                    // skip those have activators\n\n                    throw new ValidationError(\n                        `Field \"${fieldName}\" of \"${name}\" entity is required.`,\n                        {\n                            entity: name,\n                            fieldInfo: fieldInfo,\n                            raw,\n                        }\n                    );\n                }\n            } // else default value set by database or by rules\n        });\n\n        latest = context.latest = this._translateValue(\n            latest,\n            opOptions.$variables,\n            true\n        );\n\n        await Features.applyRules_(Rules.RULE_AFTER_VALIDATION, this, context);\n\n        if (!opOptions.$skipModifiers) {\n            await this.applyModifiers_(context, isUpdating);\n        }\n\n        // final round process before entering database\n        context.latest = _.mapValues(latest, (value, key) => {\n            if (value == null) return value;\n\n            if (_.isPlainObject(value) && value.$xr) {\n                // there is special input column which maybe a function or an expression\n                opOptions.$requireSplitColumns = true;\n                return value;\n            }\n\n            const fieldInfo = fields[key];\n\n            return this._serializeByTypeInfo(value, fieldInfo);\n        });\n\n        return context;\n    }\n\n    /**\n     * Ensure commit or rollback is called if transaction is created within the executor.\n     * @param {*} executor\n     * @param {*} context\n     */\n    static async _safeExecute_(executor, context) {\n        executor = executor.bind(this);\n\n        if (context.connOptions && context.connOptions.connection) {\n            return executor(context);\n        }\n\n        try {\n            const result = await executor(context);\n\n            // if the executor have initiated a transaction\n            if (context.connOptions && context.connOptions.connection) {\n                await this.db.connector.commit_(context.connOptions.connection);\n                delete context.connOptions.connection;\n            }\n\n            return result;\n        } catch (error) {\n            // we have to rollback if error occurred in a transaction\n            if (context.connOptions && context.connOptions.connection) {\n                this.db.connector.log(\n                    'error',\n                    `Rollbacked, reason: ${error.message}`,\n                    {\n                        entity: this.meta.name,\n                        context: context.options,\n                        rawData: context.raw,\n                        latestData: context.latest,\n                    }\n                );\n                await this.db.connector.rollback_(\n                    context.connOptions.connection\n                );\n                delete context.connOptions.connection;\n            }\n\n            throw error;\n        }\n    }\n\n    static _dependencyChanged(fieldName, context) {\n        if (this.meta.fieldDependencies) {\n            const deps = this.meta.fieldDependencies[fieldName];\n\n            return _.find(deps, (d) =>\n                _.isPlainObject(d)\n                    ? (d.reference !== fieldName && _.hasIn(context, d.reference))\n                    : _.hasIn(context, d)\n            );\n        }\n\n        return false;\n    }\n\n    static _referenceExist(input, ref) {\n        const pos = ref.indexOf('.');\n\n        if (pos > 0) {\n            return ref.substr(pos + 1) in input;\n        }\n\n        return ref in input;\n    }\n\n    static _dependsOnExistingData(input) {\n        // check modifier dependencies\n        const deps = this.meta.fieldDependencies;\n        let hasDepends = false;\n\n        if (deps) {\n            const nullDepends = new Set();\n\n            hasDepends = _.find(deps, (dep, fieldName) =>\n                _.find(dep, (d) => {\n                    if (_.isPlainObject(d)) {\n                        if (d.whenNull) {\n                            if (_.isNil(input[fieldName])) {\n                                nullDepends.add(dep);\n                            }\n\n                            return false;\n                        }\n\n                        if (d.reference === fieldName) return false;\n\n                        d = d.reference;\n                    }\n\n                    return (\n                        fieldName in input && !this._referenceExist(input, d)\n                    ) || (this._referenceExist(input, d) && !(fieldName in input));\n                })\n            );\n\n            if (hasDepends) {\n                return true;\n            }\n\n            for (const dep of nullDepends) {\n                if (\n                    _.find(\n                        dep,\n                        (d) => !this._referenceExist(input, d.reference)\n                    )\n                ) {\n                    return true;\n                }\n            }\n        }\n\n        // check by special rules\n        const atLeastOneNotNull = this.meta.features.atLeastOneNotNull;\n        if (atLeastOneNotNull) {\n            hasDepends = _.find(atLeastOneNotNull, (fields) =>\n                _.find(\n                    fields,\n                    (field) => field in input && _.isNil(input[field])\n                )\n            );\n            if (hasDepends) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    static _hasReservedKeys(obj) {\n        return _.find(obj, (v, k) => k[0] === '$');\n    }\n\n    /**\n     * Normalize options including moving entries with key not starting with '$' into $query, interpolating variables and building relationship structure.\n     * @param {object} options \n     * @param {boolean} [forSingleRecord=false]\n     * @returns {object}\n     */\n    static _prepareQueries(options, forSingleRecord = false) {\n        excludeColumn(this, this.meta, options);\n\n        if (!_.isPlainObject(options)) {\n            if (forSingleRecord && Array.isArray(this.meta.keyField)) {\n                throw new InvalidArgument(\n                    'Cannot use a singular value as condition to query against an entity with combined primary key.',\n                    {\n                        entity: this.meta.name,\n                        keyFields: this.meta.keyField,\n                    }\n                );\n            }\n\n            return options\n                ? {\n                    $query: {\n                        [this.meta.keyField]: this._translateValue(options),\n                    },\n                }\n                : {};\n        }\n\n        const normalizedOptions = { $key: this.meta.keyField };\n        const query = {};\n\n        _.forOwn(options, (v, k) => {\n            if (k[0] === '$') {\n                normalizedOptions[k] = v;\n            } else {\n                query[k] = v;\n            }\n        });\n\n        normalizedOptions.$query = { ...query, ...normalizedOptions.$query };\n\n        if (forSingleRecord && !options.$bypassEnsureUnique) {\n            this._ensureContainsUniqueKey(normalizedOptions.$query);\n        }\n\n        normalizedOptions.$query = this._translateValue(\n            normalizedOptions.$query,\n            normalizedOptions.$variables,\n            null,\n            true\n        );\n\n        if (normalizedOptions.$groupBy) {\n            if (_.isPlainObject(normalizedOptions.$groupBy)) {\n                if (normalizedOptions.$groupBy.having) {\n                    normalizedOptions.$groupBy.having = this._translateValue(\n                        normalizedOptions.$groupBy.having,\n                        normalizedOptions.$variables\n                    );\n                }\n            }\n        }\n\n        if (normalizedOptions.$projection) {\n            normalizedOptions.$projection = this._translateValue(\n                normalizedOptions.$projection,\n                normalizedOptions.$variables\n            );\n        }\n\n        if (\n            normalizedOptions.$association &&\n            !normalizedOptions.$relationships\n        ) {\n            normalizedOptions.$relationships =\n                this._prepareAssociations(normalizedOptions);\n        }\n\n        return normalizedOptions;\n    }\n\n    /**\n     * Pre create processing, return false to stop upcoming operation.\n     * @param {*} context\n     */\n    static async beforeCreate_(context) {\n        return true;\n    }\n\n    /**\n     * Pre update processing, return false to stop upcoming operation.\n     * @param {*} context\n     */\n    static async beforeUpdate_(context) {\n        return true;\n    }\n\n    /**\n     * Pre update processing, multiple records, return false to stop upcoming operation.\n     * @param {*} context\n     */\n    static async beforeUpdateMany_(context) {\n        return true;\n    }\n\n    /**\n     * Pre delete processing, return false to stop upcoming operation.\n     * @param {*} context\n     */\n    static async beforeDelete_(context) {\n        return true;\n    }\n\n    /**\n     * Pre delete processing, multiple records, return false to stop upcoming operation.\n     * @param {*} context\n     */\n    static async beforeDeleteMany_(context) {\n        return true;\n    }\n\n    /**\n     * Post create processing.\n     * @param {*} context\n     */\n    static async afterCreate_(context) {}\n\n    /**\n     * Post update processing.\n     * @param {*} context\n     */\n    static async afterUpdate_(context) {}\n\n    /**\n     * Post update processing, multiple records\n     * @param {*} context\n     */\n    static async afterUpdateMany_(context) {}\n\n    /**\n     * Post delete processing.\n     * @param {*} context\n     */\n    static async afterDelete_(context) {}\n\n    /**\n     * Post delete processing, multiple records\n     * @param {*} context\n     */\n    static async afterDeleteMany_(context) {}\n\n    /**\n     * Post findAll processing\n     * @param {*} context\n     * @param {*} records\n     */\n    static async afterFindAll_(context, records) {\n        if (context.options.$toDictionary) {\n            let keyField = this.meta.keyField;\n\n            if (typeof context.options.$toDictionary === 'string') {\n                keyField = context.options.$toDictionary;\n\n                if (!(keyField in this.meta.fields)) {\n                    throw new InvalidArgument(\n                        `The key field \"${keyField}\" provided to index the cached dictionary is not a field of entity \"${this.meta.name}\".`,\n                        {\n                            entity: this.meta.name,\n                            inputKeyField: keyField,\n                        }\n                    );\n                }\n            }\n\n            return this.toDictionary(records, keyField);\n        }\n\n        return records;\n    }\n\n    static _prepareAssociations() {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static _mapRecordsToObjects() {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static _extractAssociations(data) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    // will update context.raw if applicable\n    static async _populateReferences_(context, references) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    // will update context.raw if applicable\n    static async _createAssocs_(context, assocs) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static async _updateAssocs_(context, assocs) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static _translateSymbolToken(name) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static _serializeByTypeInfo(value, info) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static _translateValue(value, variables, skipTypeCast, arrayToInOperator) {\n        if (_.isPlainObject(value)) {\n            if (value.$xr) {\n                if ($xrsToBypass.has(value.$xr)) return value;\n\n                if (value.$xr === 'SessionVariable') {\n                    if (!variables) {\n                        throw new InvalidArgument(\n                            'Variables context missing.',\n                            {\n                                entity: this.meta.name,\n                            }\n                        );\n                    }\n\n                    if (\n                        (!variables.session ||\n                            !(value.name in variables.session)) &&\n                        !value.optional\n                    ) {\n                        const errArgs = [];\n                        if (value.missingMessage) {\n                            errArgs.push(value.missingMessage);\n                        }\n                        if (value.missingStatus) {\n                            errArgs.push(\n                                value.missingStatus || HttpCode.BAD_REQUEST\n                            );\n                        }\n\n                        throw new ValidationError(...errArgs);\n                    }\n\n                    return variables.session[value.name];\n                } else if (value.$xr === 'QueryVariable') {\n                    if (!variables) {\n                        throw new InvalidArgument(\n                            'Variables context missing.',\n                            {\n                                entity: this.meta.name,\n                            }\n                        );\n                    }\n\n                    if (!variables.query || !(value.name in variables.query)) {\n                        throw new InvalidArgument(\n                            `Query parameter \"${value.name}\" in configuration not found.`,\n                            {\n                                entity: this.meta.name,\n                            }\n                        );\n                    }\n\n                    return variables.query[value.name];\n                } else if (value.$xr === 'SymbolToken') {\n                    return this._translateSymbolToken(value.name);\n                }\n\n                throw new Error('Not implemented yet. ' + value.$xr);\n            }\n\n            return _.mapValues(value, (v, k) =>\n                this._translateValue(\n                    v,\n                    variables,\n                    skipTypeCast,\n                    arrayToInOperator && k[0] !== '$'\n                )\n            );\n        }\n\n        if (Array.isArray(value)) {\n            const ret = value.map((v) =>\n                this._translateValue(\n                    v,\n                    variables,\n                    skipTypeCast,\n                    arrayToInOperator\n                )\n            );\n            return arrayToInOperator ? { $in: ret } : ret;\n        }\n\n        if (skipTypeCast) return value;\n\n        return this.db.connector.typeCast(value);\n    }\n}\n\nmodule.exports = EntityModel;\n"],"names":["HttpCode","UnexpectedState","ValidationError","DatabaseError","InvalidArgument","require","_","eachAsync_","Generators","Convertors","Types","Features","Rules","excludeColumn","isNothing","hasValueIn","JES","NEED_OVERRIDE","minifyAssocs","assocs","sorted","uniq","sort","reverse","minified","take","l","length","i","k","find","a","startsWith","push","$xrsToBypass","Set","EntityModel","valueOfKey","data","meta","keyField","feildMeta","args","fieldSchema","name","extra","fields","schema","omit","$addEnumValues","$orAsArray","others","arrayElem","type","ENUM","values","concat","Object","assign","elementSchema","inputSchema","inputSetName","options","key","JSON","stringify","_cachedSchema","cache","schemaGenerator","db","assocFrom","extraArray","result","forEach","keyPath","keyNodes","split","assoc","slice","map","p","substring","join","add","Array","from","getUniqueKeyFieldsFrom","uniqueKeys","every","f","isNil","getUniqueKeyValuePairsFrom","ukFields","pick","getNestedObject","entityObj","defaultValue","nodes","isArray","get","ensureFields_","connOpts","field","has","uk","isEmpty","findOptions","$query","$association","findOne_","ensureRetrieveCreated","context","customOptions","$retrieveCreated","ensureRetrieveUpdated","$retrieveUpdated","ensureRetrieveDeleted","$retrieveDeleted","ensureTransaction_","connOptions","connection","connector","beginTransaction_","getValueFromContext","cached_","associations","combinedKey","cachedData","_cachedData","findAll_","$toDictionary","toDictionary","entityCollection","transformer","toKVPairs","aggregate_","pipeline","_pipeline","q","_prepareQueries","rawOptions","op","applyRules_","RULE_BEFORE_FIND","_safeExecute_","records","find_","$retrieveDbResult","$result","$relationships","$skipOrm","undefined","_mapRecordsToObjects","$nestedKeyGetter","log","entity","$transformer","evaluate","totalCount","rows","$totalCount","afterFindAll_","row","ret","totalItems","items","$offset","offset","$limit","limit","retryCreateOnDuplicate_","dataGenerator_","maxRery","createOptions","counter","errorRet","create_","error","code","raw","references","_extractAssociations","beforeCreate_","return","success","_populateReferences_","needCreateAssocs","_createAssocs_","_prepareEntityData_","RULE_BEFORE_CREATE","_internalBeforeCreate_","$dryRun","$upsert","dataForUpdating","latest","keys","upsertOne_","_fillResult","insertId","affectedRows","_internalAfterCreate_","queryKey","RULE_AFTER_CREATE","afterCreate_","updateOne_","updateOptions","_update_","updateMany_","forSingleRecord","conditionFields","toUpdate","beforeUpdate_","beforeUpdateMany_","needUpdateAssocs","doneUpdateAssocs","_updateAssocs_","RULE_BEFORE_UPDATE","_internalBeforeUpdate_","_internalBeforeUpdateMany_","otherOptions","update_","_internalAfterUpdate_","_internalAfterUpdateMany_","RULE_AFTER_UPDATE","afterUpdate_","afterUpdateMany_","replaceOne_","_doReplaceOne_","deleteOne_","deleteOptions","_delete_","deleteMany_","deleteAll_","$deleteAll","toDelete","beforeDelete_","beforeDeleteMany_","deletedCount","RULE_BEFORE_DELETE","_internalBeforeDelete_","_internalBeforeDeleteMany_","delete_","_internalAfterDelete_","_internalAfterDeleteMany_","RULE_AFTER_DELETE","afterDelete_","afterDeleteMany_","_containsUniqueKey","hasKeyNameOnly","hasNotNullKey","hasKeys","_ensureContainsUniqueKey","condition","containsUniqueKeyAndValue","containsUniqueKeyOnly","isUpdating","i18n","existing","$existing","opOptions","_dependsOnExistingData","$retrieveExisting","RULE_BEFORE_VALIDATION","fieldInfo","fieldName","value","useRaw","readOnly","$migration","$bypassReadOnly","freezeAfterNonDefault","Error","default","optional","isPlainObject","$xr","sanitize","stack","forceUpdate","updateByDb","hasActivator","auto","createByDb","_translateValue","$variables","RULE_AFTER_VALIDATION","$skipModifiers","applyModifiers_","mapValues","$requireSplitColumns","_serializeByTypeInfo","executor","bind","commit_","message","rawData","latestData","rollback_","_dependencyChanged","fieldDependencies","deps","d","reference","hasIn","_referenceExist","input","ref","pos","indexOf","substr","hasDepends","nullDepends","dep","whenNull","atLeastOneNotNull","features","_hasReservedKeys","obj","v","keyFields","normalizedOptions","$key","query","forOwn","$bypassEnsureUnique","$groupBy","having","$projection","_prepareAssociations","inputKeyField","_translateSymbolToken","info","variables","skipTypeCast","arrayToInOperator","session","errArgs","missingMessage","missingStatus","BAD_REQUEST","$in","typeCast","constructor","module","exports"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}