# @kitmi/data Manual

## Built-in Jacaranda Features

Below features can be configured in both `@kitmi/jacaranda` server config and app module config.

- `dataSource` - Defines connector of a database

Note: For `postgres`, different **postgres schema** are considered different data source in this framework.

- `dataModel` - To be used by `@kitmi/xeml` for code generation

- `db` - Maps of schema name to data source defined by dataSource feature

Note: Schema in this framework is a collection of entities and it can be defined as a subset of a database. Different schemas can use the same `dataSource` connector.

Sample config:

```yaml
dataSource:
    postgres:
        testConnector:
            connection: 'postgres://postgres:postgres@localhost:5432/jc-testdb'
            adminCredential:
                username: 'postgres'
                password: 'postgres'
            logStatement: true
            logConnection: false
            logTransaction: true

dataModel:
    schemaPath: './xeml'
    schemaSet:
        test:
            dataSource: postgres.testConnector
        test2:
            dataSource: postgres.testConnector
    dependencies:
        commons: '@xgent/xem-commons'

db:
    test:
        dataSource: postgres.testConnector        
    test2:
        dataSource: postgres.testConnector
```

## Basic Usage

Supposed all the entity models are generated by `@kitmi/xeml` without errors and database has been migrated to the latest state.

The `db` feature will inject a `db` function into the `app` object.

The `db` function signature is as below.
```js
app.db([schema-name]) -> DbModel; 
```

The `schema-name` is optional and will use the value of `app.settings.defaultDb` as the default schema. The value of `app.settings.defaultDb` can be configured in the app's config as below:

```yaml
settings:
    defaultDb: test
```

The `db` feature can also reference to a data source defined in a library module.

```yaml
db:
    test:
        fromLib: '<name of the library defines the data source>'
        dataSource: postgres.testConnector     
```

When an app with the `db` feature enabled, database operation can be done as below:

```js
    const db = app.db('db name'); // or app.db() for default db configured in app's settings
    // ctx.db is a shorthand of ctx.module.db, ctx.module is the app instance serving the request

    // or db.entity('user') or db.User
    const User = db.entity('User'); 
    
    // or await User.findOne_({ id: 1011 }); 
    // or await User.findOne_(1011) if 1011 is the value of User's primary key; 
    const user = await User.findOne_({ $where: { id: 1011 } });      

    const user = await User.updateOne_({ name: 'New name' }, { $where: { id: 1011 } });
    // ...
```

## CRUD Operations 

-   async findOne_(findOptions)
-   async findMany_(findOptions)
-   async create_(data, createOptions)
-   async updateOne_(data, updateOptions)
-   async updateMany_(data, updateOptions)
-   async deleteOne_(deleteOptions)
-   async deleteMany_(deleteOptions)
-   async deleteAll_()
   
-   To be implemented
    -   async createMany_(data /* array of object */, createOptions) 
    -   async createMany_(fieldNames, data /* array of array */, createOptions)
    -   async aggregate_(...)
    -   async cached_(...)

## Hooks

- async beforeCreate_(context) -> boolean
- async beforeUpdate_(context) -> boolean
- async beforeUpdateMany_(context) -> boolean
- async beforeDelete_(context) -> boolean
- async beforeDeleteMany_(context) -> boolean
- async afterCreate_(context) -> boolean
- async afterUpdate_(context) -> boolean
- async afterUpdateMany_(context) -> boolean
- async afterDelete_(context) -> boolean
- async afterDeleteMany_(context) -> boolean

## Operation Options

### Common Options

#### $ctx 

The `koa` like `ctx` object passed in to interpolate into query condition, will also be passed on to associated operation.

- session
- request
- header
- state

#### $skipUniqueCheck 

To skip unique check for $where object when performing `xxxOne_` operation. 

### findOptions

#### $select

- Select by dot-separated field name (syntax: [<association-name>.]<field-name>)

```js
$select: [
    '*',
    'user.* -password -passwordSalt', // with exclusions
    'offices.bookableResources.type'
]
// SELECT A.*, X.`type` ... JOIN `OfficeBookableResource` as X
```

Note: The output columns may have some automatically added fields especially keys of different layers for building the hierachy structure

- Select by function

```javascript
$select: [ { $xr: 'Function', name: 'MAX', alias: 'max', args: ['order'] } ]
// SELECT MAX(`order`) as max
```

Available $xr types refers to [Runtime Types](dev-runtime-type.md)

Helper functions:

- `xrCall`: call a SQL function
  
```js
{
    $select: [ xrCall('SUM', xrCol('someField')) ] // SUM(someField)
}
```

- `xrCol`: reference to a table column
  
- `xrExpr`: binary expression

```js
{
    $select: [ xrExpr(xrCol('someField'), '+', 1) ] // someField + 1
}
```

- `doInc(field, n)`: shorthand for field + n
- `doDec(field, n)`: shorthand for field - n
  
```js
entity.updateOne_({
    version: doInc('version', 1)  // version = version + 1
}, { $where: { id: xxx } })
```

#### $relation

Indicate to include what associations in the query.

Note: No trailing (s).

- Use anchor name as the relationship

```javascript
// use an anchor 
$relation: [ 'profile', 'roles' ];
// can use multi-levels
$relation: [ 'profile.address', 'roles.role' ];
```

#### $where

The where clause object.

- Condition with AND

```js
{
    $where: {
        key1: value1,
        key2: value2
    } 
    // key1 == value1 AND key2 == value2
}

{
    $where: {
        $and: [ { key1: value1 }, { key2: value2 } ]
    } 
    // key1 == value1 AND key2 == value2
}
```

- Condition with OR

```js
{
    $where: {
        $or: [ { key1: value1 }, { key2: value2 } ],
        $or_2: [ { key3: value3, key4: value4 }, { key5: value5 } ],
    }
    // (key1 == value1 OR key2 == value2) AND ((key3 == value3 AND key4 == value4) OR (key5 == value5))
}
```

- Condition with NOT

```js
{
    $where: {
        $not: {
            key1: value1,
            key2: value2
        }
    }
    // NOT (key1 == value1 AND key2 == value2)
}
```

- Condition with Expressions

```js
{
    $where: {
        $expr: xrExpr(xrCol('someField'), '==', xrCol('someField2')),
        $expr_2: xrExpr(xrCol('metadata'), '@>', obj)
    }
    // someField == someField2 AND metadata @> $1
    // $1: obj
}
```

##### Condition Operators

- $gt: >
- $lt: <
- $gte: >=
- $lte: <=
- $exist
    - { $exist: true } = IS NOT NULL
    - { $exist: false } = IS NULL
- $eq: ==
- $neq: <>
- $in, $notIn
- $between, $notBetween
- $startsWith: LIKE %S
- $endsWith: LIKE S%
- $like: LIKE %S%

#### $orderBy

Order by condition

#### $groupBy (TBD)

Group by condition

#### $offset

TBD.

#### $limit

TBD.

#### $totalCount (TBD)

Returns total record count when used with $limit, should provide the distinct field name

#### $includeDeleted - {boolean}

To include logically deleted records

#### $skipOrm - {boolean}

Internal use, to skip mapping the result into a nested object.
      
#### $asArray - {boolean}

Return result as array, i.e. array mode.

### createOptions

#### $ignore - {boolean}

If already exist (unique key conclicts), just ignore the operation.     

#### $upsert - {boolean|object}

If already exist (unique key conclicts), just update the record.     

#### $getCreated - {boolean|array}

Return created records.

### createOptions & updateOptions

#### $bypassReadOnly - {Set}

Internal use, to bypass some read-only fields

#### $skipModifiers - {boolean}

Skip auto generated modifiers.

#### $skipValidators - {array or Set}

Skip the specified validators

#### $dryRun - {boolean}

Just do the entity pre-process and skip the actual db creation call.

#### $migration - {boolean}

For migration only.

### deleteOptions

#### $getDeleted - {boolean|array}

Return the deleted records

#### $deleteAll - {boolean}

To delete all records with `deleteMany_`

#### $physicalDeletion - {boolean}

To physically delete a record.

## Transaction

When executing transactions, `DbModel` (i.e. `entity.db` or `app.db()`) will fork a new instance containing a dedicated connection for a transaction.

The business logic of the whole transaction should be wrapped in an async function and should use the newly given `db` object as **_db** in below example.

```js
  // Transaction
  const ret = await this.db.transaction_(async (_db) => {

      const User = _db.entity('user'); // should use _db to get entity
      ...

      return ret;
  });
```

## Create W