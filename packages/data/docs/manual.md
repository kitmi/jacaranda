# @kitmi/data 

Jacaranda Framework Data Access Layer

## Built-in Jacaranda Features

Below features come with `@kitmi/data` can be configured in both `@kitmi/jacaranda` server config file and app module config file.

- `dataSource` - Defines connector of a database

Note: For `postgres`, different **postgres schema** are considered different data source in this framework.

- `dataModel` - To be used by `@kitmi/xeml` for code generation

- `db` - Maps of schema name to data source defined by dataSource feature

Note: Schema in this framework is a collection of entities and it can be defined as a subset of a database. Different schemas can use the same `dataSource` connector.

Sample config:

```yaml
dataSource:
    postgres:
        testConnector:
            connection: 'postgres://postgres:postgres@localhost:5432/jc-testdb'
            adminCredential:
                username: 'postgres'
                password: 'postgres'
            logStatement: true
            logConnection: false
            logTransaction: true

dataModel:
    schemaPath: './xeml'
    schemaSet:
        test:
            dataSource: postgres.testConnector
        test2:
            dataSource: postgres.testConnector
    dependencies:
        commons: '@xgent/xem-commons'

db:
    test:
        dataSource: postgres.testConnector        
    test2:
        dataSource: postgres.testConnector
```

## Basic Usage

Supposed all the entity models are generated by `@kitmi/xeml` without errors and database has been migrated to the latest state.

The `db` feature will inject a `db` function into the `app` object.

The `db` function signature is as below.
```js
app.db([schema-name]) -> DbModel; 
```

The `schema-name` is optional and will use the value of `app.settings.defaultDb` as the default schema. The value of `app.settings.defaultDb` can be configured in the app's config as below:

```yaml
settings:
    defaultDb: test
```

The `db` feature can also reference to a data source defined in a library module.

```yaml
db:
    test:
        fromLib: '<name of the library defines the data source>'
        dataSource: postgres.testConnector     
```

When an app with the `db` feature enabled, database operation can be done as below:

```js
    const db = app.db('db name'); // or app.db() for default db configured in app's settings
    // ctx.db is a shorthand of ctx.module.db, ctx.module is the app instance serving the request

    // or db.entity('user') or db.User
    const User = db.entity('User'); 
    
    // or await User.findOne_({ id: 1011 }); 
    // or await User.findOne_(1011) if 1011 is the value of User's primary key; 
    const user = await User.findOne_({ $where: { id: 1011 } });      

    const user = await User.updateOne_({ name: 'New name' }, { $where: { id: 1011 } });
    // ...
```

## CRUD Operations 

-   async findOne_(findOptions)
-   async findMany_(findOptions)
-   async create_(data, createOptions)
-   async updateOne_(data, updateOptions)
-   async updateMany_(data, updateOptions)
-   async deleteOne_(deleteOptions)
-   async deleteMany_(deleteOptions)
-   async deleteAll_()
   
-   Not implemented yet
    -   async createMany_(data /* array of object */, createOptions) 
    -   async createMany_(fieldNames, data /* array of array */, createOptions)
    -   async aggregate_(...)
    -   async cached_(...)

## Hooks

- async beforeCreate_(context) -> boolean
- async beforeUpdate_(context) -> boolean
- async beforeUpdateMany_(context) -> boolean
- async beforeDelete_(context) -> boolean
- async beforeDeleteMany_(context) -> boolean
- async afterCreate_(context) -> boolean
- async afterUpdate_(context) -> boolean
- async afterUpdateMany_(context) -> boolean
- async afterDelete_(context) -> boolean
- async afterDeleteMany_(context) -> boolean

## Operation Options

### Common Options

#### $ctx 

The `koa` like `ctx` object passed in to interpolate into query condition, will also be passed on to associated operation.

- session
- request
- header
- state

#### $skipUniqueCheck 

To skip unique check for $where object when performing `xxxOne_` operation. 

### findOptions

#### $select

- Select by dot-separated field name (syntax: [<association-name>.]<field-name>)

```js
$select: [
    '*',
    'user.* -password -passwordSalt', // with exclusions
    'offices.bookableResources.type'
]
// SELECT A.*, X.`type` ... JOIN `OfficeBookableResource` as X
```

Note: The output columns may have some automatically added fields especially keys of different layers for building the hierachy structure

- Select by function

```js
$select: [ { $xr: 'Function', name: 'MAX', alias: 'max', args: ['order'] } ]
// SELECT MAX(`order`) as max
```

- Using the xrXXX helpers.

```js
import { xrCall, xrCol } from '@kitmi/data';
//...
{
    $select: [ xrCall('COUNT', '*'),  xrCall('SUM', xrCol('field1')) ]
    // SELECT COUNT(*), SUM("field1")
}
```

##### Helper Functions

- `xrCall`: call a SQL function
  
```js
{
    $select: [ xrCall('SUM', xrCol('someField')) ] // SUM(someField)
}
```

- `xrCol`: reference to a table column

Difference between using xrCol and string:

```
postgres: 
    xrCol('abc') -> quote_ident('abc') -> "abc"
    direct string "abc" or 'abc' -> 'abc'
```
  
- `xrExpr`: binary expression

```js
{
    $select: [ xrExpr(xrCol('someField'), '+', 1) ] // someField + 1
}
```

- `xrRaw`: raw expression

Note: Directly inject into the SQL statement, should use it carefully.

```
xrRaw(<raw-statement>, [params])
```

In the raw statement, you can put a `db.paramToken` as the placeholders of params and separately pass the params array as the second argument.

e.g.
```js
xrRaw(
    `("testJson"->>'duration')::INTEGER > ${Book.db.paramToken} AND ("testJson"->>'duration')::INTEGER < ${Book.db.paramToken}`,
    quizCount
)
```

- Others

More usage samples can be found in the [`Data to Update`](#data-to-update) section below.

#### $relation

Indicate to include what associations in the query.

Note: No trailing (s).

- Use anchor name as the relationship

```javascript
// use an anchor 
$relation: [ 'profile', 'roles' ];
// can use multi-levels
$relation: [ 'profile.address', 'roles.role' ];
```

#### $where

The where clause object.

- Condition with AND

```js
{
    $where: {
        key1: value1,
        key2: value2
    } 
    // key1 == value1 AND key2 == value2
}

{
    $where: {
        $and: [ { key1: value1 }, { key2: value2 } ]
    } 
    // key1 == value1 AND key2 == value2
}
```

- Condition with OR

```js
{
    $where: {
        $or: [ { key1: value1 }, { key2: value2 } ],
        $or_2: [ { key3: value3, key4: value4 }, { key5: value5 } ],
    }
    // (key1 == value1 OR key2 == value2) AND ((key3 == value3 AND key4 == value4) OR (key5 == value5))
}
```

- Condition with NOT

```js
{
    $where: {
        $not: {
            key1: value1,
            key2: value2
        }
    }
    // NOT (key1 == value1 AND key2 == value2)
}
```

- Condition with Expressions

```js
{
    $where: {
        $expr: xrExpr(xrCol('someField'), '==', xrCol('someField2')),
        $expr_2: xrExpr(xrCol('metadata'), '@>', obj)
    }
    // someField == someField2 AND metadata @> $1
    // $1: obj
}
```

- Condition with Raw Statement

Had better put a `db.paramToken` as the placeholders of params and separately pass the params array as the second argument.

```js
const duration = [10, 20];
await Book.findMany_({
    $where: {
        $expr: xrRaw(
            `("testJson"->>'duration')::INTEGER > ${Book.db.paramToken} AND ("testJson"->>'duration')::INTEGER < ${Book.db.paramToken}`,
            duration
        ),
    },
});
```

##### Condition Operators

- $gt: >
- $lt: <
- $gte: >=
- $lte: <=
- $exist
    - { $exist: true } = IS NOT NULL
    - { $exist: false } = IS NULL
- $eq: ==
- $neq: <>
- $in, $notIn
- $between, $notBetween
- $startsWith: LIKE %S
- $endsWith: LIKE S%
- $like: LIKE %S%
- $fitler: jsonb_field @> filter

#### $orderBy

Order by condition

#### $groupBy (TBD)

Group by condition

#### $offset

TBD.

#### $limit

TBD.

#### $totalCount (TBD)

Returns total record count when used with $limit, should provide the distinct field name

#### $includeDeleted - {boolean}

To include logically deleted records

#### $skipOrm - {boolean}

Internal use, to skip mapping the result into a nested object.
      
#### $asArray - {boolean}

Return result as array, i.e. array mode.

### createOptions

#### $ignore - {boolean}

If already exist (unique key conclicts), just ignore the operation.     

#### $upsert - {boolean|object}

If already exist (unique key conclicts), just update the record.     

#### $getCreated - {boolean|array}

Return created records.

### createOptions & updateOptions

#### $bypassReadOnly - {Set}

Internal use, to bypass some read-only fields

#### $skipModifiers - {boolean}

Skip auto generated modifiers.

#### $skipValidators - {array or Set}

Skip the specified validators

#### $dryRun - {boolean}

Just do the entity pre-process and skip the actual db creation call.

#### $migration - {boolean}

For migration only.

### deleteOptions

#### $getDeleted - {boolean|array}

Return the deleted records

#### $deleteAll - {boolean}

To delete all records with `deleteMany_`

#### $physicalDeletion - {boolean}

To physically delete a record.

## Data to Update

- Plain Object

```js
const data = {
    field1: 'value1',
    field2: 'value2'
};

await Entity.updateOne_(data, { $where, ... });
```

- Special Values
    - `xrCol` - Set the value to another column
    - `xrCall` - Set the value to the result of a function call
    - `xrExpr` - Set the value to the result of an expression
    - `xrRaw` - Set the value to a raw SQL statement
    - `doInc(field, n)`: shorthand for field + n using xrExpr and xrCol
    - `doDec(field, n)`: shorthand for field - n using xrExpr and xrCol
  
```js
entity.updateOne_({
    version: doInc('version', 1)  // version = version + 1
}, { $where: { id: xxx } })
```

## Transaction

When executing transactions, `DbModel` (i.e. `entity.db` or `app.db()`) will fork a new instance containing a dedicated connection for a transaction.

The business logic of the whole transaction should be wrapped in an async function and should use the newly given `db` object as **_db** in below example.

```js
  // Transaction
  const ret = await this.db.transaction_(async (_db) => {

      const User = _db.entity('user'); // should use _db to get entity
      ...

      return ret;
  });
```

## Create with Associations

- 1:many as array and reference as object

```js
const { op, data, affectedRows, insertId } = await Product.create_({
    'type': 'good',
    'name': 'Demo Product 2',
    'desc': 'Demo Product Description 2',
    'image': 'https://example.com/demo.jpg',
    'thumbnail': 'https://example.com/demo-thumb.jpg',
    'free': true,
    'openToGuest': true,
    'isPackage': false,
    'hasVariants': false,
    'category': 2,
    ':assets': [
        {
            'tag': 'snapshots',
            ':resource': {
                mediaType: 'image',
                url: 'https://example.com/demo-asset.jpg',
            },
        },
        {
            'tag': 'snapshots',
            ':resource': {
                mediaType: 'image',
                url: 'https://example.com/demo-asset2.jpg',
            },
        },
        {
            'tag': 'poster',
            ':resource': {
                mediaType: 'image',
                url: 'https://example.com/demo-poster.jpg',
            },
        },
    ],
    ':attributes': [
        {
            type: 'dimension',
            value: '10x10x10',
        },
        {
            type: 'origin',
            value: 'China',
        },
    ],
    ':variants': [
        {
            type: 'color',
            value: 'red',
        },
        {
            type: 'color',
            value: 'blue',
        },
        {
            type: 'color',
            value: 'green',
        },
        {
            type: 'size',
            value: 'L',
        },
        {
            type: 'size',
            value: 'M',
        },
        {
            type: 'size',
            value: 'S',
        },
    ],
});
```

## License

-   MIT
-   Copyright (c) 2023 KITMI PTY LTD
