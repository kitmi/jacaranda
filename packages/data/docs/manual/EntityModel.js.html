<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>EntityModel.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Connector.html">Connector</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Connector.html#getConnectionStringWithoutCredential">getConnectionStringWithoutCredential</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Connector.html#makeNewConnectionString">makeNewConnectionString</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="EntityModel.html">EntityModel</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#_containsUniqueKey">_containsUniqueKey</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#_delete_">_delete_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#_ensureContainsUniqueKey">_ensureContainsUniqueKey</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#_ensureReturningAutoId">_ensureReturningAutoId</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#_hasReservedKeys">_hasReservedKeys</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#_normalizeGetCreated">_normalizeGetCreated</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#_normalizeQuery">_normalizeQuery</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#_prepareEntityData_">_prepareEntityData_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#_safeExecute_">_safeExecute_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#_translateValue">_translateValue</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#_wrapCtx">_wrapCtx</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#afterCreate_">afterCreate_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#afterDeleteMany_">afterDeleteMany_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#afterDelete_">afterDelete_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#afterUpdateMany_">afterUpdateMany_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#afterUpdate_">afterUpdate_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#beforeCreate_">beforeCreate_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#beforeDeleteMany_">beforeDeleteMany_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#beforeDelete_">beforeDelete_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#beforeUpdateMany_">beforeUpdateMany_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#beforeUpdate_">beforeUpdate_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#create_">create_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#deleteMany_">deleteMany_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#deleteOne_">deleteOne_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#ensureRetrieveCreated">ensureRetrieveCreated</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#ensureRetrieveDeleted">ensureRetrieveDeleted</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#ensureRetrieveUpdated">ensureRetrieveUpdated</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#fieldSchema">fieldSchema</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#findMany_">findMany_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#findOne_">findOne_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#getChainedRelatedEntity">getChainedRelatedEntity</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#getRalatedEntity">getRalatedEntity</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#getUniqueKeyFieldsFrom">getUniqueKeyFieldsFrom</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#getUniqueKeyValuePairsFrom">getUniqueKeyValuePairsFrom</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#getValueFromContext">getValueFromContext</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#inputSchema">inputSchema</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#updateMany_">updateMany_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#updateOne_">updateOne_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#valueOfKey">valueOfKey</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="PostgresConnector.html">PostgresConnector</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#_buildJoin">_buildJoin</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#_buildSelect">_buildSelect</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#_buildWithChildTable">_buildWithChildTable</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#_executeQuery_">_executeQuery_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#_joinAssociation">_joinAssociation</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#_joinAssociations">_joinAssociations</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#_pushOrderBy">_pushOrderBy</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#_sortAndJoinOrderByClause">_sortAndJoinOrderByClause</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#beginTransaction_">beginTransaction_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#buildQuery">buildQuery</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#commit_">commit_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#connect_">connect_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#create_">create_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#delete_">delete_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#disconnect_">disconnect_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#end_">end_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#execute_">execute_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#find_">find_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#getConnectionStringWithoutCredential">getConnectionStringWithoutCredential</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#insertMany_">insertMany_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#makeNewConnectionString">makeNewConnectionString</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#ping_">ping_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#replace_">replace_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#rollback_">rollback_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#update_">update_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#upsertMany_">upsertMany_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#upsert_">upsert_</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="PostgresEntityModel.html">PostgresEntityModel</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresEntityModel.html#_buildAssocTable">_buildAssocTable</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresEntityModel.html#_mapRecordsToObjects">_mapRecordsToObjects</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresEntityModel.html#_prepareAssociations">_prepareAssociations</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresEntityModel.html#_serializeByTypeInfo">_serializeByTypeInfo</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresEntityModel.html#_translateSymbolToken">_translateSymbolToken</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="RelationalConnector.html">RelationalConnector</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_buildCTEHeader">_buildCTEHeader</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_buildColumn">_buildColumn</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_buildColumns">_buildColumns</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_buildGroupBy">_buildGroupBy</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_buildGroupByColumn">_buildGroupByColumn</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_buildGroupByList">_buildGroupByList</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_buildLimitOffset">_buildLimitOffset</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_buildOrderBy">_buildOrderBy</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_buildPartitionBy">_buildPartitionBy</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_escapeIdWithAlias">_escapeIdWithAlias</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_generateAlias">_generateAlias</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_joinCondition">_joinCondition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_packArray">_packArray</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_packValue">_packValue</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_replaceFieldNameWithAlias">_replaceFieldNameWithAlias</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_wrapCondition">_wrapCondition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#aggregate_">aggregate_</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="RelationalEntityModel.html">RelationalEntityModel</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalEntityModel.html#_extractAssociations">_extractAssociations</a></span></li><li class="nav-heading">Modules</li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-EntityFeatureRuntime_AtLeastOneNotNull.html">EntityFeatureRuntime_AtLeastOneNotNull</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-EntityFeatureRuntime_AutoCreate.html">EntityFeatureRuntime_AutoCreate</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-EntityFeatureRuntime_ChangeLog.html">EntityFeatureRuntime_ChangeLog</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-EntityFeatureRuntime_LogicalDeletion.html">EntityFeatureRuntime_LogicalDeletion</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-EntityFeatureRuntime_StateTracking.html">EntityFeatureRuntime_StateTracking</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-Feature_DataModel.html">Feature_DataModel</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-Feature_DataSource.html">Feature_DataSource</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Feature_DataSource.html#.load_">load_</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-Feature_Db.html">Feature_Db</a></span></li><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-member">M</span><span class="nav-item-name"><a href="global.html#getValueFromAny">getValueFromAny</a></span></li><li class="nav-item"><span class="nav-item-type type-member">M</span><span class="nav-item-name"><a href="global.html#hasValueInAny">hasValueInAny</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#mergeWhere">mergeWhere</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">EntityModel.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { ApplicationError, InvalidArgument, ValidationError, HttpCode } from '@kitmi/types';
import { _, eachAsync_, isPlainObject, isEmpty, get as _get } from '@kitmi/utils';
import typeSystem, { Types } from '@kitmi/validators/allSync';
import Features from './entityFeatures';
import Rules from './Rules';
import defaultGenerator from './TypeGenerators';
import { hasValueInAny } from './helpers';
import { OpCompleted } from './utils/errors';

const featureRules = _.reduce(
    Features,
    (acc, feature, name) => {
        _.each(feature, (action, rule) => {
            acc[name + '.' + rule] = action;
        });
        return acc;
    },
    {}
);

const NEED_OVERRIDE = 'Should be overrided by driver-specific subclass.';

/**
 * Base entity model class.
 * @class
 */
class EntityModel {
    /**
     * @param {Object} [rawData] - Raw data object
     */
    constructor(db) {
        this.db = db;
    }

    get meta() {
        return this.constructor.meta;
    }

    /**
     * Get the value of key field/fields from data.
     * @param {object} data
     * @returns {*}
     */
    valueOfKey(data) {
        return Array.isArray(this.meta.keyField) ? _.pick(data, this.meta.keyField) : data[this.meta.keyField];
    }

    /**
     * Get a field schema based on the metadata of the field.
     * @param {string} name - Field name
     * @param {object} [extra] - Extra schema options
     * @return {object|array} Schema object
     */
    fieldSchema(name, extra) {
        const meta = this.meta.fields[name];
        if (!meta) {
            throw new InvalidArgument(`Unknown field "${name}" of entity "${this.meta.name}".`);
        }

        const schema = _.omit(meta, ['default', 'optional']);

        if (extra) {
            const { $addEnumValues, $orAsArray, ...others } = extra;
            let arrayElem = schema;

            if ($orAsArray) {
                arrayElem = { ...schema, ...others };
            }

            if (meta.type === Types.ENUM.name &amp;&amp; $addEnumValues) {
                schema.values = schema.values.concat($addEnumValues);
            }

            Object.assign(schema, others);

            if ($orAsArray) {
                return [
                    schema,
                    {
                        type: 'array',
                        elementSchema: arrayElem,
                    },
                ];
            }
        }

        return schema;
    }

    /**
     * Get a map of fields schema by predefined input set.
     * @param {string} inputSetName - Input set name, predefined in geml
     * @param {object} [options] - Input set options
     * @return {object} Schema object
     */
    inputSchema(inputSetName, options) {
        const key = inputSetName + (options == null ? '{}' : JSON.stringify(options));

        if (this._cachedSchema) {
            const cache = this._cachedSchema[key];
            if (cache) {
                return cache;
            }
        } else {
            this._cachedSchema = {};
        }

        const schemaGenerator = this.db.require(`inputs/${this.meta.name}-${inputSetName}`);

        return (this._cachedSchema[key] = schemaGenerator(options));
    }

    omitReadOnly(data) {
        return _.omitBy(data, (value, key) => !this.meta.fields[key] || this.meta.fields[key].readOnly);
    }

    /**
     * Get related entity model by anchor.
     * @param {string} anchor
     * @returns {EntityModel}
     */
    getRalatedEntity(anchor) {
        const assocInfo = this.meta.associations[anchor];
        if (!assocInfo) {
            throw new InvalidArgument(`Unknown association "${anchor}" of entity "${this.meta.name}".`);
        }

        return this.db.entity(assocInfo.entity);
    }

    /**
     * Get chained related entity model by dot-separated name path.
     * @param {*} dotPath
     * @returns {EntityModel}
     */
    getChainedRelatedEntity(dotPath) {
        Array.isArray(dotPath) || (dotPath = dotPath.split('.'));
        let base = this;

        while (dotPath.length) {
            base = base.getRalatedEntity(dotPath.shift());
        }

        return base;
    }

    /**
     * Get field names array of a unique key from input data.
     * @param {object} data - Input data.
     */
    getUniqueKeyFieldsFrom(data) {
        return _.find(this.meta.uniqueKeys, (fields) => _.every(fields, (f) => data[f] != null));
    }

    /**
     * Get key-value pairs of a unique key from input data.
     * @param {object} data - Input data.
     */
    getUniqueKeyValuePairsFrom(data) {
        const ukFields = this.getUniqueKeyFieldsFrom(data);
        return _.pick(data, ukFields);
    }

    /**
     * Ensure context.latest be the just created entity.
     * @param {*} context
     * @param {*} customOptions
     */
    ensureRetrieveCreated(context, customOptions) {
        if (!context.options.$getCreated) {
            context.options.$getCreated = customOptions || true;
        }
    }

    /**
     * Ensure context.latest be the just updated entity.
     * @param {*} context
     * @param {*} customOptions
     */
    ensureRetrieveUpdated(context, customOptions) {
        if (!context.options.$getUpdated) {
            context.options.$getUpdated = customOptions || true;
        }
    }

    /**
     * Ensure context.exisintg be the just deleted entity.
     * @param {*} context
     * @param {*} customOptions
     */
    ensureRetrieveDeleted(context, customOptions) {
        if (!context.options.$getDeleted) {
            context.options.$getDeleted = customOptions || true;
        }
    }

    /**
     * Get value from context, e.g. session, query ...
     * @param {*} context
     * @param {string} key
     * @returns {*}
     */
    getValueFromContext(context, key) {
        return _get(context.options.$ctx, key);
    }

    /**
     * Pick only allowed fields from ctx.
     * @param {*} options
     * @returns {object}
     */
    _wrapCtx(options) {
        if (options &amp;&amp; options.$ctx &amp;&amp; options.$ctx.module) {
            return {
                ...options,
                $ctx: _.pick(options.$ctx, ['request', 'header', 'session', 'state']),
            };
        }

        return options ?? {};
    }

    async applyRules_(ruleName, context) {
        for (const featureName in this.meta.features) {
            const key = featureName + '.' + ruleName;
            const action = featureRules[key];

            if (action) {
                let featureInfo = this.meta.features[featureName];

                if (context.options.$features &amp;&amp; featureName in context.options.$features) {
                    const customFeatureInfo = context.options.$features[featureName];
                    if (!customFeatureInfo) {
                        continue;
                    }

                    featureInfo = { ...featureInfo, ...customFeatureInfo };
                }

                await action(featureInfo, this, context);
            }
        }
    }

    /**
     * Find a record by unique keys, returns a model object containing the record or undefined if nothing found.
     * @param {object} [findOptions] - findOptions
     * @property {object} [findOptions.$relation] - Joinings
     * @property {object} [findOptions.$select] - Selected fields
     * @property {object} [findOptions.$where] - Extra condition
     * @property {object} [findOptions.$groupBy] - Group by fields
     * @property {object} [findOptions.$orderBy] - Order by fields
     * @property {number} [findOptions.$offset] - Offset
     * @property {number} [findOptions.$limit] - Limit
     * @property {bool} [findOptions.$includeDeleted=false] - Include those marked as logical deleted.
     * @property {bool} [findOptions.$skipOrm=false] - Skip ORM mapping
     * @property {object} [findOptions.$ctx]
     * @returns {*}
     */
    async findOne_(findOptions) {
        return this._find_(findOptions, true);
    }

    /**
     * Find records matching the condition, returns an array of records.
     * @param {object} [findOptions] - findOptions
     * @property {object} [findOptions.$relation] - Joinings
     * @property {object} [findOptions.$select] - Selected fields
     * @property {object} [findOptions.$where] - Extra condition
     * @property {object} [findOptions.$groupBy] - Group by fields
     * @property {object} [findOptions.$orderBy] - Order by fields
     * @property {number} [findOptions.$offset] - Offset
     * @property {number} [findOptions.$limit] - Limit
     * @property {number} [findOptions.$totalCount] - Return totalCount
     * @property {bool} [findOptions.$includeDeleted=false] - Include those marked as logical deleted.
     * @property {bool} [findOptions.$skipOrm=false] - Skip ORM mapping
     * @returns {array}
     */
    async findMany_(findOptions) {
        return this._find_(findOptions, false);
    }

    async _find_(findOptions, isOne) {
        findOptions = this._wrapCtx(findOptions);
        findOptions = this._normalizeQuery(findOptions, isOne /* for single record */);

        const context = {
            op: 'find',
            options: findOptions,
            isOne,
        };

        const opOptions = context.options;

        await this.applyRules_(Rules.RULE_BEFORE_FIND, context);

        this._preProcessOptions(opOptions, isOne /* for single record */, true);

        return this._safeExecute_(async () => {
            const result = await this.db.connector.find_(this.meta.name, opOptions, this.db.transaction);
            let data = result.data;

            if (opOptions.$assoc &amp;&amp; !opOptions.$skipOrm) {
                // rows, coloumns, aliasMap
                if (data.length > 0) {
                    data = this._mapRecordsToObjects(result, opOptions.$assoc, opOptions.$nestedGet);
                }
            }

            if (isOne &amp;&amp; data.length > 1) {
                this.db.app.log('warn', `"findOne_" returns more than one record.`, {
                    entity: this.meta.name,
                    options: _.omit(opOptions, ['$assoc']),
                });
            }

            result.data = isOne ? data[0] : data ?? [];
            delete result.fields;
            delete result.aliases;
            delete result.affectedRows;
            context.latest = context.result = result;
            return isOne ? result.data : result;
        }, context);
    }

    async ensureTransaction_() {
        if (!this.db.transaction) {
            if (!this._safeFlag) {
                throw new ApplicationError('Transaction is not allowed outside of a safe execution block.');
            }

            this.db = this.db.fork(await this.db.connector.beginTransaction_());
        }
    }

    async _commitOwnedTransaction_() {
        if (this.db.transaction) {
            // exception safe
            await this.db.connector.commit_(this.db.transaction);
            const newDbInstance = this.db.fork();
            this.db.end();
            // reset db with a new instance
            this.db = newDbInstance;
        }
    }

    async _rollbackOwnedTransaction_() {
        if (this.db.transaction) {
            // exception safe
            await this.db.connector.rollback_(this.db.transaction);
            const newDbInstance = this.db.fork();
            this.db.end();
            // reset db with a new instance
            this.db = newDbInstance;
        }
    }

    /**
     * Safely execute a function with transaction support, returns false to cancel at anytime.
     * @param {*} executor
     * @returns {Promise&lt;boolean> | boolean}
     */
    async _safeExecute_(executor) {
        executor = executor.bind(this);

        if (this.db.transaction) {
            return executor();
        }

        try {
            this._safeFlag = true;
            const result = await executor();

            // if the executor have initiated a transaction
            await this._commitOwnedTransaction_();

            return result;
        } catch (error) {
            if (error instanceof OpCompleted) {
                await this._commitOwnedTransaction_();
                return error.payload;
            }

            await this._rollbackOwnedTransaction_();
            throw error;
        } finally {
            this._safeFlag = false;
        }
    }

    /**
     * Normalize the `$getCreated` query options.
     * @param {object} opOptions - [out]
     */
    _normalizeGetCreated(opOptions) {
        if (opOptions.$getCreated) {
            const t = typeof opOptions.$getCreated;

            if (t === 'string') {
                opOptions.$getCreated = [opOptions.$getCreated];
                return;
            }

            if (t === 'boolean') {
                opOptions.$getCreated = ['*'];
                return;
            }

            if (t === 'object') {
                if (Array.isArray(opOptions.$getCreated)) {
                    if (opOptions.$getCreated.every((v) => v.indexOf('.') === -1)) {
                        return;
                    }

                    throw new InvalidArgument('"$getCreated" does not support retrieving with associations.');
                }
            }

            throw new InvalidArgument(
                'Invalid value for "$getCreated", expected: column, column array or boolean for returning all.',
                {
                    $getCreated: opOptions.$getCreated,
                    type: t,
                }
            );
        }
    }

    /**
     * Ensure the returning of auto id if the entity has auto increment feature.
     * @param {object} opOptions
     */
    _ensureReturningAutoId(opOptions) {
        if (this.hasAutoIncrement) {
            if (!opOptions.$getCreated) {
                opOptions.$getCreated = [this.meta.features.autoId.field];
            } else if (Array.isArray(opOptions.$getCreated)) {
                if (opOptions.$getCreated.length === 1 &amp;&amp; opOptions.$getCreated[0] === '*') {
                    return;
                }

                opOptions.$getCreated = _.uniq([this.meta.features.autoId.field, ...opOptions.$getCreated]);
            }
        }
    }

    /**
     * Create a new entity with given data.
     * @param {object} data - Entity data
     * @param {object} [createOptions] - Create options
     * @property {bool|object} [createOptions.$getCreated=false] - Retrieve the newly created record from db, can also retrieve with a complex query.
     * @property {bool} [createOptions.$ignore=false] - If already exist, just ignore the insert.
     * @property {bool} [createOptions.$upsert=false] - If already exist, just update the record.
     * @property {bool} [createOptions.$dryRun=false] - Do not actually insert the record.
     * @returns {EntityModel}
     */
    async create_(data, createOptions) {
        createOptions = this._wrapCtx(createOptions);

        // check if data contains any associations (associcated creation) or references (create with references to other entities)
        let [raw, associations, references] = this._extractAssociations(data, true);

        const context = {
            op: 'create',
            raw,
            options: createOptions,
        };

        const opOptions = context.options;
        this._normalizeGetCreated(opOptions);
        this._ensureReturningAutoId(opOptions);

        // overrided by the genreated entity model
        if (!(await this.beforeCreate_(context))) {
            return context.result;
        }

        await this._safeExecute_(async () => {
            // use foreign data as input
            if (!isEmpty(references)) {
                await this.ensureTransaction_();
                await this._populateReferences_(context, references);
            }

            let needCreateAssocs = !isEmpty(associations);
            if (needCreateAssocs) {
                await this.ensureTransaction_();

                associations = await this._createAssocs_(context, associations, true /* before create */);
                // check any other associations left
                needCreateAssocs = !isEmpty(associations);
            }

            await this._prepareEntityData_(context);

            await this.applyRules_(Rules.RULE_BEFORE_CREATE, context);

            if (!opOptions.$dryRun) {
                if (opOptions.$upsert) {
                    const dataForUpdating = _.pick(context.latest, Object.keys(context.raw)); // only update the raw part
                    const uniqueKeys = this.getUniqueKeyFieldsFrom(context.latest);

                    let result = await this.db.connector.upsert_(
                        this.meta.name,
                        dataForUpdating,
                        uniqueKeys,
                        context.latest,
                        opOptions,
                        this.db.transaction
                    );

                    if (result.affectedRows === 0) {
                        // insert ignored
                        const _data = await this.findOne_({ $where: _.pick(context.latest, uniqueKeys) });
                        result = { data: [_data], affectedRows: 0 };
                    }

                    context.result = result;
                } else {
                    context.result = await this.db.connector.create_(
                        this.meta.name,
                        context.latest,
                        opOptions,
                        this.db.transaction
                    );
                }

                context.result.data = { ...context.latest, ...context.result.data[0] };
                context.latest = context.result.data;

                if (this.hasAutoIncrement) {
                    context.result.insertId = context.latest[this.meta.features.autoId.field];
                }

                delete context.result.fields;
            } else {
                context.result = { data: context.latest, affectedRows: 1 };
            }

            delete opOptions.$data;

            if (needCreateAssocs) {
                await this._createAssocs_(context, associations);
            }

            await this.applyRules_(Rules.RULE_AFTER_CREATE, context);
        });

        if (!opOptions.$dryRun) {
            await this.afterCreate_(context);
        }

        return context.result;
    }

    /**
     * Update an existing entity with given data.
     * @param {object} data - Entity data with at least one unique key (pair) given
     * @param {object} [updateOptions] - Update options
     * @property {object} [updateOptions.$where] - Extra condition
     * @property {bool} [updateOptions.$getUpdated=false] - Retrieve the updated entity from database
     * @returns {object}
     */
    async updateOne_(data, updateOptions) {
        if (!updateOptions) {
            // if no condition given, extract from data
            const conditionFields = this.getUniqueKeyFieldsFrom(data);
            if (isEmpty(conditionFields)) {
                throw new InvalidArgument(
                    'Primary key value(s) or at least one group of unique key value(s) is required for updating an entity.',
                    {
                        entity: this.meta.name,
                        data,
                    }
                );
            }
            updateOptions = { $where: _.pick(data, conditionFields) };
            data = _.omit(data, conditionFields);
        }

        updateOptions = this._wrapCtx(updateOptions);

        // see if there is associated entity data provided together
        let [raw, associations, references] = this._extractAssociations(data);
        const isOne = true;

        const context = {
            op: 'update',
            raw,
            options: this._normalizeQuery(updateOptions, isOne /* for single record */),
            isOne,
        };

        // see if there is any runtime feature stopping the update
        const toUpdate = await this.beforeUpdate_(context);

        if (!toUpdate) {
            return context.result;
        }

        const opOptions = context.options;
        this._preProcessOptions(opOptions, isOne /* for single record */);

        await this._safeExecute_(async () => {
            if (!isEmpty(references)) {
                await this.ensureTransaction_();
                await this._populateReferences_(context, references);
            }

            let needUpdateAssocs = !isEmpty(associations);
            let doneUpdateAssocs;

            if (needUpdateAssocs) {
                await this.ensureTransaction_();

                associations = await this._updateAssocs_(context, associations, true /* before update */, isOne);
                needUpdateAssocs = !isEmpty(associations);
                doneUpdateAssocs = true;
            }

            await this._prepareEntityData_(context, true /* is updating */, isOne);

            await this.applyRules_(Rules.RULE_BEFORE_UPDATE, context);

            if (isEmpty(context.latest)) {
                if (!doneUpdateAssocs &amp;&amp; !needUpdateAssocs) {
                    throw new InvalidArgument('Cannot do the update with empty record. Entity: ' + this.meta.name);
                }

                const data = await this.findOne_(opOptions.$where);
                context.result = { data };
            } else {
                if (
                    needUpdateAssocs &amp;&amp;
                    !hasValueInAny([opOptions.$where, context.latest], this.meta.keyField) &amp;&amp;
                    !opOptions.$getUpdated
                ) {
                    // has associated data depending on this record
                    // should ensure the latest result will contain the key of this record
                    opOptions.$getUpdated = true;
                }

                if (!opOptions.$limit) {
                    opOptions.$limit = 1;
                }

                context.result = await this.db.connector.update_(
                    this.meta.name,
                    context.latest,
                    opOptions,
                    this.db.transaction
                );

                context.result.data = context.result.data[0] ?? {};
                delete context.result.fields;
            }

            await this.applyRules_(Rules.RULE_AFTER_UPDATE, context);

            delete opOptions.$data;

            if (needUpdateAssocs) {
                await this._updateAssocs_(context, associations, false, isOne);
            }
        }, context);

        if (!opOptions.$dryRun) {
            await this.afterUpdate_(context);
        }

        return context.result;
    }

    /**
     * Update many existing entites with given data.
     * @param {*} data
     * @param {*} updateOptions
     * @returns {object}
     */
    async updateMany_(data, updateOptions) {
        updateOptions = this._wrapCtx(updateOptions);
        this._ensureNoAssociations(data);

        const isOne = false;

        const context = {
            op: 'update',
            raw: data,
            options: this._normalizeQuery(updateOptions, isOne /* for single record */),
            isOne,
        };

        // see if there is any runtime feature stopping the update
        const toUpdate = await this.beforeUpdateMany_(context);

        if (!toUpdate) {
            return context.result;
        }

        const opOptions = context.options;
        this._preProcessOptions(opOptions, isOne /* for single record */);

        await this._safeExecute_(async () => {
            await this._prepareEntityData_(context, true /* is updating */, isOne);

            await this.applyRules_(Rules.RULE_BEFORE_UPDATE, context);

            if (isEmpty(context.latest)) {
                throw new InvalidArgument('Cannot do the update with empty record. Entity: ' + this.meta.name);
            }

            context.result = await this.db.connector.update_(
                this.meta.name,
                context.latest,
                opOptions,
                this.db.transaction
            );

            context.result.data = context.result.data ?? [];
            delete context.result.fields;

            await this.applyRules_(Rules.RULE_AFTER_UPDATE, context);
            delete opOptions.$data;
        }, context);

        if (!opOptions.$dryRun) {
            await this.afterUpdateMany_(context);
        }

        return context.result;
    }

    /**
     * Remove an existing entity with given data.
     * @param {object} [deleteOptions] - Update options
     * @property {object} [deleteOptions.$where] - Extra condition
     * @property {bool} [deleteOptions.$getDeleted=false] - Retrieve the deleted entity from database
     * @property {bool} [deleteOptions.$physicalDeletion=false] - When $physicalDeletion = true, deletetion will not take into account logicaldeletion feature
     */
    async deleteOne_(deleteOptions) {
        deleteOptions = this._wrapCtx(deleteOptions);
        return this._delete_(deleteOptions, true);
    }

    /**
     * Remove an existing entity with given data.
     * @param {object} [deleteOptions] - Update options
     * @property {object} [deleteOptions.$where] - Extra condition
     * @property {bool} [deleteOptions.$getDeleted=false] - Retrieve the deleted entity from database
     * @property {bool} [deleteOptions.$physicalDeletion=false] - When $physicalDeletion = true, deletetion will not take into account logicaldeletion feature
     * @property {bool} [deleteOptions.$deleteAll=false] - When $deleteAll = true, the operation will proceed even empty condition is given
     */
    async deleteMany_(deleteOptions) {
        deleteOptions = this._wrapCtx(deleteOptions);
        return this._delete_(deleteOptions, false);
    }

    async deleteAll_() {
        return this.deleteMany_({ $deleteAll: true });
    }

    /**
     * Remove an existing entity with given data.
     * @param {object} [deleteOptions] - Update options
     * @property {object} [deleteOptions.$where] - Extra condition
     * @property {bool} [deleteOptions.$getDeleted=false] - Retrieve the deleted entity from database
     * @property {bool} [deleteOptions.$physicalDeletion=false] - When $physicalDeletion = true, deletetion will not take into account logicaldeletion feature
     */
    async _delete_(deleteOptions, isOne) {
        deleteOptions = this._normalizeQuery(deleteOptions, isOne /* for single record */);

        if (isEmpty(deleteOptions.$where) &amp;&amp; (isOne || !deleteOptions.$deleteAll)) {
            throw new InvalidArgument(
                'Empty condition is not allowed for deleting unless `{ $deleteAll: true }` is set in options.',
                {
                    entity: this.meta.name,
                    deleteOptions,
                    isOne,
                }
            );
        }

        const context = {
            op: 'delete',
            options: deleteOptions,
            isOne,
        };

        let toDelete;

        if (isOne) {
            toDelete = await this.beforeDelete_(context);
        } else {
            toDelete = await this.beforeDeleteMany_(context);
        }

        if (!toDelete) {
            return context.result;
        }

        const opOptions = context.options;
        this._preProcessOptions(opOptions, isOne /* for single record */);

        await this._safeExecute_(async () => {
            await this.applyRules_(Rules.RULE_BEFORE_DELETE, context);

            context.result = await this.db.connector.delete_(this.meta.name, opOptions, this.db.transaction);
            delete context.result.fields;

            await this.applyRules_(Rules.RULE_AFTER_DELETE, context);
        }, context);

        if (!opOptions.$dryRun) {
            if (isOne) {
                await this.afterDelete_(context);
            } else {
                await this.afterDeleteMany_(context);
            }
        }

        return context.result;
    }

    /**
     * Check whether a data record contains primary key or at least one unique key pair.
     * @param {object} data
     */
    _containsUniqueKey(data) {
        let hasKeyName = false;

        const hasNotNullKey = _.find(this.meta.uniqueKeys, (fields) => {
            const hasKeys = _.every(fields, (f) => f in data);
            hasKeyName = hasKeyName || hasKeys;

            return _.every(fields, (f) => data[f] != null);
        });

        return [hasNotNullKey, hasKeyName];
    }

    /**
     * Ensure the condition contains one of the unique keys.
     * @param {*} condition
     */
    _ensureContainsUniqueKey(condition) {
        const [containsUniqueKeyAndValue, containsUniqueKeyName] = this._containsUniqueKey(condition);

        if (!containsUniqueKeyAndValue) {
            if (containsUniqueKeyName) {
                throw new ValidationError(
                    'One of the unique key field as query condition is null. Condition: ' + JSON.stringify(condition)
                );
            }

            throw new InvalidArgument(
                'Single record operation requires at least one unique key value pair in the query condition.',
                {
                    entity: this.meta.name,
                    condition,
                }
            );
        }
    }

    /**
     * Prepare valid and sanitized entity data for sending to database.
     * @param {object} context - Operation context.
     * @property {object} context.raw - Raw input data.
     * @param {bool} isUpdating - Flag for updating existing entity.
     */
    async _prepareEntityData_(context, isUpdating = false, isOne = true) {
        const i18n = this.i18n;
        const { name, fields } = this.meta;

        let { raw } = context;
        let latest = {};
        // returned by $getExisting
        let existing = context.options.$existing;
        context.latest = latest;

        if (!context.i18n) {
            context.i18n = i18n;
        }

        const opOptions = context.options;

        if (opOptions.$upsert &amp;&amp; typeof opOptions.$upsert === 'object') {
            raw = { ...raw, ...opOptions.$upsert };
        }

        if (isUpdating &amp;&amp; isEmpty(existing) &amp;&amp; (this._dependsOnExistingData(raw) || opOptions.$getExisting)) {
            await this.ensureTransaction_();

            if (isOne) {
                existing = await this.findOne_({ $where: opOptions.$where });
            } else {
                const { data: _data } = await this.findMany_({ $where: opOptions.$where });
                existing = _data;
            }
            context.existing = existing;
        }

        if (opOptions.$getExisting &amp;&amp; !opOptions.$existing) {
            opOptions.$existing = existing;
        }

        await this.applyRules_(Rules.RULE_BEFORE_VALIDATION, context);

        await eachAsync_(fields, async (fieldInfo, fieldName) => {
            let value;
            let useRaw = false;

            if (fieldName in raw) {
                value = raw[fieldName];
                useRaw = true;
            } else if (fieldName in latest) {
                value = latest[fieldName];
            }

            if (typeof value !== 'undefined') {
                // field value given in raw data
                if (fieldInfo.readOnly &amp;&amp; useRaw) {
                    if (
                        !opOptions.$migration &amp;&amp;
                        (!opOptions.$bypassReadOnly || !opOptions.$bypassReadOnly.has(fieldName))
                    ) {
                        // read only, not allow to set by input value
                        throw new ValidationError(
                            `Read-only field "${fieldName}" is not allowed to be set by manual input.`,
                            {
                                entity: name,
                                fieldInfo: fieldInfo,
                            }
                        );
                    }
                }

                if (isUpdating &amp;&amp; fieldInfo.freezeAfterNonDefault) {
                    if (!existing) {
                        throw new Error('"freezeAfterNonDefault" qualifier requires existing data.');
                    }

                    if (existing[fieldName] !== fieldInfo.default) {
                        // freezeAfterNonDefault, not allow to change if value is non-default
                        throw new ValidationError(
                            `"freezeAfterNonDefault" field "${fieldName}" is not allowed to be changed.`,
                            {
                                entity: name,
                                fieldInfo: fieldInfo,
                            }
                        );
                    }
                }

                /**  todo: fix dependency, check writeProtect 
                if (isUpdating &amp;&amp; fieldInfo.writeOnce) {     
                    assert: existing, '"writeOnce" qualifier requires existing data.';
                    if (!_.isNil(existing[fieldName])) {
                        throw new ValidationError(`Write-once field "${fieldName}" is not allowed to be update once it was set.`, {
                            entity: name,
                            fieldInfo: fieldInfo 
                        });
                    }
                } */

                // sanitize first
                if (value == null) {
                    if (fieldInfo.default != null) {
                        // has default setting in meta data
                        latest[fieldName] = fieldInfo.default;
                    } else if (!fieldInfo.optional) {
                        throw new ValidationError(`The "${fieldName}" value of "${name}" entity cannot be null.`, {
                            entity: name,
                            fieldInfo: fieldInfo,
                        });
                    } else {
                        latest[fieldName] = null;
                    }
                } else {
                    if (isPlainObject(value) &amp;&amp; value.$xr) {
                        latest[fieldName] = value;

                        return;
                    }

                    try {
                        latest[fieldName] = typeSystem.sanitize(value, fieldInfo, i18n);
                    } catch (error) {
                        throw new ValidationError(`Invalid "${fieldName}" value of "${name}" entity.`, {
                            entity: name,
                            fieldInfo: fieldInfo,
                            value,
                            context: JSON.stringify(context),
                            error: error.stack,
                        });
                    }
                }

                return;
            }

            // not given in raw data
            if (isUpdating) {
                if (fieldInfo.forceUpdate) {
                    // has force update policy, e.g. updateTimestamp
                    if (fieldInfo.updateByDb || fieldInfo.hasActivator) {
                        return;
                    }

                    // require generator to refresh auto generated value
                    if (fieldInfo.auto) {
                        latest[fieldName] = await defaultGenerator(fieldInfo, i18n);
                        return;
                    }

                    throw new ValidationError(`Field "${fieldName}" of "${name}" entity is required for each update.`, {
                        entity: name,
                        fieldInfo: fieldInfo,
                    });
                }

                return;
            }

            // new record
            if (!fieldInfo.autoByDb) {
                if ('default' in fieldInfo) {
                    // has default setting in meta data
                    latest[fieldName] = fieldInfo.default;
                } else if (fieldInfo.optional) {
                    // ignore
                } else if (fieldInfo.auto) {
                    // automatically generated
                    latest[fieldName] = await defaultGenerator(fieldInfo, i18n);
                } else if (!fieldInfo.hasActivator &amp;&amp; !fieldInfo.fillByRule) {
                    // skip those have activators or fill by beforeCreate rule

                    throw new ValidationError(`Field "${fieldName}" of "${name}" entity is required.`, {
                        entity: name,
                        fieldInfo: fieldInfo,
                        raw,
                    });
                }
            } // else default value set by database or by rules
        });

        latest = context.latest = this._translateValue(latest, opOptions);

        await this.applyRules_(Rules.RULE_AFTER_VALIDATION, context);

        if (!opOptions.$skipModifiers) {
            if (opOptions.$skipValidators &amp;&amp; Array.isArray(opOptions.$skipValidators)) {
                opOptions.$skipValidators = new Set(opOptions.$skipValidators);
            }
            await this.applyModifiers_(context, isUpdating);
        }

        // final round process before entering database
        context.latest = _.mapValues(latest, (value, key) => {
            if (value == null) return value;

            if (isPlainObject(value) &amp;&amp; value.$xr) {
                // there is special input column which maybe a function or an expression
                // postgres only support split columns, i.e. INSERT INTO VALUES
                // mysql support INSERT INTO SET ??
                //opOptions.$requireSplitColumns = true;
                return value;
            }

            const fieldInfo = fields[key];

            return this._serializeByTypeInfo(value, fieldInfo);
        });

        opOptions.$data = {
            latest: context.latest,
            raw: context.raw,
        };

        if (isUpdating) {
            opOptions.$data.existing = existing;
        }
    }

    _dependencyChanged(fieldName, context) {
        if (this.meta.fieldDependencies) {
            const deps = this.meta.fieldDependencies[fieldName];

            return _.find(deps, (d) =>
                isPlainObject(d) ? d.reference !== fieldName &amp;&amp; _.hasIn(context, d.reference) : _.hasIn(context, d)
            );
        }

        return false;
    }

    _referenceExist(input, ref) {
        const pos = ref.indexOf('.');

        if (pos > 0) {
            return ref.substr(pos + 1) in input;
        }

        return ref in input;
    }

    _dependsOnExistingData(input) {
        // check modifier dependencies
        const deps = this.meta.fieldDependencies;
        let hasDepends = false;

        if (deps) {
            const nullDepends = new Set();

            hasDepends = _.find(deps, (dep, fieldName) =>
                _.find(dep, (d) => {
                    if (isPlainObject(d)) {
                        if (d.whenNull) {
                            if (input[fieldName] == null) {
                                nullDepends.add(dep);
                            }

                            return false;
                        }

                        if (d.reference === fieldName) return false;

                        d = d.reference;
                    }

                    return (
                        (fieldName in input &amp;&amp; !this._referenceExist(input, d)) ||
                        (this._referenceExist(input, d) &amp;&amp; !(fieldName in input))
                    );
                })
            );

            if (hasDepends) {
                return true;
            }

            for (const dep of nullDepends) {
                if (_.find(dep, (d) => !this._referenceExist(input, d.reference))) {
                    return true;
                }
            }
        }

        // check by special rules
        const atLeastOneNotNull = this.meta.features.atLeastOneNotNull;
        if (atLeastOneNotNull) {
            hasDepends = _.find(atLeastOneNotNull, (fields) =>
                _.find(fields, (field) => field in input &amp;&amp; input[field] == null)
            );
            if (hasDepends) {
                return true;
            }
        }

        return false;
    }

    /**
     * Check if the given object contains reserved keys.
     * @param {*} obj
     * @returns {boolean}
     */
    _hasReservedKeys(obj) {
        return _.find(obj, (v, k) => k[0] === '$');
    }

    /**
     * Normalize options including moving entries with key not starting with '$' into $where, interpolating variables and building relationship structure.
     * @param {object} options
     * @param {boolean} [isOne=false]
     * @returns {object}
     */
    _normalizeQuery(options, isOne = false) {
        if (!isPlainObject(options)) {
            if (isOne &amp;&amp; options == null) {
                throw new InvalidArgument(
                    'Primary key value or at least one unique key value pair is required for single record operation.',
                    {
                        entity: this.meta.name,
                    }
                );
            }

            // in this case, options is the value of primary key, check for combined primary key
            if (Array.isArray(this.meta.keyField)) {
                throw new InvalidArgument(
                    'Cannot use a singular value as condition to query against an entity with combined primary key.',
                    {
                        entity: this.meta.name,
                        keyFields: this.meta.keyField,
                    }
                );
            }

            // single key
            return options != null
                ? {
                      $where: {
                          [this.meta.keyField]: options,
                      },
                  }
                : {};
        }

        const qOptions = { $ctx: options.$ctx };
        const query = {};

        // move non-reserved keys to $where
        _.forOwn(options, (v, k) => {
            if (k[0] === '$') {
                qOptions[k] = v;
            } else {
                query[k] = v;
            }
        });

        qOptions.$where = { ...query, ...qOptions.$where };

        let relFromSelect = new Set();

        if (qOptions.$select) {
            const converted = new Set();

            qOptions.$select.forEach((value) => {
                if (typeof value === 'string') {
                    let fpos = value.indexOf('* -');
                    if (fpos >= 0) {
                        // exclude syntax
                        const parts = value.split(' -');
                        const baseAssoc = parts[0];
                        value = {
                            $xr: 'ExclusiveSelect',
                            columnSet: baseAssoc,
                            excludes: parts.slice(1),
                        };
                    } else {
                        let pos;

                        if ((pos = value.lastIndexOf('.')) > 0) {
                            // auto-add relation if select includes a field from related entity
                            relFromSelect.add(value.substring(0, pos));
                        }

                        converted.add(value);
                        return;
                    }
                }

                if (isPlainObject(value) &amp;&amp; value.$xr === 'ExclusiveSelect') {
                    this._translateExclSelect(value).forEach((v) => {
                        let pos;

                        if ((pos = v.lastIndexOf('.')) > 0) {
                            // auto-add relation if select includes a field from related entity
                            relFromSelect.add(v.substring(0, pos));
                        }

                        converted.add(v);
                    });
                    return;
                }

                converted.add(this._translateValue(value, qOptions));
            });

            qOptions.$select = converted; // will be unique in prepareAssociations
        }

        if (relFromSelect.size) {
            // merge with existing relations
            if (qOptions.$relation) {
                qOptions.$relation.forEach((rel) => relFromSelect.add(rel));
            }
            qOptions.$relation = Array.from(relFromSelect);
        }

        return qOptions;
    }

    _preProcessOptions(qOptions, isOne, isFind) {
        const extraSelect = [];
        qOptions.$where = this._translateValue(qOptions.$where, qOptions, true, isFind ? extraSelect : undefined);
        if (extraSelect.length) {
            qOptions.$select || (qOptions.$select = new Set(['*']));
            if (!qOptions.$select.has('*')) {
                extraSelect.forEach((v) => qOptions.$select.add(v));
            }
        }

        if (isOne &amp;&amp; !qOptions.$skipUniqueCheck) {
            this._ensureContainsUniqueKey(qOptions.$where);
        }

        if (qOptions.$groupBy) {
            qOptions.$skipOrm = true; // no orm for grouping
            if (isPlainObject(qOptions.$groupBy)) {
                if (qOptions.$groupBy.having) {
                    qOptions.$groupBy.having = this._translateValue(qOptions.$groupBy.having, qOptions, true);
                }
            }
        }

        if (qOptions.$relation) {
            if (qOptions.$assoc) {
                throw new Error('To be implemented');
            }

            qOptions.$assoc = this._prepareAssociations(qOptions);
        }
    }

    _translateExclSelect(value) {
        const { columnSet, excludes } = value;

        if (columnSet === '*') {
            return Object.keys(_.omit(this.meta.fields, excludes));
        }

        const base = columnSet.split('.');
        const right = base.pop();

        if (right !== '*') {
            throw new ApplicationError('Invalid column set syntax in exclusive select: ' + columnSet);
        }

        const basePrefix = base.join('.');
        const targetEntity = this.getChainedRelatedEntity(base);

        return Object.keys(_.omit(targetEntity.meta.fields, excludes)).map((f) => basePrefix + '.' + f);
    }

    /**
     * Pre create processing, return false to stop upcoming operation.
     * @param {*} context
     */
    async beforeCreate_(context) {
        return true;
    }

    /**
     * Pre update processing, return false to stop upcoming operation.
     * @param {*} context
     */
    async beforeUpdate_(context) {
        return true;
    }

    /**
     * Pre update processing, multiple records, return false to stop upcoming operation.
     * @param {*} context
     */
    async beforeUpdateMany_(context) {
        return true;
    }

    /**
     * Pre delete processing, return false to stop upcoming operation.
     * @param {*} context
     */
    async beforeDelete_(context) {
        return true;
    }

    /**
     * Pre delete processing, multiple records, return false to stop upcoming operation.
     * @param {*} context
     */
    async beforeDeleteMany_(context) {
        return true;
    }

    /**
     * Post create processing.
     * @param {*} context
     */
    async afterCreate_(context) {}

    /**
     * Post update processing.
     * @param {*} context
     */
    async afterUpdate_(context) {}

    /**
     * Post update processing, multiple records
     * @param {*} context
     */
    async afterUpdateMany_(context) {}

    /**
     * Post delete processing.
     * @param {*} context
     */
    async afterDelete_(context) {}

    /**
     * Post delete processing, multiple records
     * @param {*} context
     */
    async afterDeleteMany_(context) {}

    _prepareAssociations() {
        throw new Error(NEED_OVERRIDE);
    }

    _mapRecordsToObjects() {
        throw new Error(NEED_OVERRIDE);
    }

    _extractAssociations(data) {
        throw new Error(NEED_OVERRIDE);
    }

    // will update context.raw if applicable
    async _populateReferences_(context, references) {
        throw new Error(NEED_OVERRIDE);
    }

    // will update context.raw if applicable
    async _createAssocs_(context, assocs) {
        throw new Error(NEED_OVERRIDE);
    }

    async _updateAssocs_(context, assocs) {
        throw new Error(NEED_OVERRIDE);
    }

    _translateSymbolToken(name) {
        throw new Error(NEED_OVERRIDE);
    }

    _serializeByTypeInfo(value, info) {
        throw new Error(NEED_OVERRIDE);
    }

    /**
     * Automatically fetch variables by $xr
     * @param {*} value
     * @param {object} opPayload
     * @param {boolean} arrayToInOperator - Convert an array value to { $in: array }
     * @returns {*}
     */
    _translateValue(value, opPayload, arrayToInOperator, extraSelect) {
        if (isPlainObject(value)) {
            if (value.$xr) {                
                switch (value.$xr) {
                    case 'Column':
                        if (extraSelect) {
                            extraSelect.push(value.name);
                        }
                        return value;

                    case 'Function':
                        if (value.args) {
                            return { ...value, args: this._translateValue(value.args, opPayload, false, extraSelect) };
                        }
                        return value;

                    case 'BinExpr':
                        return {
                            ...value,
                            left: this._translateValue(value.left, opPayload, false, extraSelect),
                            right: this._translateValue(value.right, opPayload, false, extraSelect),
                        };

                    case 'Request': {
                        const ctx = opPayload.$ctx;

                        if (ctx == null) {
                            throw new InvalidArgument(
                                'Request reference requires the Http `ctx` object to be passed as `$ctx` in the operation options.',
                                {
                                    entity: this.meta.name,
                                    value,
                                }
                            );
                        }

                        const reqValue = _get(ctx, value.name);

                        if (reqValue == null &amp;&amp; !value.optional) {
                            const errArgs = [];
                            if (value.missingMessage) {
                                errArgs.push(value.missingMessage);
                            }
                            if (value.missingStatus) {
                                errArgs.push(value.missingStatus || HttpCode.BAD_REQUEST);
                            }

                            throw new ValidationError(...errArgs);
                        }

                        return reqValue;
                    }

                    case 'Symbol':
                        return this._translateSymbolToken(value.name);

                    case 'Data':
                        if (opPayload.$data == null) {
                            throw new InvalidArgument(
                                '`$data` field is required for "latest|existing|raw" value reference.',
                                {
                                    entity: this.meta.name,
                                    value,
                                }
                            );
                        }
                        return _get(opPayload.$data, value.name);

                    case 'Query':
                    case 'DataSet':
                    case 'Raw':
                        return value;
                }

                throw new Error('Not implemented yet. ' + value.$xr);
            }

            return _.mapValues(value, (v, k) => {
                const keyword = k[0] === '$';
                if (extraSelect &amp;&amp; !keyword) {
                    extraSelect.push(k);
                }

                return this._translateValue(v, opPayload, arrayToInOperator &amp;&amp; !keyword, extraSelect);
            });
        }

        if (Array.isArray(value)) {
            return arrayToInOperator
                ? { $in: value }
                : // $and, $or, $not array
                  value.map((v) => this._translateValue(v, opPayload, arrayToInOperator, extraSelect));
        }

        return value;
    }
}

export default EntityModel;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.3</a> on Thu Jun 27 2024 14:06:47 GMT+0800 (China Standard Time) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
