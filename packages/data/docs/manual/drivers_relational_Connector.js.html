<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>drivers/relational/Connector.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Connector.html">Connector</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Connector.html#getConnectionStringWithoutCredential">getConnectionStringWithoutCredential</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Connector.html#makeNewConnectionString">makeNewConnectionString</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="EntityModel.html">EntityModel</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#_containsUniqueKey">_containsUniqueKey</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#_delete_">_delete_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#_ensureContainsUniqueKey">_ensureContainsUniqueKey</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#_ensureReturningAutoId">_ensureReturningAutoId</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#_hasReservedKeys">_hasReservedKeys</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#_normalizeGetCreated">_normalizeGetCreated</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#_normalizeQuery">_normalizeQuery</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#_prepareEntityData_">_prepareEntityData_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#_safeExecute_">_safeExecute_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#_translateValue">_translateValue</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#_wrapCtx">_wrapCtx</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#afterCreate_">afterCreate_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#afterDeleteMany_">afterDeleteMany_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#afterDelete_">afterDelete_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#afterUpdateMany_">afterUpdateMany_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#afterUpdate_">afterUpdate_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#beforeCreate_">beforeCreate_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#beforeDeleteMany_">beforeDeleteMany_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#beforeDelete_">beforeDelete_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#beforeUpdateMany_">beforeUpdateMany_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#beforeUpdate_">beforeUpdate_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#create_">create_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#deleteMany_">deleteMany_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#deleteOne_">deleteOne_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#ensureRetrieveCreated">ensureRetrieveCreated</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#ensureRetrieveDeleted">ensureRetrieveDeleted</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#ensureRetrieveUpdated">ensureRetrieveUpdated</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#fieldSchema">fieldSchema</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#findMany_">findMany_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#findOne_">findOne_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#getChainedRelatedEntity">getChainedRelatedEntity</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#getRalatedEntity">getRalatedEntity</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#getUniqueKeyFieldsFrom">getUniqueKeyFieldsFrom</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#getUniqueKeyValuePairsFrom">getUniqueKeyValuePairsFrom</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#getValueFromContext">getValueFromContext</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#inputSchema">inputSchema</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#updateMany_">updateMany_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#updateOne_">updateOne_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="EntityModel.html#valueOfKey">valueOfKey</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="PostgresConnector.html">PostgresConnector</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#_buildJoin">_buildJoin</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#_buildSelect">_buildSelect</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#_buildWithChildTable">_buildWithChildTable</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#_executeQuery_">_executeQuery_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#_joinAssociation">_joinAssociation</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#_joinAssociations">_joinAssociations</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#_pushOrderBy">_pushOrderBy</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#_sortAndJoinOrderByClause">_sortAndJoinOrderByClause</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#beginTransaction_">beginTransaction_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#buildQuery">buildQuery</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#commit_">commit_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#connect_">connect_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#create_">create_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#delete_">delete_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#disconnect_">disconnect_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#end_">end_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#execute_">execute_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#find_">find_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#getConnectionStringWithoutCredential">getConnectionStringWithoutCredential</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#insertMany_">insertMany_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#makeNewConnectionString">makeNewConnectionString</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#ping_">ping_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#replace_">replace_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#rollback_">rollback_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#update_">update_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#upsertMany_">upsertMany_</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresConnector.html#upsert_">upsert_</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="PostgresEntityModel.html">PostgresEntityModel</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresEntityModel.html#_buildAssocTable">_buildAssocTable</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresEntityModel.html#_mapRecordsToObjects">_mapRecordsToObjects</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresEntityModel.html#_prepareAssociations">_prepareAssociations</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresEntityModel.html#_serializeByTypeInfo">_serializeByTypeInfo</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="PostgresEntityModel.html#_translateSymbolToken">_translateSymbolToken</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="RelationalConnector.html">RelationalConnector</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_buildCTEHeader">_buildCTEHeader</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_buildColumn">_buildColumn</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_buildColumns">_buildColumns</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_buildGroupBy">_buildGroupBy</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_buildGroupByColumn">_buildGroupByColumn</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_buildGroupByList">_buildGroupByList</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_buildLimitOffset">_buildLimitOffset</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_buildOrderBy">_buildOrderBy</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_buildPartitionBy">_buildPartitionBy</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_escapeIdWithAlias">_escapeIdWithAlias</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_generateAlias">_generateAlias</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_joinCondition">_joinCondition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_packArray">_packArray</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_packValue">_packValue</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_replaceFieldNameWithAlias">_replaceFieldNameWithAlias</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#_wrapCondition">_wrapCondition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalConnector.html#aggregate_">aggregate_</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="RelationalEntityModel.html">RelationalEntityModel</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="RelationalEntityModel.html#_extractAssociations">_extractAssociations</a></span></li><li class="nav-heading">Modules</li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-EntityFeatureRuntime_AtLeastOneNotNull.html">EntityFeatureRuntime_AtLeastOneNotNull</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-EntityFeatureRuntime_AutoCreate.html">EntityFeatureRuntime_AutoCreate</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-EntityFeatureRuntime_ChangeLog.html">EntityFeatureRuntime_ChangeLog</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-EntityFeatureRuntime_LogicalDeletion.html">EntityFeatureRuntime_LogicalDeletion</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-EntityFeatureRuntime_StateTracking.html">EntityFeatureRuntime_StateTracking</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-Feature_DataModel.html">Feature_DataModel</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-Feature_DataSource.html">Feature_DataSource</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-Feature_DataSource.html#.load_">load_</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-Feature_Db.html">Feature_Db</a></span></li><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-member">M</span><span class="nav-item-name"><a href="global.html#getValueFromAny">getValueFromAny</a></span></li><li class="nav-item"><span class="nav-item-type type-member">M</span><span class="nav-item-name"><a href="global.html#hasValueInAny">hasValueInAny</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#mergeWhere">mergeWhere</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">drivers/relational/Connector.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import ntol from 'number-to-letter';
import { isPlainObject, isEmpty, snakeCase, isInteger, _, countOfChar } from '@kitmi/utils';
import { ApplicationError, InvalidArgument } from '@kitmi/types';

import Connector from '../../Connector';
import { isRawSql, extractRawSql } from '../../helpers';

class RelationalConnector extends Connector {
    /**
     * Create a new instance of the connector.
     * @param {App} app
     * @param {string} connectionString
     * @param {object} options
     * @property {boolean} [options.logStatement] - Flag to log executed SQL statement.
     * @property {boolean} [options.logConnection] - Flag to log connect and disconnect.
     * @property {boolean} [options.logTransaction] - Flag to log connect and disconnect.
     * @property {boolean} [options.verboseAlias] - Flag to use verbose alias.
     */
    constructor(app, driver, connectionString, options) {
        super(app, driver, connectionString, options);

        this.relational = true;
    }

    get specParamToken() {
        return `$?`;
    }

    /**
     * Run aggregate pipeline
     * @param {string} model
     * @param {array} pipeline
     * @param {object} [options]
     * @returns {*}
     */
    async aggregate_(model, pipeline, options, connection) {
        if (!Array.isArray(pipeline) || pipeline.length === 0) {
            throw new InvalidArgument('"pipeline" should be an unempty array.');
        }

        const [startingQuery, ..._pipeline] = pipeline;

        let query = this.buildQuery(model, startingQuery);

        _pipeline.forEach((stage, i) => {
            let _params = query.params;

            query = this.buildQuery(
                {
                    sql: query.sql,
                    alias: `_STAGE_${i}`,
                },
                stage
            );

            query.params = _params.concat(query.params);
        });

        return this._executeQuery_(query, options, connection);
    }

    /**
     * Build CTE header and return the select from target and CTE header
     * @param {string} model
     * @returns {object} { fromTable, withTables, model }
     */
    _buildCTEHeader(model) {
        let fromTable = this.escapeId(model);
        let withTables = '';

        // CTE, used by aggregation
        if (typeof model === 'object') {
            const { sql: subSql, alias } = model;

            model = alias;
            fromTable = alias;
            withTables = `WITH ${alias} AS (${subSql}) `;
        }

        return { fromTable, withTables, model };
    }

    /**
     * Generate an alias
     * @param {*} index
     * @param {*} anchor
     * @returns {string}
     */
    _generateAlias(index, anchor) {
        if (this.options.verboseAlias) {
            return `${snakeCase(anchor).toUpperCase()}${index}`;
        }

        return ntol(index);
    }

    /**
     * SQL condition representation
     *   Rules:
     *     default:
     *        array: OR
     *        kv-pair: AND
     *     $all:
     *        array: AND
     *     $any:
     *        kv-pair: OR
     *     $not:
     *        array: not ( or )
     *        kv-pair: not ( and )
     * @param {object|array|string} condition - The condition object
     * @param {array} params - The parameters array
     * @param {string} joinOperator - 'AND' or 'OR'
     * @param {string} mainEntity - The entity name that has joining
     * @param {object} aliasMap - The alias map, dot separated key -> alias
     * @returns {string}
     */
    _joinCondition(condition, params, joinOperator, mainEntity, aliasMap) {
        if (Array.isArray(condition)) {
            if (!joinOperator) {
                joinOperator = 'OR';
            }
            return condition
                .map((c) => '(' + this._joinCondition(c, params, null, mainEntity, aliasMap) + ')')
                .join(` ${joinOperator} `);
        }

        if (isPlainObject(condition)) {
            if (condition.$xr) {
                return this._packValue(condition, params, mainEntity, aliasMap);
            }

            if (!joinOperator) {
                joinOperator = 'AND';
            }

            return _.map(condition, (value, key) => {
                if (key === '$all' || key === '$and' || key.startsWith('$and_')) {
                    // for avoiding duplicate, $and_1, $and_2 is valid
                    if (!Array.isArray(value) &amp;&amp; !isPlainObject(value)) {
                        throw new Error('"$and" operator value should be an array or plain object.');
                    }

                    return '(' + this._joinCondition(value, params, 'AND', mainEntity, aliasMap) + ')';
                }

                if (key === '$any' || key === '$or' || key.startsWith('$or_')) {
                    // for avoiding dupliate, $or_1, $or_2 is valid
                    if (!Array.isArray(value) &amp;&amp; !isPlainObject(value)) {
                        throw new Error('"$or" operator value should be an array or plain object.');
                    }

                    return '(' + this._joinCondition(value, params, 'OR', mainEntity, aliasMap) + ')';
                }

                if (key === '$not' || key.startsWith('$not_')) {
                    if (Array.isArray(value)) {
                        if (value.length === 0) {
                            throw new Error('"$not" operator value should be non-empty.');
                        }

                        return 'NOT (' + this._joinCondition(value, params, null, mainEntity, aliasMap) + ')';
                    }

                    if (isPlainObject(value)) {
                        if (isEmpty(value)) {
                            throw new Error('"$not" operator value should be non-empty.');
                        }

                        return 'NOT (' + this._joinCondition(value, params, null, mainEntity, aliasMap) + ')';
                    }

                    if (typeof value !== 'string') {
                        throw new Error('Unsupported condition!');
                    }

                    return 'NOT (' + condition + ')';
                }

                if ((key === '$expr' || key.startsWith('$expr_')) &amp;&amp; value.$xr) {
                    if (value.$xr === 'BinExpr') {
                        const left = this._packValue(value.left, params, mainEntity, aliasMap);
                        const right = this._packValue(value.right, params, mainEntity, aliasMap);
                        return left + ` ${value.op} ` + right;
                    }

                    if (value.$xr === 'Raw') {
                        if (value.params) {
                            const numParamTokens = countOfChar(value.value, this.specParamToken);
                            if (numParamTokens !== value.params.length) {
                                throw new InvalidArgument('Parameter placeholder count mismatch in raw SQL expression.', {
                                    expected: value.params.length,
                                    actual: numParamTokens
                                });
                            }

                            params.push(...value.params);
                        }
                        
                        return value.value;
                    }
                }

                return this._wrapCondition(key, value, params, mainEntity, aliasMap);
            }).join(` ${joinOperator} `);
        }

        if (typeof condition !== 'string') {
            throw new Error('Unsupported condition!\n Value: ' + JSON.stringify(condition));
        }

        return condition;
    }

    /**
     * Build limit and offset clause
     * @param {*} $limit
     * @param {*} $offset
     * @param {*} params
     * @returns {string} '' or ' LIMIT X OFFSET Y'
     */
    _buildLimitOffset($limit, $offset, params) {
        let sql = '';

        if (isInteger($limit) &amp;&amp; $limit > 0) {
            if (isInteger($offset) &amp;&amp; $offset > 0) {
                params.push($offset);
                sql = ` OFFSET ${this.specParamToken} LIMIT ${this.specParamToken}`;
                params.push($limit);
            } else {
                params.push($limit);
                sql = ` LIMIT ${this.specParamToken}`;
            }
        } else if (isInteger($offset) &amp;&amp; $offset > 0) {
            params.push($offset);
            sql = ` OFFSET ${this.specParamToken}`;
        }

        return sql;
    }

    /**
     * Convert the dot separated field name to alias padded and escaped field name
     * @param {string} fieldName - The dot separate field name or starting with "::" for skipping alias padding
     * @param {string} mainEntity - Only called when mainEntity != null
     * @param {*} aliasMap
     * @returns {string}
     */
    _replaceFieldNameWithAlias(fieldName, mainEntity, aliasMap) {
        if (fieldName.startsWith('::')) {
            // ::fieldName for skipping alias padding
            return this.escapeId(fieldName.substring(2));
        }

        const rpos = fieldName.lastIndexOf('.');
        if (rpos > 0) {
            const actualFieldName = fieldName.substring(rpos + 1);

            const aliasKey = mainEntity + '.' + fieldName.substring(0, rpos);

            return this._buildAliasedColumn(aliasMap, aliasMap[aliasKey], mainEntity, fieldName, actualFieldName);
        }

        if (aliasMap[fieldName] === fieldName) {
            throw new Error('To be reviewed.');
            return this.escapeId(fieldName);
        }

        return this._buildAliasedColumn(aliasMap, aliasMap[mainEntity], mainEntity, fieldName, fieldName);
    }

    _buildAliasedColumn(aliasMap, alias, mainEntity, fieldName, actualFieldName) {
        if (!alias) {
            throw new InvalidArgument(`Column reference "${fieldName}" not found in populated associations.`, {
                entity: mainEntity,
                aliasMap,
            });
        }

        if (typeof alias === 'object') {
            return (
                alias.outer + '.' + (actualFieldName === '*' ? '*' : this.escapeId(`${alias.inner}_${actualFieldName}`))
            );
        }

        return alias + '.' + (actualFieldName === '*' ? '*' : this.escapeId(actualFieldName));
    }

    /**
     * Escape the field name with alias, skip if the field name is "*"
     * @param {string} fieldName
     * @param {string} mainEntity
     * @param {object} aliasMap
     * @returns {string}
     */
    _escapeIdWithAlias(fieldName, mainEntity, aliasMap) {
        if (mainEntity) {
            return this._replaceFieldNameWithAlias(fieldName, mainEntity, aliasMap);
        }

        return fieldName === '*' ? fieldName : this.escapeId(fieldName);
    }

    _splitColumnsAsInput(data, params, mainEntity, aliasMap) {
        return _.map(data, (v, fieldName) => {
            return (
                this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +
                '=' +
                this._packValue(v, params, mainEntity, aliasMap)
            );
        });
    }

    /**
     * Pack an array of values into params and return the parameterized string with placeholders
     * @param {*} array
     * @param {*} params
     * @param {*} mainEntity
     * @param {*} aliasMap
     * @returns {string}
     */
    _packArray(array, params, mainEntity, aliasMap) {
        return array.map((value) => this._packValue(value, params, mainEntity, aliasMap)).join(',');
    }

    /**
     * Pack a value into params and return the parameter placeholder
     * @param {*} value
     * @param {*} params
     * @param {*} mainEntity
     * @param {*} aliasMap
     * @returns {string}
     */
    _packValue(value, params, mainEntity, aliasMap) {
        if (isPlainObject(value)) {
            if (value.$xr) {
                switch (value.$xr) {
                    case 'Column':
                        return this._escapeIdWithAlias(value.name, mainEntity, aliasMap);

                    case 'Function':
                        return (
                            value.name +
                            '(' +
                            (value.args ? this._packArray(value.args, params, mainEntity, aliasMap) : '') +
                            ')'
                        );

                    case 'Raw':
                        return value.value;

                    case 'Query':
                        return this._joinCondition(value.query, params, null, mainEntity, aliasMap);

                    case 'BinExpr': {
                        const left = this._packValue(value.left, params, mainEntity, aliasMap);
                        const right = this._packValue(value.right, params, mainEntity, aliasMap);
                        return '(' + left + ` ${value.op} ` + right + ')';
                    }

                    default:
                        throw new Error(`Unknown xeml runtime type: ${value.$xr}, value: ${JSON.stringify(value)}`);
                }
            }
        }

        params.push(value);
        return this.specParamToken;
    }

    /**
     * Wrap a condition clause
     *
     * Value can be a literal or a plain condition object.
     *   1. fieldName, &lt;literal>
     *   2. fieldName, { normal object }
     *
     * @param {string} fieldName - The field name in a condition object.
     * @param {*} value
     * @param {array} params - The parameters array
     * @param {string} mainEntity - The entity name that has joining
     * @param {object} aliasMap - The alias map, dot separated key -> alias
     * @param {boolean} [inject=false] - Whether to inject the value directly
     * @returns {string}
     */
    _wrapCondition(fieldName, value, params, mainEntity, aliasMap, inject) {
        if (value == null) {
            return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' IS NULL';
        }

        if (Array.isArray(value)) {
            return this._wrapCondition(fieldName, { $in: value }, params, mainEntity, aliasMap, inject);
        }

        if (isPlainObject(value)) {
            if (value.$xr) {
                return (
                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +
                    ' = ' +
                    this._packValue(value, params, mainEntity, aliasMap)
                );
            }

            const hasOperator = _.find(Object.keys(value), (k) => k &amp;&amp; k[0] === '$');

            if (hasOperator) {
                return _.map(value, (v, k) => {
                    if (k &amp;&amp; k[0] === '$') {
                        // operator
                        switch (k) {
                            case '$exist':
                            case '$exists':
                                return (
                                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +
                                    (v ? ' IS NOT NULL' : 'IS NULL')
                                );

                            case '$eq':
                            case '$equal':
                                return this._wrapCondition(fieldName, v, params, mainEntity, aliasMap, inject);

                            case '$ne':
                            case '$neq':
                            case '$notEqual':
                                if (v == null) {
                                    return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' IS NOT NULL';
                                }

                                if (inject) {
                                    return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' &lt;> ' + v;
                                }

                                return (
                                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +
                                    ` &lt;> ${this._packValue(v, params, mainEntity, aliasMap)}`
                                );

                            case '$>':
                            case '$gt':
                            case '$greaterThan':
                                if (inject) {
                                    return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' > ' + v;
                                }

                                return (
                                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +
                                    ` > ${this._packValue(v, params, mainEntity, aliasMap)}`
                                );

                            case '$>=':
                            case '$gte':
                            case '$greaterThanOrEqual':
                                if (inject) {
                                    return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' >= ' + v;
                                }

                                return (
                                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +
                                    ` >= ${this._packValue(v, params, mainEntity, aliasMap)}`
                                );

                            case '$&lt;':
                            case '$lt':
                            case '$lessThan':
                                if (inject) {
                                    return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' &lt; ' + v;
                                }

                                return (
                                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +
                                    ` &lt; ${this._packValue(v, params, mainEntity, aliasMap)}`
                                );

                            case '$&lt;=':
                            case '$lte':
                            case '$lessThanOrEqual':
                                if (inject) {
                                    return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' &lt;= ' + v;
                                }

                                return (
                                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +
                                    ` &lt;= ${this._packValue(v, params, mainEntity, aliasMap)}`
                                );

                            case '$between':
                                if (!Array.isArray(v) || v.length !== 2) {
                                    throw new InvalidArgument(
                                        'The value should be an array with 2 elements when using "$between" operator.',
                                        {
                                            value: v,
                                        }
                                    );
                                }

                                if (inject) {
                                    return (
                                        this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +
                                        ` BETWEEN ${v[0]} AND ${v[1]}`
                                    );
                                }

                                params.push(v[0]);
                                params.push(v[1]);
                                return (
                                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +
                                    ` BETWEEN ${this.specParamToken} AND ${this.specParamToken}`
                                );

                            case '$notBetween':
                                if (!Array.isArray(v) || v.length !== 2) {
                                    throw new InvalidArgument(
                                        'The value should be an array with 2 elements when using "$notBetween" operator.',
                                        {
                                            value: v,
                                        }
                                    );
                                }

                                if (inject) {
                                    return (
                                        this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +
                                        ` NOT BETWEEN ${v[0]} AND ${v[1]}`
                                    );
                                }

                                params.push(v[0]);
                                params.push(v[1]);
                                return (
                                    this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +
                                    ` NOT BETWEEN ${this.specParamToken} AND ${this.specParamToken}`
                                );

                            case '$in':
                                if (isPlainObject(v) &amp;&amp; v.$xr === 'DataSet') {
                                    const sqlInfo = this.buildQuery(v.model, v.query);
                                    sqlInfo.params &amp;&amp; sqlInfo.params.forEach((p) => params.push(p));

                                    return (
                                        this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +
                                        ` IN (${sqlInfo.sql})`
                                    );
                                } else {
                                    if (!Array.isArray(v)) {
                                        throw new InvalidArgument(
                                            'The value should be a dataset or an array when using "$in" operator.',
                                            {
                                                value: v,
                                            }
                                        );
                                    }

                                    if (inject) {
                                        return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ` IN (${v})`;
                                    }

                                    params.push(v);
                                    return (
                                        this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +
                                        this.specInClause
                                    );
                                }

                            case '$nin':
                            case '$notIn':
                                if (isPlainObject(v) &amp;&amp; v.$xr === 'DataSet') {
                                    const sqlInfo = this.buildQuery(v.model, v.query);
                                    sqlInfo.params &amp;&amp; sqlInfo.params.forEach((p) => params.push(p));

                                    return (
                                        this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +
                                        ` NOT IN (${sqlInfo.sql})`
                                    );
                                } else {
                                    if (!Array.isArray(v)) {
                                        throw new InvalidArgument(
                                            'The value should be an array when using "$notIn" operator.',
                                            {
                                                value: v,
                                            }
                                        );
                                    }

                                    if (inject) {
                                        return (
                                            this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ` NOT IN (${v})`
                                        );
                                    }

                                    params.push(v);
                                    return (
                                        this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) +
                                        this.specNotInClause
                                    );
                                }

                            case '$startWith':
                            case '$startsWith':
                                if (typeof v !== 'string') {
                                    throw new InvalidArgument(
                                        'The value should be a string when using "$startWith" operator.',
                                        {
                                            value: v,
                                        }
                                    );
                                }

                                params.push(`${v}%`);
                                return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' LIKE ?';

                            case '$endWith':
                            case '$endsWith':
                                if (typeof v !== 'string') {
                                    throw new InvalidArgument(
                                        'The value should be a string when using "$endWith" operator.',
                                        {
                                            value: v,
                                        }
                                    );
                                }

                                params.push(`%${v}`);
                                return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' LIKE ?';

                            case '$like':
                            case '$likes':
                                if (typeof v !== 'string') {
                                    throw new InvalidArgument(
                                        'The value should be a string when using "$like" operator.',
                                        {
                                            value: v,
                                        }
                                    );
                                }

                                params.push(`%${v}%`);
                                return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' LIKE ' + this.specParamToken;

                            case '$filter':
                                if (typeof v !== 'object') {
                                    throw new InvalidArgument(
                                        'The value should be an object when using "$filter" operator.',
                                        {
                                            value: v,
                                        }
                                    );
                                }
                                params.push(v);                                
                                return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' @> ' + this.specParamToken;

                            default:
                                throw new Error(`Unsupported condition operator: "${k}"!`);
                        }
                    } else {
                        throw new Error('Operator should not be mixed with condition value.');
                    }
                }).join(' AND ');
            }

            params.push(JSON.stringify(value));
            return (
                this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' = ' + this.specParamToken
            );
        }

        if (inject) {
            return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' = ' + value;
        }

        params.push(value);
        return this._escapeIdWithAlias(fieldName, mainEntity, aliasMap) + ' = ' + this.specParamToken;
    }

    /**
     * Build column list
     * @param {array} columns
     * @param {array} params
     * @param {*} mainEntity
     * @param {*} aliasMap
     * @returns {string}
     */
    _buildColumns(columns, params, mainEntity, aliasMap) {
        return _.map(_.castArray(columns), (col) => this._buildColumn(col, params, mainEntity, aliasMap)).join(', ');
    }

    /**
     *
     * @param {string|number|object} col - The column object or string, quoted string will be treated as raw SQL
     * @property {string} [col.alias] - The alias of the column, can be a dot separated string
     * @property {string} [col.$xr] - The type of the column, "function" | "func", "expression" | "expr, "column" | "col"
     * @property {string} [col.name] - The column name
     * @property {string} [col.prefix] - The prefix of the function, like DISTINCT
     * @property {array} [col.args] - The arguments of the function
     * @property {object} [col.over] - The window function over clause
     * @property {array} [col.over.$partitionBy] - The partition by clause
     * @property {array} [col.over.$orderBy] - The order by clause
     * @property {string} [col.over.$nulls] - The nulls clause, FIRST | LAST
     * @param {*} params
     * @param {*} mainEntity
     * @param {*} aliasMap
     * @returns {string}
     */
    _buildColumn(col, params, mainEntity, aliasMap) {
        if (typeof col === 'string') {
            // it's a string if it's quoted when passed in
            return isRawSql(col) ? extractRawSql(col) : this._escapeIdWithAlias(col, mainEntity, aliasMap);
        }

        if (typeof col === 'number') {
            return col;
        }

        if (isPlainObject(col) &amp;&amp; col.$xr) {
            if (col.alias) {
                /*
                const lastDotIndex = col.alias.lastIndexOf('.');                
                let alias = lastDotIndex > 0 ? col.alias.substring(lastDotIndex + 1) : col.alias;

                if (lastDotIndex > 0) {
                    throw new Error('Not implemented yet!');

                    if (!mainEntity) {
                        throw new InvalidArgument(
                            'Cascade alias is not allowed when the query has no associated entity populated.',
                            {
                                alias: col.alias,
                            }
                        );
                    }

                    const fullPath = mainEntity + '.' + col.alias.substring(0, lastDotIndex);
                    const aliasPrefix = aliasMap[fullPath];
                    if (!aliasPrefix) {
                        throw new InvalidArgument(`Invalid cascade alias. "${fullPath}" not found in associations.`, {
                            alias: col.alias,
                        });
                    }

                    alias = aliasPrefix + '_' + alias;
                }

                aliasMap[col.alias] = alias;
                */

                return (
                    this._buildColumn(_.omit(col, ['alias']), params, mainEntity, aliasMap) +
                    ' AS ' +
                    this.escapeId(col.alias)
                );
            }

            if (col.$xr.startsWith('Fun')) {
                const name = col.name.toUpperCase();
                if (name === 'COUNT' &amp;&amp; col.args.length === 1 &amp;&amp; col.args[0] === '*') {
                    return 'COUNT(*)';
                }

                if (this.constructor.windowFunctions.has(name)) {
                    if (!col.over) {
                        throw new InvalidArgument(`"${name}" window function requires over clause.`);
                    }
                } else if (!this.constructor.windowableFunctions.has(name) &amp;&amp; col.over) {
                    throw new InvalidArgument(`"${name}" function does not support over clause.`);
                }

                let funcClause =
                    name +
                    '(' +
                    (col.prefix ? `${col.prefix.toUpperCase()} ` : '') +
                    (col.args ? this._buildColumns(col.args, params, mainEntity, aliasMap) : '') +
                    ')';

                if (col.over) {
                    funcClause += ' OVER(';
                    if (col.over.$partitionBy) {
                        funcClause += this._buildPartitionBy(col.over.$partitionBy, mainEntity, aliasMap);
                    }

                    if (col.over.$orderBy) {
                        if (!funcClause.endsWith('(')) {
                            funcClause += ' ';
                        }
                        funcClause += this._buildOrderBy(col.over.$orderBy, mainEntity, aliasMap);
                    }

                    if (col.over.$nulls) {
                        funcClause += ' NULLS ' + col.over.$nulls; // FIRST | LAST
                    }

                    funcClause += ')';
                }

                return funcClause;
            }

            // Condition
            if (col.$xr.startsWith('Con')) {
                return this._joinCondition(col.expr, params, null, mainEntity, aliasMap);
            }

            // Column
            if (col.$xr.startsWith('Col')) {
                return this._escapeIdWithAlias(col.name, mainEntity, aliasMap);
            }
        }

        throw new ApplicationError(`Unknow column syntax: ${JSON.stringify(col)}`);
    }

    /**
     * Build group by column
     * @param {string|object} groupBy
     * @param {*} mainEntity
     * @param {*} aliasMap
     * @returns {string}
     */
    _buildGroupByColumn(groupBy, mainEntity, aliasMap) {
        if (typeof groupBy === 'string') {
            return isRawSql(groupBy) ? extractRawSql(groupBy) : this._escapeIdWithAlias(groupBy, mainEntity, aliasMap);
        }

        if (typeof groupBy === 'object') {
            if (groupBy.alias) {
                return this._escapeIdWithAlias(groupBy.alias, mainEntity, aliasMap);
            }
        }

        throw new ApplicationError(`Unknown GROUP BY syntax: ${JSON.stringify(groupBy)}`);
    }

    /**
     * Build group by column list
     * @param {array|string} groupBy
     * @param {*} mainEntity
     * @param {*} aliasMap
     * @returns {string}
     */
    _buildGroupByList(groupBy, mainEntity, aliasMap) {
        if (Array.isArray(groupBy)) {
            return 'GROUP BY ' + groupBy.map((by) => this._buildGroupByColumn(by, mainEntity, aliasMap)).join(', ');
        }

        return 'GROUP BY ' + this._buildGroupByColumn(groupBy, mainEntity, aliasMap);
    }

    /**
     * Build group by clause from groupBy object
     * @param {object|array|string} groupBy
     * @property {array} [groupBy.columns] - The columns to group by
     * @property {object} [groupBy.having] - The having condition
     * @param {*} params
     * @param {string} [mainEntity] - The entity name that has joining
     * @param {*} aliasMap
     * @returns {string}
     */
    _buildGroupBy(groupBy, params, mainEntity, aliasMap) {
        if (isPlainObject(groupBy)) {
            const { columns, having } = groupBy;

            if (!columns || !Array.isArray(columns)) {
                throw new ApplicationError(`Invalid group by syntax: ${JSON.stringify(groupBy)}`);
            }

            let groupByClause = this._buildGroupByList(columns, mainEntity, aliasMap);
            const havingCluse = having &amp;&amp; this._joinCondition(having, params, null, mainEntity, aliasMap);
            if (havingCluse) {
                groupByClause += ' HAVING ' + havingCluse;
            }

            return groupByClause;
        }

        return this._buildGroupByList(groupBy, mainEntity, aliasMap);
    }

    /**
     * Build partition by clause
     * @param {*} partitionBy
     * @param {*} mainEntity
     * @param {*} aliasMap
     * @returns {string}
     */
    _buildPartitionBy(partitionBy, mainEntity, aliasMap) {
        if (typeof partitionBy === 'string') {
            return 'PARTITION BY ' + this._escapeIdWithAlias(partitionBy, mainEntity, aliasMap);
        }

        if (Array.isArray(partitionBy)) {
            return (
                'PARTITION BY ' + partitionBy.map((by) => this._escapeIdWithAlias(by, mainEntity, aliasMap)).join(', ')
            );
        }

        throw new ApplicationError(`Unknown PARTITION BY syntax: ${JSON.stringify(partitionBy)}`);
    }

    /**
     * Build order by clause
     * @param {string|array|object} orderBy
     * @param {*} mainEntity
     * @param {*} aliasMap
     * @returns {string}
     *
     * @example
     * $orderBy: 'name' => 'ORDER BY A.name'
     * $orderBy: ['name', 'age'] => 'ORDER BY A.name, A.age'
     * $orderBy: { name: -1, age: 1 } => 'ORDER BY A.name DESC, A.age ASC'
     */
    _buildOrderBy(orderBy, mainEntity, aliasMap) {
        if (typeof orderBy === 'string') {
            return 'ORDER BY ' + this._escapeIdWithAlias(orderBy, mainEntity, aliasMap);
        }

        if (Array.isArray(orderBy))
            return 'ORDER BY ' + orderBy.map((by) => this._escapeIdWithAlias(by, mainEntity, aliasMap)).join(', ');

        if (isPlainObject(orderBy)) {
            return (
                'ORDER BY ' +
                _.map(
                    orderBy,
                    (asc, col) =>
                        this._escapeIdWithAlias(col, mainEntity, aliasMap) +
                        (asc === false || asc === -1 ? ' DESC' : '')
                ).join(', ')
            );
        }

        throw new ApplicationError(`Unknown ORDER BY syntax: ${JSON.stringify(orderBy)}`);
    }
}

export default RelationalConnector;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.3</a> on Thu Jun 27 2024 14:06:47 GMT+0800 (China Standard Time) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
