{"version":3,"sources":["../src/transformers.js"],"sourcesContent":["// JSON Expression Syntax (JES)\nimport { remap, isPlainObject, get as _get, template, filterNull, objectToArray, toNumber } from '@kitmi/utils';\nimport { Types, typeOf } from '@kitmi/types';\nimport { validate, test, OP as v_ops, getChildContext } from '@kitmi/jsonv';\nimport transform, { processExprLikeValue, processExprLikeValueWithLeft } from '@kitmi/jsonv/transform';\nimport { matchOptions } from '@kitmi/jsonv/transformersLoader';\n\nimport _size from 'lodash/size';\nimport _reduce from 'lodash/reduce';\nimport _reverse from 'lodash/reverse';\nimport _keys from 'lodash/keys';\nimport _values from 'lodash/values';\nimport _pick from 'lodash/pick';\nimport _pickBy from 'lodash/pickBy';\nimport _nth from 'lodash/nth';\nimport _omit from 'lodash/omit';\nimport _omitBy from 'lodash/omitBy';\nimport _groupBy from 'lodash/groupBy';\nimport _sortBy from 'lodash/sortBy';\nimport _filter from 'lodash/filter';\nimport _map from 'lodash/map';\nimport _mapValues from 'lodash/mapValues';\nimport _findIndex from 'lodash/findIndex';\nimport _findKey from 'lodash/findKey';\nimport _find from 'lodash/find';\nimport _isEqual from 'lodash/isEqual';\nimport _each from 'lodash/each';\nimport _castArray from 'lodash/castArray';\n\nimport ops from './transformerOperators';\n\nconst UNARY = true;\nconst BINARY = false;\n\n//Query & aggregate operators (pure)\nconst OP_SIZE = [ops.SIZE, UNARY, '$size', '$length', '$count'];\nconst OP_SUM = [ops.SUM, UNARY, '$sum', '$total'];\nconst OP_GET_TYPE = [ops.GET_TYPE, UNARY, '$type', '$typeOf'];\nconst OP_FIND_INDEX = [ops.FIND_INDEX, BINARY, '$findIndex', '$findKey'];\nconst OP_FIND = [ops.FIND, BINARY, '$find'];\nconst OP_IF = [ops.IF, BINARY, '$if'];\nconst OP_CAST_ARRAY = [ops.CAST_ARRAY, UNARY, '$castArray', '$makeArray'];\n\n//Math operators (pure)\nconst OP_ADD = [ops.ADD, BINARY, '$add', '$plus', '$inc', '$+'];\nconst OP_SUB = [ops.SUB, BINARY, '$sub', '$subtract', '$minus', '$dec', '$-'];\nconst OP_MUL = [ops.MUL, BINARY, '$mul', '$multiply', '$times', '$*'];\nconst OP_DIV = [ops.DIV, BINARY, '$div', '$divide', '$/'];\nconst OP_MOD = [ops.MOD, BINARY, '$mod', '$remainder', '$%'];\nconst OP_POW = [ops.POW, BINARY, '$pow', '$power', '$^'];\n\n//Collection operators (pure)\nconst OP_KEYS = [ops.KEYS, UNARY, '$keys'];\nconst OP_VALUES = [ops.VALUES, UNARY, '$values'];\nconst OP_ENTRIES = [ops.ENTRIES, UNARY, '$entries', '$pairs'];\nconst OP_FILTER_NULL = [ops.FILTER_NULL, UNARY, '$filterNull', '$filterNullValues'];\n\nconst OP_OBJ_TO_ARRAY = [ops.OBJ_TO_ARRAY, BINARY, '$toArray', '$objectToArray'];\nconst OP_PICK = [ops.PICK, BINARY, '$pick', '$pickBy', '$selectByKeys']; // filter by key\nconst OP_OMIT = [ops.OMIT, BINARY, '$omit', '$omitBy', '$excludeByKeys'];\nconst OP_SLICE = [ops.SLICE, BINARY, '$slice', '$limit'];\nconst OP_GROUP = [ops.GROUP, BINARY, '$group', '$groupBy'];\nconst OP_SORT = [ops.SORT, BINARY, '$sort', '$orderBy', '$sortBy'];\nconst OP_REVERSE = [ops.REVERSE, UNARY, '$reverse'];\nconst OP_CONCAT = [ops.CONCAT, BINARY, '$concat'];\nconst OP_JOIN = [ops.JOIN, BINARY, '$join', '$implode'];\nconst OP_MERGE = [ops.MERGE, BINARY, '$merge', '$reduce']; // merge a list of transform result over the value\nconst OP_FILTER = [ops.FILTER, BINARY, '$filter', '$select', '$filterByValue']; // filter by value\nconst OP_REMAP = [ops.REMAP, BINARY, '$remap', '$mapKeys']; // reverse-map, map a key to another name\nconst OP_TO_JSON = [ops.TO_JSON, UNARY, '$json', '$toJSON', '$stringify'];\nconst OP_TO_OBJ = [ops.TO_OBJ, UNARY, '$object', '$toObject', '$parseJSON'];\n\n//Value updater (pure)\nconst OP_SET = [ops.SET, BINARY, '$set', '$=', '$value'];\nconst OP_ADD_ITEM = [ops.ADD_ITEM, BINARY, '$addItem', '$addFields', '$append'];\nconst OP_ASSIGN = [ops.ASSIGN, BINARY, '$assign', '$override']; // will delete undefined entries\nconst OP_CREATE = [ops.CREATE, BINARY, '$new', '$create']; // create an object based on left value\nconst OP_APPLY = [ops.APPLY, BINARY, '$apply', '$eval']; // to be used in collection, e.g. |>$apply\n\nconst OP_SANITIZE = [ops.SANITIZE, BINARY, '$sanitize'];\n\n//String manipulate\nconst OP_SPLIT = [ops.SPLIT, BINARY, '$split', '$explode'];\nconst OP_INTERPOLATE = [ops.INTERPOLATE, BINARY, '$interpolate', '$template'];\n\nfunction transformersFactory(config) {\n    const MSG = config.messages;\n\n    config.addTransformerToMap(OP_SIZE, (left) => _size(left));\n\n    config.addTransformerToMap(OP_SUM, (left) =>\n        _reduce(\n            left,\n            (sum, item) => {\n                sum += item;\n                return sum;\n            },\n            0\n        )\n    );\n\n    config.addTransformerToMap(OP_GET_TYPE, (left) => typeOf(left));\n\n    config.addTransformerToMap(OP_FIND_INDEX, (left, right, context) => {\n        let jvs;\n        let fromIndex = 0;\n\n        if (Array.isArray(right)) {\n            if (!Array.isArray(left)) {\n                throw new Error(MSG.INVALID_OP_EXPR(ops.FIND_INDEX));\n            }\n\n            if (right.length !== 2) {\n                throw new Error(MSG.OPERAND_NOT_TUPLE(ops.FIND_INDEX));\n            }\n\n            jvs = right[0];\n            fromIndex = processExprLikeValue(right[1], context);\n        } else {\n            jvs = right;\n        }\n\n        const predicate = (value, key) =>\n            validate(value, jvs, matchOptions, getChildContext(context, left, key, value));\n\n        return Array.isArray(left) ? _findIndex(left, predicate, fromIndex) : _findKey(left, predicate);\n    });\n\n    config.addTransformerToMap(OP_FIND, (left, right, context) => {\n        let jvs;\n        let fromIndex = 0;\n\n        if (Array.isArray(right)) {\n            if (right.length !== 2) {\n                throw new Error(MSG.OPERAND_NOT_TUPLE(ops.FIND_INDEX));\n            }\n\n            jvs = right[0];\n            fromIndex = processExprLikeValue(right[1], context);\n        } else {\n            jvs = right;\n        }\n\n        const predicate = (value, key) =>\n            validate(value, jvs, matchOptions, getChildContext(context, left, key, value));\n\n        return _find(left, predicate, fromIndex);\n    });\n\n    config.addTransformerToMap(OP_IF, (left, right, context) => {\n        if (!Array.isArray(right)) {\n            throw new Error(MSG.OPERAND_NOT_ARRAY(ops.IF));\n        }\n\n        if (right.length < 2 || right.length > 3) {\n            throw new Error(MSG.OPERAND_NOT_TUPLE_2_OR_3(ops.IF));\n        }\n\n        const condition = transform(left, right[0], context);\n\n        if (typeof condition !== 'boolean') {\n            throw new Error(MSG.VALUE_NOT_BOOL(ops.IF));\n        }\n\n        if (condition) {\n            return transform(left, right[1], context);\n        } else if (right.length > 2) {\n            return transform(left, right[2], context);\n        }\n\n        return left;\n    });\n\n    config.addTransformerToMap(OP_CAST_ARRAY, (left) => (left == null ? null : Array.isArray(left) ? left : [left]));\n\n    config.addTransformerToMap(OP_ADD, (left, right, context) => left + toNumber(processExprLikeValue(right, context)));\n    config.addTransformerToMap(OP_SUB, (left, right, context) => left - toNumber(processExprLikeValue(right, context)));\n    config.addTransformerToMap(OP_MUL, (left, right, context) => left * toNumber(processExprLikeValue(right, context)));\n    config.addTransformerToMap(OP_DIV, (left, right, context) => left / toNumber(processExprLikeValue(right, context)));\n    config.addTransformerToMap(OP_MOD, (left, right, context) => left % toNumber(processExprLikeValue(right, context)));\n    config.addTransformerToMap(\n        OP_POW,\n        (left, right, context) => left ** toNumber(processExprLikeValue(right, context))\n    );\n\n    config.addTransformerToMap(OP_KEYS, (left) => _keys(left));\n    config.addTransformerToMap(OP_VALUES, (left) => _values(left));\n    config.addTransformerToMap(OP_ENTRIES, (left) => _map(left, (value, key) => [key, value]));\n    config.addTransformerToMap(OP_OBJ_TO_ARRAY, (left, right, context) => {\n        if (right == null) {\n            return objectToArray(left);\n        }\n\n        return _map(left, (v, k) => transform(v, { $create: right }, getChildContext(context, left, k, v)));\n    });\n    config.addTransformerToMap(OP_FILTER_NULL, (left) => filterNull(left));\n\n    config.addTransformerToMap(OP_PICK, (left, right, context) => {\n        if (left == null) {\n            return null;\n        }\n\n        if (typeof right !== 'object') {\n            right = [right];\n        }\n\n        if (Array.isArray(right)) {\n            return _pick(left, right);\n        }\n\n        return _pickBy(left, (item, key) =>\n            test(key, v_ops.MATCH, right, matchOptions, getChildContext(context, left, key, item))\n        );\n    });\n\n    config.addTransformerToMap(OP_OMIT, (left, right, context) => {\n        if (left == null) {\n            return null;\n        }\n\n        if (typeof right !== 'object') {\n            right = [right];\n        }\n\n        if (Array.isArray(right)) {\n            return _omit(left, right);\n        }\n\n        return _omitBy(left, (item, key) =>\n            test(key, v_ops.MATCH, right, matchOptions, getChildContext(context, left, key, item))\n        );\n    });\n\n    config.addTransformerToMap(OP_SLICE, (left, right) => {\n        if (left == null) {\n            return null;\n        }\n\n        if (!Array.isArray(left)) {\n            return new Error(MSG.VALUE_NOT_ARRAY(ops.SLICE));\n        }\n\n        if (Number.isInteger(right)) {\n            return left.slice(right);\n        }\n\n        if (Array.isArray(right)) {\n            if (right.length === 0 || right.length > 2) {\n                return new Error(MSG.INVALID_OP_EXPR(ops.SLICE, right, ['integer', '[integer]']));\n            }\n\n            return left.slice(...right);\n        }\n\n        return new Error(MSG.INVALID_OP_EXPR(ops.SLICE, right));\n    });\n\n    config.addTransformerToMap(OP_GROUP, (left, right) => _groupBy(left, right));\n    config.addTransformerToMap(OP_SORT, (left, right) => _sortBy(left, right));\n    config.addTransformerToMap(OP_REVERSE, (left) => _reverse(left));\n\n    config.addTransformerToMap(OP_CONCAT, (left, right) => {\n        if (left == null) {\n            left = '';\n        }\n\n        right = processExprLikeValue(right);\n        if (right == null) {\n            right = '';\n        } else if (Array.isArray(right)) {\n            right = right.join('');\n        } else if (typeof right !== 'string') {\n            throw new Error(MSG.VALUE_NOT_STRING(ops.CONCAT));\n        }\n\n        return left + right;\n    });\n\n    config.addTransformerToMap(OP_JOIN, (left, right) => {\n        if (left == null) {\n            return null;\n        }\n        if (!Array.isArray(left)) {\n            throw new Error(MSG.VALUE_NOT_ARRAY(ops.JOIN));\n        }\n\n        right = processExprLikeValue(right);\n        if (typeof right !== 'string') {\n            throw new Error(MSG.VALUE_NOT_STRING(ops.JOIN));\n        }\n\n        return left.join(right);\n    });\n\n    const objectMerger = (left, context) => [\n        (result, expr) => Object.assign(result, transform(left, expr, context)),\n        {},\n    ];\n\n    const arrayMerger = (left, context) => [\n        (result, expr) => [...result, ..._castArray(transform(left, expr, context))],\n        [],\n    ];\n\n    config.addTransformerToMap(OP_MERGE, (left, right, context) => {\n        if (!Array.isArray(right)) {\n            throw new Error(MSG.OPERAND_NOT_ARRAY(ops.MERGE));\n        }\n\n        return right.reduce(...(Array.isArray(left) ? arrayMerger(left, context) : objectMerger(left, context)));\n    });\n\n    config.addTransformerToMap(OP_FILTER, (left, right, context) => {\n        if (left == null) {\n            return null;\n        }\n\n        if (typeof left !== 'object') {\n            throw new Error(MSG.VALUE_NOT_COLLECTION(ops.FILTER));\n        }\n\n        return _filter(left, (value, key) =>\n            test(value, v_ops.MATCH, right, matchOptions, getChildContext(context, left, key, value))\n        );\n    });\n    config.addTransformerToMap(OP_REMAP, (left, right) => {\n        if (left == null) {\n            return null;\n        }\n\n        if (typeof left !== 'object') {\n            throw new Error(MSG.VALUE_NOT_COLLECTION(ops.REMAP));\n        }\n\n        if (Array.isArray(right)) {\n            if (right.length !== 2) {\n                throw new Error(MSG.OPERAND_NOT_TUPLE(ops.REMAP));\n            }\n\n            if (!isPlainObject(right[0]) || (right[1] != null && typeof right[1] !== 'boolean')) {\n                throw new Error(MSG.INVALID_OP_EXPR(ops.REMAP, right, ['object', 'boolean']));\n            }\n\n            return remap(left, right[0], right[1]);\n        }\n\n        if (!isPlainObject(right)) {\n            throw new Error(MSG.OPERAND_NOT_OBJECT(ops.REMAP));\n        }\n\n        return remap(left, right);\n    });\n\n    config.addTransformerToMap(OP_TO_JSON, (left) => (left == null ? left : JSON.stringify(left)));\n    config.addTransformerToMap(OP_TO_OBJ, (left) => (left == null ? left : JSON.parse(left)));\n\n    config.addTransformerToMap(OP_SET, (left, right, context) => transform(undefined, right, context, true));\n    config.addTransformerToMap(OP_ADD_ITEM, (left, right, context) => {\n        if (typeof left !== 'object') {\n            throw new Error(MSG.VALUE_NOT_COLLECTION(ops.ADD_ITEM));\n        }\n\n        if (Array.isArray(left)) {\n            return left.concat(processExprLikeValueWithLeft(left, right, context));\n        }\n\n        if (!Array.isArray(right) || right.length !== 2) {\n            throw new Error(MSG.OPERAND_NOT_TUPLE(ops.ADD_ITEM));\n        }\n\n        const key = processExprLikeValueWithLeft(left, right[0], context);\n        if (typeof key !== 'string') {\n            throw new Error(MSG.INVALID_OP_EXPR(ops.ADD_ITEM, right, ['string', 'any']));\n        }\n\n        return {\n            ...left,\n            [key]: processExprLikeValueWithLeft(left, right[1], context),\n        };\n    });\n    config.addTransformerToMap(OP_ASSIGN, (left, right, context) => {\n        if (!isPlainObject(left)) {\n            if (left == null) {\n                left = {};\n            } else {\n                throw new Error(MSG.VALUE_NOT_OBJECT(ops.ASSIGN));\n            }\n        }\n\n        if (!isPlainObject(right)) {\n            throw new Error(MSG.OPERAND_NOT_OBJECT(ops.ASSIGN));\n        }\n\n        const rightValue = _mapValues(right, (expr, key) => {\n            const leftValue = left[key];\n            return processExprLikeValueWithLeft(leftValue, expr, getChildContext(context, left, key, leftValue));\n        });\n\n        const toRemove = [];\n        _each(rightValue, (value, key) => {\n            if (value === undefined) {\n                toRemove.push(key);\n            }\n        });\n\n        const merged = { ...left, ...rightValue };\n\n        return toRemove.length > 0 ? _omit(merged, toRemove) : merged;\n    });\n    config.addTransformerToMap(OP_CREATE, (left, right, context) => {\n        return _mapValues(right, (expr) => transform(left, expr, context));\n    });\n\n    config.addTransformerToMap(OP_APPLY, transform);\n\n    config.addTransformerToMap(OP_SANITIZE, (left, right, context) => {\n        return Types.sanitize(left, transform(undefined, right, context, true));\n    });\n\n    config.addTransformerToMap(OP_SPLIT, (left, right) => {\n        if (typeof left !== 'string') {\n            throw new Error(MSG.VALUE_NOT_STRING(ops.SPLIT));\n        }\n\n        if (Array.isArray(right)) {\n            if (right.length !== 2) {\n                throw new Error(MSG.OPERAND_NOT_TUPLE(ops.SPLIT));\n            }\n\n            const [separator, limit] = right;\n\n            if (typeof separator !== 'string' || (limit != null && typeof limit !== 'number')) {\n                throw new Error(MSG.INVALID_OP_EXPR(ops.SPLIT, right, ['string', 'number']));\n            }\n\n            return left.split(separator, limit);\n        } else if (typeof right !== 'string') {\n            throw new Error(MSG.OPERAND_NOT_STRING(ops.SPLIT));\n        }\n\n        return left.split(right);\n    });\n\n    const esTemplateSetting = {\n        interpolate: /\\$\\{([\\s\\S]+?)\\}/g,\n    };\n\n    config.addTransformerToMap(OP_INTERPOLATE, (left, right) => {\n        if (typeof left !== 'string') {\n            throw new Error(MSG.VALUE_NOT_STRING(ops.INTERPOLATE));\n        }\n\n        if (right != null && typeof right !== 'object') {\n            throw new Error(MSG.OPERAND_NOT_OBJECT(ops.INTERPOLATE));\n        }\n\n        if (Array.isArray(right)) {\n            if (right.length !== 2) {\n                throw new Error(MSG.OPERAND_NOT_TUPLE(ops.INTERPOLATE));\n            }\n\n            return template(left, right[0], right[1] === 'es6' ? esTemplateSetting : right[1]);\n        }\n\n        return template(left, right);\n    });\n}\n\nexport default transformersFactory;"],"names":["UNARY","BINARY","OP_SIZE","ops","SIZE","OP_SUM","SUM","OP_GET_TYPE","GET_TYPE","OP_FIND_INDEX","FIND_INDEX","OP_FIND","FIND","OP_IF","IF","OP_CAST_ARRAY","CAST_ARRAY","OP_ADD","ADD","OP_SUB","SUB","OP_MUL","MUL","OP_DIV","DIV","OP_MOD","MOD","OP_POW","POW","OP_KEYS","KEYS","OP_VALUES","VALUES","OP_ENTRIES","ENTRIES","OP_FILTER_NULL","FILTER_NULL","OP_OBJ_TO_ARRAY","OBJ_TO_ARRAY","OP_PICK","PICK","OP_OMIT","OMIT","OP_SLICE","SLICE","OP_GROUP","GROUP","OP_SORT","SORT","OP_REVERSE","REVERSE","OP_CONCAT","CONCAT","OP_JOIN","JOIN","OP_MERGE","MERGE","OP_FILTER","FILTER","OP_REMAP","REMAP","OP_TO_JSON","TO_JSON","OP_TO_OBJ","TO_OBJ","OP_SET","SET","OP_ADD_ITEM","ADD_ITEM","OP_ASSIGN","ASSIGN","OP_CREATE","CREATE","OP_APPLY","APPLY","OP_SANITIZE","SANITIZE","OP_SPLIT","SPLIT","OP_INTERPOLATE","INTERPOLATE","transformersFactory","config","MSG","messages","addTransformerToMap","left","_size","_reduce","sum","item","typeOf","right","context","jvs","fromIndex","Array","isArray","Error","INVALID_OP_EXPR","length","OPERAND_NOT_TUPLE","processExprLikeValue","predicate","value","key","validate","matchOptions","getChildContext","_findIndex","_findKey","_find","OPERAND_NOT_ARRAY","OPERAND_NOT_TUPLE_2_OR_3","condition","transform","VALUE_NOT_BOOL","toNumber","_keys","_values","_map","objectToArray","v","k","$create","filterNull","_pick","_pickBy","test","v_ops","MATCH","_omit","_omitBy","VALUE_NOT_ARRAY","Number","isInteger","slice","_groupBy","_sortBy","_reverse","join","VALUE_NOT_STRING","objectMerger","result","expr","Object","assign","arrayMerger","_castArray","reduce","VALUE_NOT_COLLECTION","_filter","isPlainObject","remap","OPERAND_NOT_OBJECT","JSON","stringify","parse","undefined","concat","processExprLikeValueWithLeft","VALUE_NOT_OBJECT","rightValue","_mapValues","leftValue","toRemove","_each","push","merged","Types","sanitize","separator","limit","split","OPERAND_NOT_STRING","esTemplateSetting","interpolate","template"],"mappings":"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"}