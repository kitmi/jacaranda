{"version":3,"sources":["../src/transform.js"],"sourcesContent":["// JSON Expression Syntax (JES)\nimport { get as _get, set as _set } from '@galaxar/utils';\n\nimport _isEmpty from 'lodash/isEmpty';\nimport _reduce from 'lodash/reduce';\nimport _map from 'lodash/map';\nimport _mapValues from 'lodash/mapValues';\n\nimport config, { getChildContext } from './config';\nimport ops from './transformerOperators';\n\nconst MSG = config.messages;\n\nconst PFX_MAP = '|>'; // map\nconst PFX_REDUCE = '|+'; // reduce 1. intermediate = result op [key, value] 2. result = result op intermediate\n\n/**\n * Apply a bianry operator to a value\n * @param {*} value\n * @param {*} op\n * @param {*} opValue\n * @param {*} context\n * @returns {*}\n */\nfunction applyBinaryOperator(value, op, opValue, context) {\n    const handler = config.getTransformer(op);\n\n    if (!handler) {\n        throw new Error(MSG.INVALID_TRANSFORMER_HANDLER(op));\n    }\n\n    return handler(value, opValue, context);\n}\n\n/**\n * Apply an unary operator to a value\n * @param {*} value\n * @param {*} tag\n * @param {*} context\n * @returns {*}\n */\nfunction applyUnaryOperator(value, tag, context) {\n    const handler = config.getTransformer(tag);\n\n    if (!handler) {\n        throw new Error(MSG.INVALID_TRANSFORMER_HANDLER(tag));\n    }\n\n    return handler(value, context);\n}\n\n/**\n * Apply an operator to a value with operator meta\n * @param {*} currentValue\n * @param {*} rightValue\n * @param {*} opMeta\n * @param {*} context\n * @returns {*}\n */\nfunction applyOperator(currentValue, rightValue, [op, isUnary], context) {\n    if (isUnary) {\n        return applyUnaryOperator(currentValue, op, context);\n    }\n\n    return applyBinaryOperator(currentValue, op, rightValue, context);\n}\n\n/**\n * Apply an collection iteration operator with operator meta\n * @param {*} currentValue\n * @param {*} collectionOp\n * @param {*} opMeta\n * @param {*} expectedFieldValue\n * @param {*} context\n * @returns {*}\n */\nfunction transformCollection(currentValue, collectionOp, opMeta, expectedFieldValue, context) {\n    const isUnary = opMeta[1];\n\n    switch (collectionOp) {\n        case PFX_MAP:\n            return (Array.isArray(currentValue) ? _map : _mapValues)(currentValue, (item, key) =>\n                applyOperator(item, expectedFieldValue, opMeta, getChildContext(context, currentValue, key, item))\n            );\n\n        case PFX_REDUCE:\n            if (!Array.isArray(expectedFieldValue) || (isUnary && expectedFieldValue.length !== 1)) {\n                throw new Error(MSG.INVALID_COLLECTION_OP_EXPR(ops.REDUCE, opMeta[0], expectedFieldValue));\n            }\n\n            return _reduce(\n                currentValue,\n                (result, item, key) =>\n                    applyOperator(\n                        result,\n                        expectedFieldValue[1],\n                        opMeta,\n                        getChildContext(context, currentValue, key, item)\n                    ),\n                expectedFieldValue[0]\n            );\n\n        default:\n            throw new Error(MSG.INVALID_COLLECTION_OP(collectionOp));\n    }\n}\n\n/**\n * If $ operator used, only one a time is allowed\n * e.g.\n * {\n *    $groupBy: 'key'\n * }\n *\n *\n * @param {*} currentValue\n * @param {*} jxs\n * @param {*} context\n * @param {boolean} replaceLeft - Whether the expression will replace the left value chain, like a setOp\n * @return {*}\n */\nfunction transform(currentValue, jxs, context, replaceLeft) {\n    if (jxs == null) {\n        return replaceLeft ? jxs : currentValue;\n    }\n\n    if (context == null) {\n        context = {\n            path: null,\n            $$ROOT: currentValue,\n            $$PARENT: null,\n            $$CURRENT: currentValue,\n            $$KEY: null,\n        };\n    }\n\n    if (Array.isArray(jxs)) {\n        if (replaceLeft) {\n            return jxs.map((item) => transform(undefined, item, { ...context }, true));\n        }\n\n        return jxs.reduce((result, exprItem) => transform(result, exprItem, { ...context }), currentValue);\n    }\n\n    const typeExpr = typeof jxs;\n\n    if (typeExpr === 'boolean') {\n        if (replaceLeft) {\n            return jxs;\n        }\n\n        return jxs ? currentValue : undefined;\n    }\n\n    if (typeExpr === 'number' || typeExpr === 'bigint') {\n        if (replaceLeft) {\n            return jxs;\n        }\n\n        throw new Error(MSG.SYNTAX_NUMBER_AS_EXPR);\n    }\n\n    if (typeExpr === 'string') {\n        if (jxs.startsWith('$$')) {\n            //get from context\n            const pos = jxs.indexOf('.');\n            if (pos === -1) {\n                return context[jxs];\n            }\n\n            return _get(context[jxs.substr(0, pos)], jxs.substr(pos + 1));\n        }\n\n        if (replaceLeft) {\n            return jxs;\n        }\n\n        const opMeta = config.getTransformerTagAndType(jxs);\n        if (!opMeta) {\n            throw new Error(MSG.INVALID_TRANSFORMER_OP(jxs));\n        }\n\n        if (!opMeta[1]) {\n            return applyBinaryOperator(currentValue, opMeta[0], null, context);\n        }\n\n        return applyUnaryOperator(currentValue, opMeta[0], context);\n    }\n\n    if (typeExpr !== 'object') {\n        throw new Error(MSG.SYNTAX_INVALID_EXPR(jxs));\n    }\n\n    if (replaceLeft) {\n        return _mapValues(jxs, (item) => transform(undefined, item, context, true));\n    }\n\n    let result,\n        hasOperator = false;\n\n    for (let fieldName in jxs) {\n        let expectedFieldValue = jxs[fieldName];\n\n        const l = fieldName.length;\n\n        if (l > 1) {\n            if (fieldName[0] === '$') {\n                if (result) {\n                    throw new Error(MSG.SYNTAX_OP_NOT_ALONE);\n                }\n\n                const opMeta = config.getTransformerTagAndType(fieldName);\n                if (!opMeta) {\n                    throw new Error(MSG.INVALID_TRANSFORMER_OP(fieldName));\n                }\n\n                if (hasOperator) {\n                    throw new Error(MSG.SYNTAX_OP_NOT_ALONE);\n                }\n\n                result = applyOperator(currentValue, expectedFieldValue, opMeta, context);\n                hasOperator = true;\n                continue;\n            }\n\n            if (l > 3 && fieldName[0] === '|' && fieldName[2] === '$') {\n                if (result) {\n                    throw new Error(MSG.SYNTAX_OP_NOT_ALONE);\n                }\n\n                const collectionOp = fieldName.substring(0, 2);\n                fieldName = fieldName.substring(2);\n\n                const opMeta = config.getTransformerTagAndType(fieldName);\n                if (!opMeta) {\n                    throw new Error(MSG.INVALID_TRANSFORMER_OP(fieldName));\n                }\n\n                if (hasOperator) {\n                    throw new Error(MSG.SYNTAX_OP_NOT_ALONE);\n                }\n\n                result = transformCollection(currentValue, collectionOp, opMeta, expectedFieldValue, context);\n                hasOperator = true;\n                continue;\n            }\n        }\n\n        if (hasOperator) {\n            throw new Error(MSG.SYNTAX_OP_NOT_ALONE);\n        }\n\n        let complexKey = fieldName.indexOf('.') !== -1;\n\n        //pick a field and then apply manipulation\n        let actualFieldValue =\n            currentValue != null ? (complexKey ? _get(currentValue, fieldName) : currentValue[fieldName]) : undefined;\n\n        const childFieldValue = transform(\n            actualFieldValue,\n            expectedFieldValue,\n            getChildContext(context, currentValue, fieldName, actualFieldValue)\n        );\n\n        if (typeof childFieldValue !== 'undefined') {\n            result == null && (result = {});\n            if (complexKey) {\n                _set(result, fieldName, childFieldValue);\n            } else {\n                result[fieldName] = childFieldValue;\n            }\n        }\n    }\n\n    return result;\n}\n\nexport default transform;\n"],"names":["MSG","config","messages","PFX_MAP","PFX_REDUCE","applyBinaryOperator","value","op","opValue","context","handler","getTransformer","Error","INVALID_TRANSFORMER_HANDLER","applyUnaryOperator","tag","applyOperator","currentValue","rightValue","isUnary","transformCollection","collectionOp","opMeta","expectedFieldValue","Array","isArray","_map","_mapValues","item","key","getChildContext","length","INVALID_COLLECTION_OP_EXPR","ops","REDUCE","_reduce","result","INVALID_COLLECTION_OP","transform","jxs","replaceLeft","path","$$ROOT","$$PARENT","$$CURRENT","$$KEY","map","undefined","reduce","exprItem","typeExpr","SYNTAX_NUMBER_AS_EXPR","startsWith","pos","indexOf","_get","substr","getTransformerTagAndType","INVALID_TRANSFORMER_OP","SYNTAX_INVALID_EXPR","hasOperator","fieldName","l","SYNTAX_OP_NOT_ALONE","substring","complexKey","actualFieldValue","childFieldValue","_set"],"mappings":"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"}