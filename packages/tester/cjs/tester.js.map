{"version":3,"sources":["../src/tester.js"],"sourcesContent":["import { _, batchAsync_, Box, fxargs } from '@kitmi/utils';\nimport { fs } from '@kitmi/sys';\nimport path from 'node:path';\nimport testShouldThrow_ from '@kitmi/utils/testShouldThrow_';\nimport dbgGetCallerFile from '@kitmi/utils/dbgGetCallerFile';\nimport WebServer, { startWorker, HttpClient } from '@kitmi/jacaranda';\nimport Benchmark from 'benchmark';\nimport _superagent from 'superagent';\nimport { superagent } from '@kitmi/adapters';\nimport microtime from 'microtime';\n\nimport createAuth from './createAuth';\nimport readTestData from './readTestData'\n\nfunction serialize(obj, replacer, space) {\n    let content;\n    let type;\n\n    if (typeof obj === 'string') {\n        content = obj;\n        type = 'text/plain';\n    } else {\n        content = JSON.stringify(obj, replacer, space);\n        type = 'application/json';\n    }\n\n    return { content, type };\n}\n\nconst [jacatProxy, _setJacat] = Box();\n\nexport const jacat = jacatProxy;\nexport const setJacat = _setJacat;\n\n/**\n * Jacaranda tester.\n * @class \n */\nclass JacaTester {\n    /**\n     * Test if an async function throws an error     \n     * @param {Function} fn - Function (async) that should throw an error\n     * @param {*} error\n     */\n    throw_ = testShouldThrow_;\n\n    constructor(config) {\n        this.config = config;\n        this.startedServers = {};\n    }\n\n    /**\n     * Load fixtures and declare test case with `it`.     \n     * @param {Function} [testCase] - Test case to run after loading fixtures. async (data) => {}\n     */\n    loadFixtures(testCase) {\n        let fixturePath = this.config.fixturePath || './test/fixtures';\n        const fixtureType = this.config.fixtureType || 'json';\n\n        const callerFileName = dbgGetCallerFile();        \n        const baseName = path.basename(callerFileName, '.spec.js');\n        const testCaseDir = path.resolve(fixturePath, baseName);\n\n        if (!fs.existsSync(testCaseDir)) {\n            throw new Error('Fixture path not exist: ' + testCaseDir);\n        }\n\n        const files = fs.readdirSync(testCaseDir);\n        files.forEach((fixtureFile) => {            \n            const fixtureFilePath = path.join(testCaseDir, fixtureFile);\n            const testCaseName = path.basename(fixtureFilePath, '.' + fixtureType);\n            const testCaseData = readTestData(fixtureFilePath, fixtureType);\n            \n            it(testCaseName, async () => {\n                jacat.param('fixturePath', fixtureFilePath);\n                jacat.param('data', testCaseData);\n\n                await testCase(testCaseData);\n            });\n        });\n    }\n\n    async profile_(name, fn) {\n        const t1 = microtime.now();\n        await fn();\n        const t2 = microtime.now();\n        const elapsed = t2 - t1;\n        console.log(name, 'elapsed:', elapsed, 'ms');\n\n        this.attach(`Profiling result - ${name}`, { elapsed });\n    }\n\n    // ------------------------------\n    // allure\n    // ------------------------------\n\n    /**\n     * Mark a step of a test case.\n     * @param {String} name - Name of the step.\n     * @param {Function} fn - Function to run.\n     * @async\n     */\n    async step_(name, fn) {\n        if (allure) {\n            await allure.step(name, fn);\n        }\n    }\n\n    /**\n     * Record a parameter in a test case report.\n     * @param {String} name - Name of the parameter.\n     * @param {*} value - Value of the parameter.\n     */\n    param(name, value) {\n        if (allure) {\n            const { content, type } = serialize(value);\n            allure.parameter(name, content, type);\n        }\n    }\n\n    /**\n     * Attach an object in a test case report.\n     * @param {String} name - Name of the attachment.\n     * @param {*} value - Value of the attachment.\n     */\n    attach(name, value) {\n        if (allure) {\n            const { content, type } = serialize(value, null, 4);\n            allure.attachment(name, content, type);\n        }\n    }\n\n    // ------------------------------\n    // server\n    // ------------------------------\n\n    /**\n     * Start a server for code coverage testing.\n     * @param  {String} [name] - Name of the server to start, should be configured in test config.\n     * @param  {Object} [options]\n     * @async\n     */\n    async startServer_(...args) {\n        let [name, options] = fxargs(args, ['string?', 'object?']);\n\n        if (name && this.startedServers[name]) {\n            return this.startedServers[name];\n        }\n\n        const serverOptions = name ? this.config.servers?.[name] : null;\n\n        if (!serverOptions) {\n            throw new Error(`Server options for \"${name}\" not found.`);\n        }\n\n        const server = new WebServer(name, { ...serverOptions, ...options });\n        await server.start_();\n\n        if (name) {\n            this.startedServers[name] = server;\n        }\n\n        return server;\n    }\n\n    /**\n     * Stop a running server.\n     * @param {WebServer} server\n     * @async\n     */\n    async stopServer_(server) {\n        if (typeof server === 'string') {\n            server = this.startedServers[server];\n        }\n\n        if (server == null) {\n            return;\n        }\n\n        await server.stop_();\n\n        delete this.startedServers[server.name];\n    }\n\n    /**\n     * Stop all running servers.\n     * @async\n     */\n    async closeAllServers_() {\n        await batchAsync_(Object.values(this.startedServers), async (server) => {\n            await server.stop_();\n        });\n        this.startedServers = {};\n    }\n\n    // ------------------------------\n    // worker\n    // ------------------------------\n\n    /**\n     * Start a worker app for testing\n     * @param {String} [name] - Name of the worker to start.\n     * @param {function} testToRun - Test (async) function to run.\n     * @param {*} [options] - Options for starting the worker.\n     * @async\n     */\n    async startWorker_(...args) {\n        let [name, testToRun, options] = fxargs(args, ['string?', 'function', 'object?']);\n\n        const workerOptions = name ? this.config.workers?.[name] : null;\n\n        let err;\n\n        const result = await startWorker(\n            async (app) => {\n                try {\n                    return await testToRun(app);\n                } catch (e) {\n                    console.error(e);\n                    err = e;\n                }\n            },\n            {\n                ...workerOptions,\n                ...options,\n            }\n        );\n\n        if (err) {\n            throw err;\n        }\n\n        return result;\n    }\n\n    // ------------------------------\n    // httpClient\n    // ------------------------------\n\n    /**\n     * Create a http client for testing.\n     * @param {String|WebServer} server\n     * @param {String|Function} [authenticator]\n     * @param {Function} testToRun\n     * @param {*} options\n     * @async\n     */\n    async withClient_(...args) {\n        let [server, authenticator, testToRun, options] = fxargs(args, [\n            'string|object?',\n            'string?',\n            'function',\n            'object?',\n        ]);\n\n        if (typeof server !== 'object') {\n            server = await this.startServer_(server);\n        }\n\n        const authConfig = authenticator ? this.config.authentications?.[authenticator] : null;\n        authenticator &&= createAuth(authenticator /** authticationKey */, authConfig ?? {});\n\n        const client = new HttpClient(superagent(_superagent), { endpoint: server.host, ...options });\n\n        client.onResponse = (result, req, res) => {\n            this.attach(`${req.method} ${req.url}`, { headers: res.header, response: result });\n        };\n\n        authenticator && (await authenticator(client));\n\n        await testToRun(client, server);\n    }\n\n    // ------------------------------\n    // benchmark\n    // ------------------------------\n\n    /**\n     * Run benchmark against given methods.\n     * @param {*} mapOfMethods - Map of name to function with payload\n     * @param {*} verifier - Function to verify the result of each method\n     * @param {*} payload\n     */\n    async benchmark_(mapOfMethods, verifier, payload) {\n        const suite = new Benchmark.Suite();\n\n        _.each(mapOfMethods, (f, name) => {\n            verifier(f(payload));\n\n            suite.add(name, function () {\n                f(payload);\n            });\n        });\n\n        return new Promise((resolve, reject) => {\n            const self = this;\n\n            suite\n                .on('cycle', function (event) {\n                    const cycleMessage = String(event.target);\n                    console.log(cycleMessage);\n                    self.attach('cycle', cycleMessage);\n                })\n                .on('complete', function () {\n                    const completeMessage = 'The fastest is ' + this.filter('fastest').map('name');\n                    self.attach('complete', completeMessage);\n                    resolve();\n                })\n                .on('error', (event) => reject(String(event.target)))\n                .run({ async: true });\n        });\n    }\n}\n\nexport default JacaTester;\n"],"names":["jacat","setJacat","serialize","obj","replacer","space","content","type","JSON","stringify","jacatProxy","_setJacat","Box","JacaTester","loadFixtures","testCase","fixturePath","config","fixtureType","callerFileName","dbgGetCallerFile","baseName","path","basename","testCaseDir","resolve","fs","existsSync","Error","files","readdirSync","forEach","fixtureFile","fixtureFilePath","join","testCaseName","testCaseData","readTestData","it","param","profile_","name","fn","t1","microtime","now","t2","elapsed","console","log","attach","step_","allure","step","value","parameter","attachment","startServer_","args","options","fxargs","startedServers","serverOptions","servers","server","WebServer","start_","stopServer_","stop_","closeAllServers_","batchAsync_","Object","values","startWorker_","testToRun","workerOptions","workers","err","result","startWorker","app","e","error","withClient_","authenticator","authConfig","authentications","createAuth","client","HttpClient","superagent","_superagent","endpoint","host","onResponse","req","res","method","url","headers","header","response","benchmark_","mapOfMethods","verifier","payload","suite","Benchmark","Suite","_","each","f","add","Promise","reject","self","on","event","cycleMessage","String","target","completeMessage","filter","map","run","async","constructor","throw_","testShouldThrow_"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}