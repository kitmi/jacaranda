{"version":3,"sources":["../src/testerCore.js"],"sourcesContent":["import { _, esmCheck, toBoolean, batchAsync_ } from '@kitmi/utils';\nimport { startWorker, HttpClient } from '@kitmi/jacaranda';\nimport Benchmark from 'benchmark';\nimport path from \"node:path\";\nimport loadFixtures from './loadFixtures';\n\nfunction serialize(obj, replacer, space) {\n    let content;\n    let type;\n\n    if (typeof obj === 'string') {\n        content = obj;\n        type = 'text/plain';\n    } else {\n        content = JSON.stringify(obj, replacer, space);\n        type = 'application/json';\n    }\n\n    return { content, type };\n}\n\nclass GxTester {\n    loadFixtures = loadFixtures;\n\n    constructor(config) {\n        this.config = config;\n        this.startedServers = {};\n        this.isCoverMode = process.env.COVER && toBoolean(process.env.COVER);\n    }\n\n    // ------------------------------\n    // allure\n    // ------------------------------\n\n    async step_(name, fn) {\n        if (allure) {\n            await allure.step(name, fn);\n        }\n    }\n\n    param(name, value) {\n        if (allure) {\n            const { content, type } = serialize(value);\n            allure.parameter(name, content, type);\n        }\n    }\n\n    attach(name, value) {\n        if (allure) {\n            const { content, type } = serialize(value, null, 4);\n            allure.attachment(name, content, type);\n        }\n    }\n\n    // ------------------------------\n    // server\n    // ------------------------------\n\n    // specially for server code coverage test with supertest agent\n    async startServer_(name) {        \n        if (this.startedServers[name]) {\n            return this.startedServers[name];\n        }\n\n        const { servers } = this.config;\n        const serverEntry = servers?.[name];\n\n        if (!serverEntry) {\n            throw new Error(`Server entry for \"${name}\" not found`);\n        }\n\n        const _serverInfo = typeof serverEntry === 'string' ? { entry: serverEntry } : serverEntry;\n\n        const createServer = esmCheck(require(path.resolve(process.cwd(), _serverInfo.entry)));\n\n        const server = await createServer(name, _serverInfo.options);\n        await server.start_();\n\n        this.startedServers[name] = server;\n        return server;\n    }\n\n    async stopServer_(server) {\n        if (typeof server === 'string') {\n            server = this.startedServers[server];\n        }\n\n        await server.stop_();\n\n        delete this.startedServers[server.name];\n    }\n\n    async closeAllServers_() {\n        await batchAsync_(Object.values(this.startedServers), async (server) => {\n            await server.stop_();\n        });\n        this.startedServers = {};\n    }\n\n    // ------------------------------\n    // worker\n    // ------------------------------\n\n    /**\n     * Start a worker app for testing\n     * @param {function} testToRun - Test (async) function to run.\n     * @param {*} options - Options passed to the test worker, see startWorker of @kitmi/jacaranda.\n     * @async\n     */\n    async startWorker_(testToRun, options) {\n        let err;\n\n        const result = await startWorker(\n            async (app) => {\n                try {\n                    return await testToRun(app);\n                } catch (e) {\n                    console.error(e);\n                    err = e;\n                }\n            },\n            {\n                workerName: 'tester',\n                configName: 'test',\n                configPath: 'test/conf',\n                ignoreUncaught: true,\n                exitOnUncaught: false,\n                ...this.config.workerOptions,\n                ...options,\n            }\n        );\n\n        if (err) {\n            throw err;\n        }\n\n        return result;\n    }\n\n    // ------------------------------\n    // httpClient\n    // ------------------------------\n\n    /**\n     *\n     * @param {*} server\n     * @param {*} [authenticator]\n     * @param {*} testToRun\n     * @param {*} options\n     * @returns\n     */\n    async withHttpClient_(server, authenticator, testToRun, options) {\n        if (typeof options === 'undefined') {\n            if (typeof testToRun === 'undefined') {\n                testToRun = authenticator;\n                authenticator = null;\n            } else if (typeof testToRun === 'object') {\n                options = testToRun;\n                testToRun = authenticator;\n                authenticator = null;\n            }\n        }\n\n        const { worker: workerOptions, client: clientOptions } = options || {};\n        if (typeof server === 'string') {\n            server = await this.startServer_(server);\n        }\n\n        return this.startWorker_(async (app) => {\n            if (typeof authenticator === 'string') {\n                authenticator = defaultUserAuth(authenticator /** authticationKey */);\n            }\n\n            const { authentication: authConfig } = this.config;\n\n            const getHttpClient_ = async () => {\n                let agentClientSetting =\n                    this.config.httpAgent?.[this.isCoverMode ? 'coverage' : 'normal'];\n\n                if (typeof agentClientSetting === 'string') {\n                    agentClientSetting = { adapter: agentClientSetting };\n                } else if (Array.isArray(agentClientSetting)) {\n                    agentClientSetting = { adapter: agentClientSetting[0], options: agentClientSetting[1] };\n                }\n                    \n                const agentCreatorModule = agentClientSetting?.adapter ?? (this.isCoverMode ? 'supertest' : 'superagent');\n                const agentCreator = esmCheck(require(`@kitmi/adapters/${agentCreatorModule}`));\n\n                const agent = agentCreator();\n                if (this.isCoverMode) {                    \n                    agent.server = server.httpServer;\n                }\n\n                const client = new HttpClient(agent, {  ...agentClientSetting.options , ...clientOptions });                \n\n                client.onResponse = (result, req, res) => {\n                    this.attach(`${req.method} ${req.url}`, { headers: res.header, response: result });\n                };\n\n                if (!authenticator) {\n                    delete client.onSending;\n                    return client;\n                }\n\n                await authenticator(client, authConfig);\n\n                return client;\n            }\n\n            const client = await getHttpClient_();\n            return testToRun(client, app);\n        }, workerOptions);\n    }\n\n    // ------------------------------\n    // benchmark\n    // ------------------------------\n\n    /**\n     * Run benchmark against given methods.\n     * @param {*} mapOfMethods - Map of name to function with payload\n     * @param {*} verifier - Function to verify the result of each method\n     * @param {*} payload\n     */\n    async benchmark_(mapOfMethods, verifier, payload) {\n        const suite = new Benchmark.Suite();\n\n        _.each(mapOfMethods, (f, name) => {\n            verifier(f(payload));\n\n            suite.add(name, function () {\n                f(payload);\n            });\n        });\n\n        return new Promise((resolve, reject) => {\n            const self = this;\n\n            suite\n                .on('cycle', function (event) {\n                    const cycleMessage = String(event.target);\n                    console.log(cycleMessage);\n                    self.attach('cycle', cycleMessage);\n                })\n                .on('complete', function () {\n                    const completeMessage = 'The fastest is ' + this.filter('fastest').map('name');\n                    self.attach('complete', completeMessage);\n                    resolve();\n                })\n                .on('error', (event) => reject(String(event.target)))\n                .run({ async: true });\n        });\n    }\n}\n\nexport default GxTester;\n"],"names":["serialize","obj","replacer","space","content","type","JSON","stringify","GxTester","step_","name","fn","allure","step","param","value","parameter","attach","attachment","startServer_","startedServers","servers","config","serverEntry","Error","_serverInfo","entry","createServer","esmCheck","require","path","resolve","process","cwd","server","options","start_","stopServer_","stop_","closeAllServers_","batchAsync_","Object","values","startWorker_","testToRun","err","result","startWorker","app","e","console","error","workerName","configName","configPath","ignoreUncaught","exitOnUncaught","workerOptions","withHttpClient_","authenticator","worker","client","clientOptions","defaultUserAuth","authentication","authConfig","getHttpClient_","agentClientSetting","httpAgent","isCoverMode","adapter","Array","isArray","agentCreatorModule","agentCreator","agent","httpServer","HttpClient","onResponse","req","res","method","url","headers","header","response","onSending","benchmark_","mapOfMethods","verifier","payload","suite","Benchmark","Suite","_","each","f","add","Promise","reject","self","on","event","cycleMessage","String","target","log","completeMessage","filter","map","run","async","constructor","loadFixtures","env","COVER","toBoolean"],"mappings":";;;;+BA+PA;;;eAAA;;;uBA/PoD;2BACZ;kEAClB;iEACL;qEACQ;;;;;;;;;;;;;;;;;;;AAEzB,SAASA,UAAUC,GAAG,EAAEC,QAAQ,EAAEC,KAAK;IACnC,IAAIC;IACJ,IAAIC;IAEJ,IAAI,OAAOJ,QAAQ,UAAU;QACzBG,UAAUH;QACVI,OAAO;IACX,OAAO;QACHD,UAAUE,KAAKC,SAAS,CAACN,KAAKC,UAAUC;QACxCE,OAAO;IACX;IAEA,OAAO;QAAED;QAASC;IAAK;AAC3B;AAEA,MAAMG;IASF,iCAAiC;IACjC,SAAS;IACT,iCAAiC;IAEjC,MAAMC,MAAMC,IAAI,EAAEC,EAAE,EAAE;QAClB,IAAIC,QAAQ;YACR,MAAMA,OAAOC,IAAI,CAACH,MAAMC;QAC5B;IACJ;IAEAG,MAAMJ,IAAI,EAAEK,KAAK,EAAE;QACf,IAAIH,QAAQ;YACR,MAAM,EAAER,OAAO,EAAEC,IAAI,EAAE,GAAGL,UAAUe;YACpCH,OAAOI,SAAS,CAACN,MAAMN,SAASC;QACpC;IACJ;IAEAY,OAAOP,IAAI,EAAEK,KAAK,EAAE;QAChB,IAAIH,QAAQ;YACR,MAAM,EAAER,OAAO,EAAEC,IAAI,EAAE,GAAGL,UAAUe,OAAO,MAAM;YACjDH,OAAOM,UAAU,CAACR,MAAMN,SAASC;QACrC;IACJ;IAEA,iCAAiC;IACjC,SAAS;IACT,iCAAiC;IAEjC,+DAA+D;IAC/D,MAAMc,aAAaT,IAAI,EAAE;QACrB,IAAI,IAAI,CAACU,cAAc,CAACV,KAAK,EAAE;YAC3B,OAAO,IAAI,CAACU,cAAc,CAACV,KAAK;QACpC;QAEA,MAAM,EAAEW,OAAO,EAAE,GAAG,IAAI,CAACC,MAAM;QAC/B,MAAMC,cAAcF,SAAS,CAACX,KAAK;QAEnC,IAAI,CAACa,aAAa;YACd,MAAM,IAAIC,MAAM,CAAC,kBAAkB,EAAEd,KAAK,WAAW,CAAC;QAC1D;QAEA,MAAMe,cAAc,OAAOF,gBAAgB,WAAW;YAAEG,OAAOH;QAAY,IAAIA;QAE/E,MAAMI,eAAeC,IAAAA,eAAQ,EAACC,QAAQC,iBAAI,CAACC,OAAO,CAACC,QAAQC,GAAG,IAAIR,YAAYC,KAAK;QAEnF,MAAMQ,SAAS,MAAMP,aAAajB,MAAMe,YAAYU,OAAO;QAC3D,MAAMD,OAAOE,MAAM;QAEnB,IAAI,CAAChB,cAAc,CAACV,KAAK,GAAGwB;QAC5B,OAAOA;IACX;IAEA,MAAMG,YAAYH,MAAM,EAAE;QACtB,IAAI,OAAOA,WAAW,UAAU;YAC5BA,SAAS,IAAI,CAACd,cAAc,CAACc,OAAO;QACxC;QAEA,MAAMA,OAAOI,KAAK;QAElB,OAAO,IAAI,CAAClB,cAAc,CAACc,OAAOxB,IAAI,CAAC;IAC3C;IAEA,MAAM6B,mBAAmB;QACrB,MAAMC,IAAAA,kBAAW,EAACC,OAAOC,MAAM,CAAC,IAAI,CAACtB,cAAc,GAAG,OAAOc;YACzD,MAAMA,OAAOI,KAAK;QACtB;QACA,IAAI,CAAClB,cAAc,GAAG,CAAC;IAC3B;IAEA,iCAAiC;IACjC,SAAS;IACT,iCAAiC;IAEjC;;;;;KAKC,GACD,MAAMuB,aAAaC,SAAS,EAAET,OAAO,EAAE;QACnC,IAAIU;QAEJ,MAAMC,SAAS,MAAMC,IAAAA,sBAAW,EAC5B,OAAOC;YACH,IAAI;gBACA,OAAO,MAAMJ,UAAUI;YAC3B,EAAE,OAAOC,GAAG;gBACRC,QAAQC,KAAK,CAACF;gBACdJ,MAAMI;YACV;QACJ,GACA;YACIG,YAAY;YACZC,YAAY;YACZC,YAAY;YACZC,gBAAgB;YAChBC,gBAAgB;YAChB,GAAG,IAAI,CAAClC,MAAM,CAACmC,aAAa;YAC5B,GAAGtB,OAAO;QACd;QAGJ,IAAIU,KAAK;YACL,MAAMA;QACV;QAEA,OAAOC;IACX;IAEA,iCAAiC;IACjC,aAAa;IACb,iCAAiC;IAEjC;;;;;;;KAOC,GACD,MAAMY,gBAAgBxB,MAAM,EAAEyB,aAAa,EAAEf,SAAS,EAAET,OAAO,EAAE;QAC7D,IAAI,OAAOA,YAAY,aAAa;YAChC,IAAI,OAAOS,cAAc,aAAa;gBAClCA,YAAYe;gBACZA,gBAAgB;YACpB,OAAO,IAAI,OAAOf,cAAc,UAAU;gBACtCT,UAAUS;gBACVA,YAAYe;gBACZA,gBAAgB;YACpB;QACJ;QAEA,MAAM,EAAEC,QAAQH,aAAa,EAAEI,QAAQC,aAAa,EAAE,GAAG3B,WAAW,CAAC;QACrE,IAAI,OAAOD,WAAW,UAAU;YAC5BA,SAAS,MAAM,IAAI,CAACf,YAAY,CAACe;QACrC;QAEA,OAAO,IAAI,CAACS,YAAY,CAAC,OAAOK;YAC5B,IAAI,OAAOW,kBAAkB,UAAU;gBACnCA,gBAAgBI,gBAAgBJ,cAAc,oBAAoB;YACtE;YAEA,MAAM,EAAEK,gBAAgBC,UAAU,EAAE,GAAG,IAAI,CAAC3C,MAAM;YAElD,MAAM4C,iBAAiB;gBACnB,IAAIC,qBACA,IAAI,CAAC7C,MAAM,CAAC8C,SAAS,EAAE,CAAC,IAAI,CAACC,WAAW,GAAG,aAAa,SAAS;gBAErE,IAAI,OAAOF,uBAAuB,UAAU;oBACxCA,qBAAqB;wBAAEG,SAASH;oBAAmB;gBACvD,OAAO,IAAII,MAAMC,OAAO,CAACL,qBAAqB;oBAC1CA,qBAAqB;wBAAEG,SAASH,kBAAkB,CAAC,EAAE;wBAAEhC,SAASgC,kBAAkB,CAAC,EAAE;oBAAC;gBAC1F;gBAEA,MAAMM,qBAAqBN,oBAAoBG,WAAY,CAAA,IAAI,CAACD,WAAW,GAAG,cAAc,YAAW;gBACvG,MAAMK,eAAe9C,IAAAA,eAAQ,EAACC,QAAQ,CAAC,gBAAgB,EAAE4C,mBAAmB,CAAC;gBAE7E,MAAME,QAAQD;gBACd,IAAI,IAAI,CAACL,WAAW,EAAE;oBAClBM,MAAMzC,MAAM,GAAGA,OAAO0C,UAAU;gBACpC;gBAEA,MAAMf,SAAS,IAAIgB,qBAAU,CAACF,OAAO;oBAAG,GAAGR,mBAAmBhC,OAAO;oBAAG,GAAG2B,aAAa;gBAAC;gBAEzFD,OAAOiB,UAAU,GAAG,CAAChC,QAAQiC,KAAKC;oBAC9B,IAAI,CAAC/D,MAAM,CAAC,CAAC,EAAE8D,IAAIE,MAAM,CAAC,CAAC,EAAEF,IAAIG,GAAG,CAAC,CAAC,EAAE;wBAAEC,SAASH,IAAII,MAAM;wBAAEC,UAAUvC;oBAAO;gBACpF;gBAEA,IAAI,CAACa,eAAe;oBAChB,OAAOE,OAAOyB,SAAS;oBACvB,OAAOzB;gBACX;gBAEA,MAAMF,cAAcE,QAAQI;gBAE5B,OAAOJ;YACX;YAEA,MAAMA,SAAS,MAAMK;YACrB,OAAOtB,UAAUiB,QAAQb;QAC7B,GAAGS;IACP;IAEA,iCAAiC;IACjC,YAAY;IACZ,iCAAiC;IAEjC;;;;;KAKC,GACD,MAAM8B,WAAWC,YAAY,EAAEC,QAAQ,EAAEC,OAAO,EAAE;QAC9C,MAAMC,QAAQ,IAAIC,kBAAS,CAACC,KAAK;QAEjCC,QAAC,CAACC,IAAI,CAACP,cAAc,CAACQ,GAAGtF;YACrB+E,SAASO,EAAEN;YAEXC,MAAMM,GAAG,CAACvF,MAAM;gBACZsF,EAAEN;YACN;QACJ;QAEA,OAAO,IAAIQ,QAAQ,CAACnE,SAASoE;YACzB,MAAMC,OAAO,IAAI;YAEjBT,MACKU,EAAE,CAAC,SAAS,SAAUC,KAAK;gBACxB,MAAMC,eAAeC,OAAOF,MAAMG,MAAM;gBACxCvD,QAAQwD,GAAG,CAACH;gBACZH,KAAKnF,MAAM,CAAC,SAASsF;YACzB,GACCF,EAAE,CAAC,YAAY;gBACZ,MAAMM,kBAAkB,oBAAoB,IAAI,CAACC,MAAM,CAAC,WAAWC,GAAG,CAAC;gBACvET,KAAKnF,MAAM,CAAC,YAAY0F;gBACxB5E;YACJ,GACCsE,EAAE,CAAC,SAAS,CAACC,QAAUH,OAAOK,OAAOF,MAAMG,MAAM,IACjDK,GAAG,CAAC;gBAAEC,OAAO;YAAK;QAC3B;IACJ;IApOAC,YAAY1F,MAAM,CAAE;QAFpB2F,uBAAAA,gBAAeA,qBAAY;QAGvB,IAAI,CAAC3F,MAAM,GAAGA;QACd,IAAI,CAACF,cAAc,GAAG,CAAC;QACvB,IAAI,CAACiD,WAAW,GAAGrC,QAAQkF,GAAG,CAACC,KAAK,IAAIC,IAAAA,gBAAS,EAACpF,QAAQkF,GAAG,CAACC,KAAK;IACvE;AAiOJ;MAEA,WAAe3G"}